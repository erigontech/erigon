package vm

import (
	"bytes"
	"fmt"
	"math/big"
	"testing"

	libcommon "github.com/ledgerwatch/erigon-lib/common"
	"github.com/ledgerwatch/erigon/common"
	"github.com/ledgerwatch/erigon/smt/pkg/utils"
)

var (
	big0    = "0x0"
	big10   = "0xA"
	big8194 = "0x4362992542477663717851936978935131449793056647984930769727331144758885327396477180865056938100807948895829167184628101092439483280708736254443919060310219196315625195368771958154439300912192820638787406454366552787087546170437298240485162215607545204071601010143199668800040318400106143347203621191223523809402006520781902615644021249458240059389704141174204983375715675011074785117376352222470062777399781626711300563259602464423681025754018312053305974263344188969629529771248980526071030076659596905462974889729109472300110511532180826007171046803782796673989031518735406948199987603844482062620200462245085965970061368422995866518188131145286022923313720886659881297584554541006505638064672021710493743985235686765784724749625581242661619542957739331509712669629981483974047475025439881560468087294466997834483879428025054448330826861632628266300549124108089243710259641107036642083513218529644197458275019683869291929836739053709535161089793752074107911059764290862446321738763309837359967845656970965642396469704242225935055025258110445450634513533474484631974552083514150702181347159662776937735822665260280348854141881022681248016522901983338033429758615315744308323914202315651871629411120219742486244363183380691816463891709919510110954240032816474235720019110994911047415254041975362327446394608846423841233425623767284758856151474904877925994910414614465195424699289652133941755141296099005677668732049124312838917214149491218297488380914814491105455781163479225033689420594030284158477549798519467232755078651263112612317572716372574593363046954327278252011977691163019820245155273233720318594772928716635063672142260864628461611968481104622431492431749909867366113451950834797800608124927450376812342775355778628245384946816936107284411835819804788348306184746491185178145806483026037404075624095095286158131104834707914358927865321235573218660677744740313402566273347778120205749965245195337469060954381619617093823714895798100908738469617471419018441897508079072102306423524152309082830871768887908361541754343376381968464399410155615898622815775892344363722387853443070119859753658392742823855018245989423311254495333155625236017152069285699234655850685334112036931033403492238456474895125688405840794462989547420387584356756721765358234099291470164452850555174702270601361451880127720093591313861274188952976928112060758758641675291904003261750442609017080654382603501735404588492856909066421614327125876363226305875802350647988746022661902863171584"
)

func uint64To32Bytes(input int) []byte {
	bigInt := new(big.Int).SetUint64(uint64(input))
	bytes := bigInt.Bytes()
	result := make([]byte, 32)
	copy(result[32-len(bytes):], bytes)
	return result
}

func uint64ToDeterminedBytes(input *big.Int, length int) []byte {
	bytes := input.Bytes()
	result := make([]byte, length)
	copy(result[length-len(bytes):], bytes)
	return result
}

// This relies on PrecompiledContractsForkID13Durian.
func testPrecompiledZkevm(t *testing.T, addr string, test precompiledTest) {
	p := PrecompiledContractsForkID13Durian[libcommon.HexToAddress(addr)]
	in := libcommon.Hex2Bytes(test.Input)
	gas := p.RequiredGas(in)
	t.Run(fmt.Sprintf("%s-Gas=%d", test.Name, gas), func(t *testing.T) {
		t.Parallel()
		if res, _, err := RunPrecompiledContract(p, in, gas); err != nil {
			t.Error(err)
		} else if common.Bytes2Hex(res) != test.Expected {
			t.Errorf("Expected %v, got %v", test.Expected, common.Bytes2Hex(res))
		}
		if expGas := test.Gas; expGas != gas {
			t.Errorf("%v: gas wrong, expected %d, got %d", test.Name, expGas, gas)
		}
		// Verify that the precompile did not touch the input buffer
		exp := libcommon.Hex2Bytes(test.Input)
		if !bytes.Equal(in, exp) {
			t.Errorf("Precompiled %v modified input data", addr)
		}
	})
}

func testJsonZkevm(name, addr string, t *testing.T) {
	tests, err := loadJson(name)
	if err != nil {
		t.Fatal(err)
	}
	for _, test := range tests {
		testPrecompiledZkevm(t, addr, test)
	}
}

func Test_ModExpZkevm_Gas(t *testing.T) {
	modExp := bigModExp_zkevm{enabled: true, eip2565: true}

	cases := map[string]struct {
		base       string
		exp        string
		mod        string
		nonZeroGas bool
		revert     bool
	}{
		"simple test": {
			big10,
			big10,
			big10,
			true,
			false,
		},
		"0 mod - normal gas": {
			big10,
			big10,
			big0,
			true,
			false,
		},
		"base 0 - mod < 8192 - normal gas": {
			big0,
			big10,
			big10,
			true,
			false,
		},
		"base 0 - mod > 8192 - 0 gas": {
			big0,
			big10,
			big8194,
			false,
			true,
		},
		"base over 8192 - 0 gas": {
			big8194,
			big10,
			big10,
			false,
			true,
		},
		"exp over 8192 - 0 gas": {
			big10,
			big8194,
			big10,
			false,
			true,
		},
		"mod over 8192 - 0 gas": {
			big10,
			big10,
			big8194,
			false,
			true,
		},
		// tests beyond here are taken from the test vectors here https://github.com/0xPolygonHermez/zkevm-testvectors/blob/2b70027e11a427c15994713b41ef9b6794c2f3bb/tools-inputs/data/calldata/pre-modexp.json#L787
		"pre-modexp-test-case_0": {
			"0x1",
			"0x1",
			"0x1111111111000000000000000000000000000000000000000000000000000000",
			true,
			false,
		},
		"pre-modexp-test-case_1": {
			"0x7",
			"0x8",
			"0x9",
			true,
			false,
		},
		"pre-modexp_0": {
			"0x00000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000",
			"0x1",
			"0x9",
			true,
			false,
		},
		"pre-modexp_1": {
			"0x00000000000000000000000000000000000000000000000000000000000001110000000000000000000000000000000000000000000000000000000000000000",
			"0x1000",
			"0x0000000000000000000000000000000000000000000000000000000000ffffff0000000000000000000000000000000000000000000000000000000000000000",
			true,
			false,
		},
		"pre-modexp_10": {
			"0x3",
			"0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2e",
			"0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f",
			true,
			false,
		},
		"pre-modexp_12": {
			"0x10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
			"0x1",
			"0x9",
			true,
			false,
		},
		"pre-modexp_5": {
			"0xf000000000000000000000000000000000000000000000000000000000000000",
			"0xf000000000000000000000000000000000000000000000000000000000000010",
			"0xf000000000000000000000000000000000000000000000000000000000000055",
			true,
			false,
		},
		"pre-modexp_6": {
			"0x20",
			"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
			"0xf000000000000000000000000000000000000000000000000000000000000055",
			true,
			false,
		},
		"pre-modexp_7": {
			"0x000000000000000000000000000000000000000000000000000000000000006400000000000000000000000000000000000000000000000000000000002b32af000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004339f6e1061a",
			"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
			"0x0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001eb07e0ea000000000000000000000000000000000000000000000000000000056101669d",
			true,
			false,
		},
		"pre-modexp_8": {
			"0x10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
			"0x1",
			"0x00000000000000000000000000000000000000000000000000000000000000090000000000000000000000000000000000000000000000000000000000000000",
			true,
			false,
		},
	}

	for name, test := range cases {
		t.Run(name, func(t *testing.T) {
			input := make([]byte, 0)

			bigBase := utils.ConvertHexToBigInt(test.base)
			bigExp := utils.ConvertHexToBigInt(test.exp)
			bigMod := utils.ConvertHexToBigInt(test.mod)

			base := len(bigBase.Bytes())
			exp := len(bigExp.Bytes())
			mod := len(bigMod.Bytes())

			input = append(input, uint64To32Bytes(base)...)
			input = append(input, uint64To32Bytes(exp)...)
			input = append(input, uint64To32Bytes(mod)...)
			input = append(input, uint64ToDeterminedBytes(bigBase, base)...)
			input = append(input, uint64ToDeterminedBytes(bigExp, exp)...)
			input = append(input, uint64ToDeterminedBytes(bigMod, mod)...)

			gas := modExp.RequiredGas(input)
			if test.nonZeroGas && gas == 0 {
				t.Errorf("Expected non-zero gas")
			} else if !test.nonZeroGas && gas != 0 {
				t.Errorf("Expected zero gas")
			}

			_, err := modExp.Run(input)
			if test.revert && err == nil {
				t.Errorf("Expected revert")
			} else if !test.revert && err != nil {
				t.Errorf("Unexpected revert: %s", err)
			}
		})
	}
}

func TestP256VerifyZkevm(t *testing.T) {
	testJsonZkevm("p256Verify", "0x0000000000000000000000000000000000000100", t)
}

// EIP2565 is enabled by default.
func TestBigModExpZkevm(t *testing.T) {
	testJsonZkevm("modexp_eip2565", "0x0000000000000000000000000000000000000005", t)
}
