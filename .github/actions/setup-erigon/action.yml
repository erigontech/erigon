name: Setup Erigon environment
description: Install Go, restore/save module cache

inputs:
  fetch-depth:
    description: "Number of commits to fetch (0 for all history)"
    required: false
    default: '0'
  filter:
    description: "Partial clone filter (e.g. blob:none)"
    required: false
    default: 'blob:none'
  submodules:
    description: "Clone submodules (recursive shallow clone)"
    required: false
    default: 'false'
  lfs:
    description: "'false' to skip, 'tests' for test fixtures only"
    required: false
    default: 'false'
  cleanup-space:
    description: "Remove large pre-installed packages to free disk space (Linux only)"
    required: false
    default: 'false'
  modcache:
    description: "Use the default mod cache handling"
    required: false
    default: 'true'

outputs:
  goversion:
    description: "Full Go version string (e.g. go1.25.7)"
    value: ${{ steps.go-env.outputs.goversion }}
  build:
    description: "GOCACHE path"
    value: ${{ steps.go-env.outputs.build }}
  modcache:
    description: "GOMODCACHE path"
    value: ${{ steps.go-env.outputs.modcache }}

runs:
  using: composite
  steps:
    # Frees 20-30GB but takes ~30s. Only enable for workflows that hit the
    # disk ceiling. If space is tight, first check whether caches have blown
    # out in size before turning this on.
    - name: Set compact time format
      shell: bash
      run: echo "TIMEFORMAT=real %Rs user %Us sys %Ss" >> "$GITHUB_ENV"

    - name: Display free disk space
      shell: bash
      run: time df -h

    - name: Cleanup space
      if: ${{ inputs.cleanup-space == 'true' && runner.os == 'Linux' }}
      shell: bash
      run: |
        rm -fr /opt/az \
               /opt/microsoft \
               /usr/share/dotnet \
               /usr/share/miniconda \
               /usr/share/swift
        df -h

    - name: "Use D: drive for temp files on Windows"
      if: ${{ runner.os == 'Windows' }}
      shell: bash
      run: |
        mkdir -p D:/tmp
        echo "TEMP=D:/tmp" >> "$GITHUB_ENV"
        echo "TMP=D:/tmp" >> "$GITHUB_ENV"
        echo "TMPDIR=D:/tmp" >> "$GITHUB_ENV"

    - name: Checkout code
      uses: actions/checkout@v6
      with:
        fetch-depth: ${{ inputs.fetch-depth }}
        filter: ${{ inputs.filter }}
        clean: false
      env:
        GIT_LFS_SKIP_SMUDGE: 1
        GIT_TRACE: ${{ runner.debug }}
        GIT_CURL_VERBOSE: ${{ runner.debug }}

    - name: Clone submodules
      if: ${{ inputs.submodules == 'true' }}
      shell: bash
      run: time git submodule update --init --recursive --depth 1 --filter=blob:none
      env:
        GIT_TRACE: ${{ runner.debug }}
        GIT_CURL_VERBOSE: ${{ runner.debug }}

    - name: Pull LFS test fixtures
      if: ${{ inputs.lfs == 'tests' }}
      shell: bash
      run: |
        time git lfs pull --include='execution/tests/test-corners/**'
        cd execution/tests/execution-spec-tests
        time git lfs pull --include='blockchain_tests/frontier/scenarios/*.json,blockchain_tests/osaka/eip7934_block_rlp_limit/*.json,blockchain_tests/static/state_tests/stPreCompiledContracts/*.json,blockchain_tests/static/state_tests/stStackTests/*.json,state_tests/static/state_tests/stStackTests/*.json'
      env:
        GIT_TRACE: ${{ runner.debug }}
        GIT_CURL_VERBOSE: ${{ runner.debug }}

    - name: Install git-restore-mtime
      shell: bash
      run: |
        curl -sL https://raw.githubusercontent.com/MestreLion/git-tools/main/git-restore-mtime -o "$RUNNER_TEMP/git-restore-mtime"
        chmod +x "$RUNNER_TEMP/git-restore-mtime"
        echo "$RUNNER_TEMP" >> "$GITHUB_PATH"

    - name: Restore file mtimes for Go test caching
      shell: bash
      run: |
        # Go's test cache keys include stat metadata (mtime+size) for every file
        # and directory accessed during test execution.
        #
        # Main repo (full history via fetch-depth: 0): git-restore-mtime sets
        # each file's mtime to the commit that last touched it. This is
        # deterministic and content-sensitive â€” changed fixtures get a new mtime.
        #
        # Submodules (depth 1): git-restore-mtime can't help because files not
        # in the single commit's log are left untouched. Instead, set all files
        # to the submodule HEAD commit timestamp. This changes whenever the
        # submodule is updated.
        #
        # Directories: git-restore-mtime only handles dirs for file adds/deletes,
        # not modifications. Normalize all directory mtimes to a fixed epoch.
        time git restore-mtime --no-directories
        git submodule foreach --quiet --recursive \
          'ts=$(git log -1 --format=%cd --date=format:%Y%m%d%H%M.%S HEAD); find . -not -path "./.git/*" -not -type d -print0 | TZ=UTC xargs -0 touch -t $ts'
        find . -type d -not -path '*/.git/*' -print0 | TZ=UTC xargs -0 touch -t 200902132331.30

    - name: Debug file mtimes
      if: ${{ runner.debug }}
      shell: bash
      run: |
        if [ "$RUNNER_OS" = "macOS" ]; then
          find . -name .git -prune -o -print0 | xargs -0 stat -f '%m %HT %N' | sort -k3
        else
          find . -name .git -prune -o -printf '%T@ %y %p\n' | sort -k3
        fi

    - name: Get Go minor version from go.mod
      id: goversion
      shell: bash
      run: |
        minor=$(sed -n 's/^go \([0-9]*\.[0-9]*\).*/\1/p' go.mod)
        echo "version=${minor}.x" >> "$GITHUB_OUTPUT"

    - uses: actions/setup-go@v6
      with:
        go-version: ${{ steps.goversion.outputs.version }}
        # We have our own caching because we smrt.
        cache: false

    # TODO: Make this optional, it's possibly not needed for lints and a few other quick things.
    - name: Install dependencies on Linux
      if: ${{ runner.os == 'Linux' }}
      shell: bash
      # Can't suppress "Reading database... from apt-get install. Also it's very slow...
      run: sudo apt-get update -qq && sudo apt-get install -qq -y build-essential 2>/dev/null

    - name: Install make on Windows
      if: ${{ runner.os == 'Windows' }}
      shell: bash
      run: choco install make -y --no-progress

    - name: Get Go environment paths
      id: go-env
      shell: bash
      run: |
        echo "goversion=$(go env GOVERSION)" >> "$GITHUB_OUTPUT"
        echo "build=$(go env GOCACHE)" >> "$GITHUB_OUTPUT"
        echo "modcache=$(go env GOMODCACHE)" >> "$GITHUB_OUTPUT"
        echo "ERIGON_CI_GOCACHE=$(go env GOCACHE)" >> "$GITHUB_ENV"
        echo "ERIGON_CI_GOVERSION=$(go env GOVERSION)" >> "$GITHUB_ENV"
        echo "ERIGON_CI_MODCACHE=$(go env GOMODCACHE)" >> "$GITHUB_ENV"
        echo "ERIGON_CI_WORKFLOW=$(basename "${GITHUB_WORKFLOW_REF%%@*}" .yml)" >> "$GITHUB_ENV"

    # Note we only cache $(go env GOMODCACHE)/cache/download, the rest is derived from that part. We don't use this for lint, because it fetches extra metadata.

    - name: Restore Go module cache
      id: restore-modcache
      if: ${{ inputs.modcache == 'true' }}
      uses: actions/cache/restore@v4
      with:
        path: ${{ steps.go-env.outputs.modcache }}/cache/download
        key: gomodcache-${{ runner.os }}-${{ hashFiles('go.sum') }}-invalid
        restore-keys: gomodcache-${{ runner.os }}-${{ hashFiles('go.sum') }}-

    - name: Download Go modules
      if: ${{ inputs.modcache == 'true' }}
      shell: bash
      # -x because it doesn't log what it's doing otherwise, unlike if a download occurs during another tool call.
      run: time go mod download

    - uses: ./.github/actions/save-mod-cache
      if: ${{ always() && steps.restore-modcache.outcome == 'success' }}
      with:
        modcache: ${{ steps.go-env.outputs.modcache }}
