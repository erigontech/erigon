name: Setup Erigon environment
description: >
  Install Go, restore/save module cache. Callers may need a shallow checkout
  first (actions/checkout with fetch-depth: 1) so this composite action is
  available. setup-erigon then performs the full checkout per its inputs.

inputs:
  fetch-depth:
    description: "Number of commits to fetch (0 for all history)"
    required: false
    default: '0'
  filter:
    description: "Partial clone filter (e.g. blob:none)"
    required: false
    default: 'blob:none'
  submodules:
    description: "Clone submodules (recursive shallow clone)"
    required: false
    default: 'false'
  lfs:
    description: "'false' to skip, 'tests' for test fixtures only"
    required: false
    default: 'false'
  cleanup-space:
    description: "Remove large pre-installed packages to free disk space (Linux only)"
    required: false
    default: 'false'
  modcache:
    description: "'download' to restore/download/save module cache, 'false' to skip, other values restore only (save deferred to cleanup-erigon)"
    required: false
    default: 'download'
  build-cache-extra-key:
    description: "Extra segment appended to build cache key (e.g. matrix.test-group)"
    required: false
    default: ''

outputs:
  goversion:
    description: "Full Go version string (e.g. go1.25.7)"
    value: ${{ steps.go-env.outputs.goversion }}
  build:
    description: "GOCACHE path"
    value: ${{ steps.go-env.outputs.build }}
  modcache:
    description: "GOMODCACHE path"
    value: ${{ steps.go-env.outputs.modcache }}

runs:
  using: composite
  steps:
    - name: Set compact time format
      shell: bash
      run: echo "TIMEFORMAT=real %Rs user %Us sys %Ss" >> "$GITHUB_ENV"

    - name: Display free disk space
      shell: bash
      run: time df -h

    # Frees 20-30GB but takes ~30s. Only enable for workflows that hit the
    # disk ceiling. If space is tight, first check whether caches have blown
    # out in size before turning this on.
    - name: Cleanup space
      if: ${{ inputs.cleanup-space == 'true' && runner.os != 'Windows' }}
      shell: bash
      run: |
        time rm -fr /opt/az \
               /opt/microsoft \
               /usr/share/dotnet \
               /usr/share/miniconda \
               /usr/share/swift
        df -h

    - name: "Use D: drive for temp files on Windows"
      if: ${{ runner.os == 'Windows' }}
      shell: bash
      run: |
        mkdir -p D:/tmp
        echo "TEMP=D:/tmp" >> "$GITHUB_ENV"
        echo "TMP=D:/tmp" >> "$GITHUB_ENV"
        echo "TMPDIR=D:/tmp" >> "$GITHUB_ENV"

    - name: Enable git debug tracing
      if: ${{ runner.debug }}
      shell: bash
      run: |
        echo "GIT_TRACE=1" >> "$GITHUB_ENV"
        echo "GIT_CURL_VERBOSE=1" >> "$GITHUB_ENV"

    - name: Checkout code
      uses: actions/checkout@v6
      with:
        fetch-depth: ${{ inputs.fetch-depth }}
        filter: ${{ inputs.filter }}
        clean: false
        submodules: false
        lfs: false
      env:
        GIT_LFS_SKIP_SMUDGE: 1

    - name: Compute submodule objects cache key
      id: submodule-key
      if: ${{ inputs.submodules == 'true' }}
      shell: bash
      run: |
        hash=$(git ls-tree -r HEAD | awk '$2 == "commit" {print $3}' | sort | sha256sum | cut -d' ' -f1)
        echo "hash=$hash" >> "$GITHUB_OUTPUT"

    - name: Restore submodule git objects cache
      id: restore-submodules
      if: ${{ inputs.submodules == 'true' }}
      uses: actions/cache/restore@v4
      with:
        path: .git/modules
        key: gitobjects|${{ runner.os }}|lfs-${{ inputs.lfs }}|${{ steps.submodule-key.outputs.hash }}
        restore-keys: |
          gitobjects|${{ runner.os }}|lfs-${{ inputs.lfs }}|

    - name: Warn on submodule cache miss
      if: ${{ inputs.submodules == 'true' && steps.restore-submodules.outputs.cache-hit != 'true' }}
      shell: bash
      run: |
        echo "::warning::.git/modules cache miss (matched key: '${{ steps.restore-submodules.outputs.cache-matched-key }}')"

    - name: Clone submodules
      if: ${{ inputs.submodules == 'true' }}
      shell: bash
      run: time GIT_LFS_SKIP_SMUDGE=1 git submodule update --init --recursive --depth 1 --filter=blob:none --jobs 4

    - name: Pull LFS test fixtures
      if: ${{ inputs.lfs == 'tests' }}
      shell: bash
      run: |
        time git lfs pull --include='execution/tests/test-corners/**'
        cd execution/tests/execution-spec-tests
        time git lfs pull --include='blockchain_tests/frontier/scenarios/*.json,blockchain_tests/osaka/eip7934_block_rlp_limit/*.json,blockchain_tests/static/state_tests/stPreCompiledContracts/*.json,blockchain_tests/static/state_tests/stStackTests/*.json,state_tests/static/state_tests/stStackTests/*.json'

    - name: Install git-restore-mtime
      shell: bash
      run: |
        curl -sL https://raw.githubusercontent.com/MestreLion/git-tools/main/git-restore-mtime -o "$RUNNER_TEMP/git-restore-mtime"
        chmod +x "$RUNNER_TEMP/git-restore-mtime"
        echo "$RUNNER_TEMP" >> "$GITHUB_PATH"

    - name: Restore fixture mtimes for Go test caching
      shell: bash
      run: |
        # Go's test cache keys include stat metadata (mtime+size) for every
        # file and directory accessed during test execution. Source file
        # changes are captured by the test binary hash, so we only need
        # deterministic mtimes for fixture/data files that tests open at
        # runtime.
        #
        # Main repo: git-restore-mtime sets each fixture's mtime to the
        # commit that last touched it (deterministic and content-sensitive).
        #
        # Submodules (depth 1): git-restore-mtime can't help because files
        # not in the single commit's log keep checkout time. Instead, set
        # all files to the submodule HEAD commit timestamp.
        #
        # Directories: normalize to a fixed epoch since git-restore-mtime
        # only handles dirs for file adds/deletes, not modifications.

        # Fixture paths and extensions in the main repo:
        #   **/testdata/**          - Go-convention test data dirs
        #   execution/tests/test-corners/** - custom edge-case fixtures
        #   cl/spectest/**/data_*/** - consensus spec test data
        #   cl/transition/**/test_data/** - consensus transition test data
        #   Extensions: .json .js .txt .ssz .ssz_snappy .yaml
        time git restore-mtime --no-directories -- \
          '**/testdata/**' \
          'execution/tests/test-corners/**' \
          'cl/spectest/**/data_*/**' \
          'cl/transition/**/test_data/**'

        # Submodules are all fixture data; set mtimes to HEAD commit time.
        git submodule foreach --quiet --recursive \
          'ts=$(git log -1 --format=%cd --date=format:%Y%m%d%H%M.%S HEAD); find . -not -path "./.git/*" -not -type d -print0 | TZ=UTC xargs -0 touch -t $ts'

        # Normalize directory mtimes to a fixed epoch.
        find . -type d -not -path '*/.git/*' -print0 | TZ=UTC xargs -0 touch -t 200902132331.30

    - name: Debug file mtimes
      if: ${{ runner.debug }}
      shell: bash
      run: |
        if [ "$RUNNER_OS" = "macOS" ]; then
          find . -name .git -prune -o -print0 | xargs -0 stat -f '%m %HT %N' | sort -k3
        else
          find . -name .git -prune -o -printf '%T@ %y %p\n' | sort -k3
        fi

    - name: Get Go minor version from go.mod
      id: goversion
      shell: bash
      run: |
        minor=$(sed -n 's/^go \([0-9]*\.[0-9]*\).*/\1/p' go.mod)
        echo "version=${minor}.x" >> "$GITHUB_OUTPUT"

    - uses: actions/setup-go@v6
      with:
        go-version: ${{ steps.goversion.outputs.version }}
        # We have our own caching because we smrt.
        cache: false

    # TODO: Make this optional, it's possibly not needed for lints and a few other quick things.
    - name: Install dependencies on Linux
      if: ${{ runner.os == 'Linux' }}
      shell: bash
      # Can't suppress "Reading database... from apt-get install. Also it's very slow...
      run: sudo apt-get update -qq && sudo apt-get install -qq -y build-essential 2>/dev/null

    - name: Install make on Windows
      if: ${{ runner.os == 'Windows' }}
      shell: bash
      run: choco install make -y --no-progress

    - name: Debug parallelism
      shell: bash
      run: |
        nproc 2>/dev/null || sysctl -n hw.ncpu 2>/dev/null || echo "nproc unavailable"

    - name: Get Go environment paths
      id: go-env
      shell: bash
      run: |
        echo "goversion=$(go env GOVERSION)" >> "$GITHUB_OUTPUT"
        echo "build=$(go env GOCACHE)" >> "$GITHUB_OUTPUT"
        echo "modcache=$(go env GOMODCACHE)" >> "$GITHUB_OUTPUT"
        workflow=$(basename "${GITHUB_WORKFLOW_REF%%@*}" .yml)
        echo "workflow=$workflow" >> "$GITHUB_OUTPUT"
        echo "ERIGON_CI_GOCACHE_PATH=$(go env GOCACHE)" >> "$GITHUB_ENV"
        echo "ERIGON_CI_MODCACHE=$(go env GOMODCACHE)" >> "$GITHUB_ENV"
        echo "ERIGON_CI_MODCACHE_MODE=${{ inputs.modcache }}" >> "$GITHUB_ENV"

    # Note we only cache $(go env GOMODCACHE)/cache/download, the rest is derived from that part.

    - name: Restore Go module cache
      id: restore-modcache
      if: ${{ inputs.modcache != 'false' }}
      uses: actions/cache/restore@v4
      with:
        path: ${{ steps.go-env.outputs.modcache }}/cache/download
        key: gomodcache|${{ runner.os }}|${{ hashFiles('go.sum') }}|${{ inputs.modcache }}
        restore-keys: |
          gomodcache|${{ runner.os }}|${{ hashFiles('go.sum') }}|${{ inputs.modcache }}
          gomodcache|${{ runner.os }}|${{ hashFiles('go.sum') }}|
          gomodcache|${{ runner.os }}|

    - name: Export modcache restored key
      if: ${{ inputs.modcache != 'false' }}
      shell: bash
      run: echo "ERIGON_CI_MODCACHE_RESTORED_KEY=${{ steps.restore-modcache.outputs.cache-matched-key }}" >> "$GITHUB_ENV"

    - name: Download Go modules
      if: ${{ inputs.modcache == 'download' }}
      shell: bash
      # -x because it doesn't log what it's doing otherwise, unlike if a download occurs during another tool call.
      run: time go mod download

    - name: Save Go module cache
      if: ${{ inputs.modcache == 'download' && steps.restore-modcache.outputs.cache-hit != 'true' }}
      uses: actions/cache/save@v4
      with:
        path: ${{ steps.go-env.outputs.modcache }}/cache/download
        key: gomodcache|${{ runner.os }}|${{ hashFiles('go.sum') }}|${{ inputs.modcache }}

    - id: restore-build-cache
      uses: ./.github/actions/restore-build-cache
      with:
        gocache: ${{ steps.go-env.outputs.build }}
        goversion: ${{ steps.go-env.outputs.goversion }}
        workflow: ${{ steps.go-env.outputs.workflow }}
        extra-key: ${{ inputs.build-cache-extra-key }}

    - name: Export build cache key
      shell: bash
      run: echo "ERIGON_CI_GOCACHE_KEY=${{ steps.restore-build-cache.outputs.cache-key }}" >> "$GITHUB_ENV"

    - name: Export submodule cache keys
      if: ${{ inputs.submodules == 'true' }}
      shell: bash
      run: |
        echo "ERIGON_CI_SUBMODULE_CACHE_KEY=gitobjects|${{ runner.os }}|lfs-${{ inputs.lfs }}|${{ steps.submodule-key.outputs.hash }}" >> "$GITHUB_ENV"
        echo "ERIGON_CI_SUBMODULE_CACHE_RESTORED_KEY=${{ steps.restore-submodules.outputs.cache-matched-key }}" >> "$GITHUB_ENV"
