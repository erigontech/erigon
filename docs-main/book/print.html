<!DOCTYPE HTML>
<html lang="en" class="ayu sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Erigon 3 Docs</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="Erigon 3 documentation!">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "ayu" : "ayu";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Erigon 3 Docs</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/erigontech/erigon" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<img src="introduction//images/Erigon-2024-ICON-V1-O-scaled.webp" alt="Erigon 3" style="display: block; margin: 0 auto; max-width: 200px">
<p>Erigon is an efficient Ethereum implementation designed for speed, modularity, and optimization.</p>
<p>With Erigon 3 the default configuration shifts from archive node to full node, enhancing efficiency, accessibility, and versatility for a wider range of users. Archive nodes remain available for developers and researchers needing full historical data, while the full node offers faster sync times and lower resource usage for everyday operations.</p>
<p>See here <strong><a href="introduction/why-using-erigon.html">why you should be using Erigon</a></strong>.</p>
<h1 id="topics"><a class="header" href="#topics">Topics</a></h1>
<ul>
<li>Review the hardware and software requirements to <a href="introduction//getting-started/getting-started.html">get started</a>.</li>
<li>Follow the <a href="introduction//getting-started/installation.html">installation guide</a> to set up Erigon.</li>
<li>Learn the <a href="introduction//fundamentals/basic-usage.html">basic usage</a> of Erigon.</li>
<li>Find how to <a href="introduction//fundamentals/configuring-erigon.html">configure Erigon</a>.</li>
<li>Interact with Erigon's advanced <a href="introduction//interacting-with-erigon/interacting-with-erigon.html">RPC</a>.</li>
</ul>
<p>Explore also our help, wiki and dedicated developer guide.</p>
<h1 id="additional-resources-and-information"><a class="header" href="#additional-resources-and-information">Additional Resources and Information</a></h1>
<ul>
<li><strong>Releases</strong>: see <a href="https://github.com/erigontech/erigon/releases">https://github.com/erigontech/erigon/releases</a>.</li>
<li><strong>Docker image releases</strong>:
<ul>
<li>New Docker Image Repository: Erigon images are now available on Dockerhub repository <a href="https://hub.docker.com/r/erigontech/erigon">erigontech/erigon</a>.</li>
<li>Multi-Platform Support: The docker image is built for linux/amd64/v2 and linux/arm64 platforms using Alpine.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="why-using-erigon"><a class="header" href="#why-using-erigon">Why using Erigon?</a></h1>
<p>Erigon is an efficient Ethereum implementation designed for speed, modularity, and optimization. By default, it functions as a full node, utilizing technologies like staged sync, efficient state storage, and database compression.</p>
<p>With Erigon 3 the default configuration shifts from archive node to <strong>full node</strong>, enhancing efficiency, accessibility, and versatility for a wider range of users. Archive nodes remain available for developers and researchers needing full historical data, while the full node offers faster sync times and lower resource usage for everyday operations.</p>
<h2 id="key-architectural-benefits"><a class="header" href="#key-architectural-benefits">Key Architectural Benefits</a></h2>
<ul>
<li>
<p><strong>Staged Sync:</strong> Erigon uses a unique staged synchronization process that breaks down the blockchain sync into a series of distinct, optimized stages (e.g., downloading headers, executing blocks, building the state). This approach allows Erigon to be faster and more efficient than traditional sync methods because it procesfses data in a way that minimizes database writes and resource usage. This results in significantly faster initial sync times, often in a matter of hours or days, making it far more accessible for users with standard hardware.</p>
</li>
<li>
<p><strong>Modularity:</strong> Erigon's architecture is highly modular, separating components like the core node, RPC daemon, and transaction pool into independent processes. This design enables RPC providers to create scalable, high-performance clusters by running multiple RPC daemons connected to a single node. For developers, this modularity simplifies development, allowing for easier integration of new features and debugging without affecting the entire system.</p>
</li>
<li>
<p><strong>Efficient state Storage:</strong> Erigon's approach to state storage is a core reason for its efficiency. Instead of storing data using the complex Merkle Patricia Trie (MPT) structure like most clients, Erigon uses a flat key-value database. This design simplifies data organization, reducing the need for multiple lookups and random disk access. This architecture not only speeds up read/write operations but also enables powerful data compression, which dramatically shrinks the overall disk footprint of an Erigon node. By making a full archive node feasible on consumer-grade SSDs, Erigon significantly lowers the hardware barrier for solo stakers, developers, and professionals.</p>
</li>
<li>
<p><strong>OtterSync:</strong> OtterSync is a new sync algorithm designed to drastically reduce the time needed to sync a node. It achieves this by shifting most of the initial sync computation from the CPU to network bandwidth. This is done by downloading state data through a secondary protocol, like BitTorrent, instead of re-executing every historical transaction. This enables a fast sync, even for archive nodes.</p>
</li>
</ul>
<blockquote>
<p>Dive into Erigon's architecture by accessing our Wiki section.</p>
</blockquote>
<h2 id="advantages-of-using-erigon"><a class="header" href="#advantages-of-using-erigon">Advantages of using Erigon</a></h2>
<h3 id="professionals-rpc-providers-and-stakers"><a class="header" href="#professionals-rpc-providers-and-stakers">Professionals: RPC Providers and Stakers</a></h3>
<p>Professionals, particularly <strong>RPC providers</strong> can leverage Erigon's unique architecture for enhanced performance and scalability. The client's modular design allows for the RPC daemon to be run as a separate process from the core node, which enables RPC providers to build scalable clusters by connecting multiple RPC daemons to a single node. This separation of concerns allows for flexible resource allocation and can handle a high volume of requests with low latency.</p>
<p>For <strong>large-scale stakers</strong>, Erigon's optimized performance, including fast block processing and an integrated consensus layer client (Caplin), reduces the risk of missed attestations and slashing penalties, leading to higher profitability and improved reliability.</p>
<h4 id="performance-and-efficiency"><a class="header" href="#performance-and-efficiency">Performance and Efficiency</a></h4>
<ul>
<li>Faster sync and smaller disk footprint compared to other execution clients.</li>
<li>Cheaper infrastructure due to a significantly smaller database size.</li>
<li>The minimized disk footprint optimizes performance and reduces overall costs.</li>
<li>Superior RPC performance, leading to a much-improved user experience.</li>
<li>Faster RPC speeds, benefiting wallets and analytics tools.</li>
<li>Quicker transaction broadcasting improves the end-user experience, preventing missed opportunities and reducing errors.</li>
</ul>
<h3 id="home-users-and-solo-stakers"><a class="header" href="#home-users-and-solo-stakers">Home Users and Solo Stakers</a></h3>
<p>For home users and solo stakers, Erigon offers a compelling solution that prioritizes <strong>efficiency and accessibility</strong>. Its primary benefit lies in its reduced disk space requirements. By employing an innovative "flat" database schema and advanced data compression techniques, Erigon can store a full archive node in significantly less space than other clients. This makes it feasible for individuals to run a full node on consumer-grade hardware, lowering the barrier to entry for solo staking. Furthermore, Erigon's fast synchronization capabilities mean that a new node can be brought up to speed much quicker, reducing the initial setup time and allowing stakers to start earning rewards with minimal delay.</p>
<p>By running their own Erigon node, home users and solo stakers contribute directly to the <strong>decentralization</strong> and overall health of the Ethereum network. This practice reduces their dependence on third-party servers and the need to trust information about the state of the network provided by external parties. This self-reliance is a key aspect of the decentralization revolution, as it shifts power away from centralized entities and back to the individual user. By participating in this process, users not only improve their own <strong>security and privacy</strong> but also play a vital role in ensuring the long-term resilience and censorship resistance of the entire network.</p>
<h3 id="developers"><a class="header" href="#developers">Developers</a></h3>
<p>Erigon provides a robust and flexible environment for developers building on Ethereum and L2s. Its modular architecture simplifies development, allowing teams to focus on specific components without being burdened by the entire system. Developers can easily integrate new features or fix bugs within a specific module, enhancing development efficiency. Erigon’s full archive node capabilities by default, coupled with its fast sync, make it an ideal choice for building dApps, analytics platforms, or other applications that require access to comprehensive historical data. The client also offers a gRPC API for lower-level data access and a range of debug and tracing functionalities, empowering developers to create, test, and optimize their applications with greater ease.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributing-to-documentation"><a class="header" href="#contributing-to-documentation">Contributing to Documentation</a></h1>
<p>This documentation is powered by <a href="https://rust-lang.github.io/mdBook">MdBook</a>.</p>
<p>To contribute to the Erigon 3 Docs, you can either:</p>
<ol>
<li>Create an Issue: Open a new issue in the main branch to suggest changes or report problems.</li>
<li>Open a Branch and Submit a PR: Create a new branch, make your changes, and submit a pull request (PR) on Github.</li>
</ol>
<p>Before committing your changes, it's recommended to run the documentation locally to verify the output. This ensures that your changes render correctly and maintain the consistency of the documentation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>In order to use Erigon, the software has to be installed first. There are several ways to install Erigon, depending on the operating system and the user's choice of installation method, e.g. using a package manager, docker container or building from source.</p>
<p>Verify carefully that your <a href="getting-started/hardware-requirements.html">hardware</a> satisfy the requirements and your machine is running the required <a href="getting-started/software-requirements.html">software</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hardware-requirements"><a class="header" href="#hardware-requirements">Hardware Requirements</a></h1>
<h2 id="disk-type"><a class="header" href="#disk-type">Disk type</a></h2>
<p>A locally mounted <strong>SSD</strong> (Solid-State Drive) or <strong>NVMe</strong> (Non-Volatile Memory Express) disk is recommended for storage. <strong>Avoid Hard Disk Drives (HDD)</strong>, as they can cause Erigon to lag behind the blockchain tip, albeit not fall behind.</p>
<p>Additionally, SSDs may experience performance degradation when nearing full capacity.</p>
<p>See here how you can <a href="getting-started/../fundamentals/optimizing-storage.html">optimize storage</a>.</p>
<p>Here is the outline of the hardware requirements for running Erigon on the following networks:</p>
<ul>
<li>Ethereum Mainnet</li>
<li>Polygon (formerly Matic)</li>
<li>Gnosis (formerly xDai)</li>
</ul>
<p>Hardware requirements vary depending on whether you're running a Minimal, Full, or Archive node.</p>
<p>General recommendations for all node types include:</p>
<ul>
<li><strong>Disk Type:</strong> Use high-end NVMe SSDs. RAID or ZFS setups may improve performance for archive nodes.</li>
<li><strong>RAM:</strong> Adequate memory reduces bottlenecks during sync and improves performance under load.</li>
<li><strong>CPU:</strong> 4–8 cores recommended for Full nodes; 8–16 cores for Archive.</li>
<li><strong>Linux</strong>: kernel version &gt; v4</li>
<li>When using multiple disks, consider implementing a <strong>RAID 0</strong> configuration to maximize performance and utilize space efficiently. RAID ZFS is not recommended.</li>
</ul>
<h2 id="disk-size-and-ram-requirements"><a class="header" href="#disk-size-and-ram-requirements">Disk Size and RAM Requirements</a></h2>
<p>The amount of disk space recommended and RAM you need depends on the <a href="getting-started/../basic/node.html">type of node</a> you want to run. The "Disk Size (Required)" values listed below are obtained using the standard Erigon configuration, with the sole exception of the <code>--prune.mode</code> flag.</p>
<h3 id="minimal-node-requirements"><a class="header" href="#minimal-node-requirements">Minimal Node Requirements</a></h3>
<p>Minimal nodes are suitable for light operation with pruned state and minimal historical data retention. (<code>--prune.mode=minimal</code>)</p>
<div class="table-wrapper"><table><thead><tr><th>Network</th><th>Disk Size (Required)</th><th>Disk Size (Recommended)</th><th>RAM (Required)</th><th>RAM (Recommended)</th></tr></thead><tbody>
<tr><td>Mainnet</td><td>350 GB</td><td>1 TB</td><td>16 GB</td><td>64 GB</td></tr>
<tr><td>Polygon</td><td>1.2 TB</td><td>2 TB</td><td>32 GB</td><td>64 GB</td></tr>
<tr><td>Gnosis</td><td>128 GB</td><td>500 GB</td><td>8 GB</td><td>16 GB</td></tr>
</tbody></table>
</div>
<h3 id="full-node-requirements"><a class="header" href="#full-node-requirements">Full Node Requirements</a></h3>
<p>Full nodes maintain full state with standard pruning and all recent data.  (<code>--prune.mode=full</code>)</p>
<div class="table-wrapper"><table><thead><tr><th>Network</th><th>Disk Size (Required)</th><th>Disk Size (Recommended)</th><th>RAM (Required)</th><th>RAM (Recommended)</th></tr></thead><tbody>
<tr><td>Mainnet</td><td>920 GB</td><td>2 TB</td><td>16 GB</td><td>32 GB</td></tr>
<tr><td>Polygon</td><td>3.3 TB</td><td>4 TB</td><td>16 GB</td><td>32 GB</td></tr>
<tr><td>Gnosis</td><td>462 GB</td><td>1 TB</td><td>8 GB</td><td>16 GB</td></tr>
</tbody></table>
</div>
<h3 id="archive-node-requirements"><a class="header" href="#archive-node-requirements">Archive Node Requirements</a></h3>
<p>Archive nodes retain <strong>all</strong> historical state and require significantly more disk space. These are typically used for block explorers or deep analytical queries. (<code>--prune.mode=archive</code>)</p>
<div class="table-wrapper"><table><thead><tr><th>Network</th><th>Disk Size (Required)</th><th>Disk Size (Recommended)</th><th>RAM (Required)</th><th>RAM (Recommended)</th></tr></thead><tbody>
<tr><td>Mainnet</td><td>1.77 TB</td><td>4 TB</td><td>32 GB</td><td>64 GB</td></tr>
<tr><td>Polygon</td><td>4.85 TB</td><td>8 TB</td><td>64 GB</td><td>128 GB</td></tr>
<tr><td>Gnosis</td><td>539 GB</td><td>1 TB</td><td>16 GB</td><td>32 GB</td></tr>
</tbody></table>
</div>
<h2 id="bandwidth-requirements"><a class="header" href="#bandwidth-requirements">Bandwidth Requirements</a></h2>
<p>Your internet bandwidth is also an important factor, particularly for sync speed and validator performance.</p>
<div class="table-wrapper"><table><thead><tr><th>Node Type</th><th>Bandwidth (Required)</th><th>Bandwidth (Recommended)</th></tr></thead><tbody>
<tr><td>Staking/Mining</td><td>10 Mbps</td><td>50 Mbps</td></tr>
<tr><td>Non-Staking</td><td>5 Mbps</td><td>25 Mbps</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="software-requirements"><a class="header" href="#software-requirements">Software Requirements</a></h1>
<p>If you plan to compile Erigon from source, ensure that the following prerequisites are met.</p>
<p>Erigon works only from command line interface (CLI), so it is advisable to have a good confidence with basic commands.</p>
<blockquote>
<p>Building software from source can be complex. If you're not comfortable with technical tasks, we recommend you use other installation methods like pre-built images or Docker and skip these requirements.</p>
</blockquote>
<h3 id="git"><a class="header" href="#git">Git</a></h3>
<p>Git is a tool that helps download and manage the Erigon source code. To install Git, visit <a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a>.</p>
<h3 id="build-essential-only-for-linux"><a class="header" href="#build-essential-only-for-linux">Build essential (only for Linux)</a></h3>
<p>Install <strong>Build-essential</strong> and <strong>Cmake</strong>:</p>
<pre><code class="language-bash">sudo apt install build-essential cmake -y
</code></pre>
<h3 id="go-programming-language"><a class="header" href="#go-programming-language">Go Programming Language</a></h3>
<p>Erigon utilizes Go (also known as Golang) version 1.24 or newer for part of its development. It is recommended to have a fresh Go installation. If you have an older version, consider deleting the /usr/local/go folder (you may need to use sudo) and re-extract the new version in its place.</p>
<p>To install the latest Go version, visit the official documentation at <a href="https://golang.org/doc/install">https://golang.org/doc/install</a>.</p>
<h3 id="c-compiler"><a class="header" href="#c-compiler">C++ Compiler</a></h3>
<p>This turns the C++ part of Erigon's code into a program your computer can run. You can use either <strong>Clang</strong> or <strong>GCC</strong>:</p>
<ul>
<li>For <strong>Clang</strong> follow the instructions at <a href="https://clang.llvm.org/get_started.html">https://clang.llvm.org/get_started.html</a>;</li>
<li>For <strong>GCC</strong> (version 10 or newer): <a href="https://gcc.gnu.org/install/index.html">https://gcc.gnu.org/install/index.html</a>.</li>
</ul>
<p>You can now proceed with Erigon <a href="getting-started/installation.html">installation</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<p>In order to use Erigon, the software has to be installed first. There are several ways to install Erigon, depending on the operating system and the user's choice of installation method, e.g. using a pre-built image, container or building from source.</p>
<blockquote>
<p>Always check the <a href="https://github.com/erigontech/erigon/releases">list of releases</a> for release notes.</p>
</blockquote>
<hr />
<p><a href="getting-started/installation/linux-and-macos.html">Linux and MacOS</a></p>
<p><a href="getting-started/installation/windows.html">Windows</a></p>
<p><a href="getting-started/installation/docker.html">Docker</a></p>
<p><a href="getting-started/installation/upgrading.html">Upgrading from a previous version</a></p>
<hr />
<p>See here if you are <a href="getting-started/installation/migrating-from-geth.html">migrating from GETH</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linux-and-mac-os"><a class="header" href="#linux-and-mac-os">Linux and Mac OS</a></h1>
<p><em>How to install Erigon 3 on Linux and Mac OS</em></p>
<p>There are 3 options for running Erigon 3, listed from easiest to most difficult installation:</p>
<ul>
<li>
<p><a href="getting-started/installation/pre-built-binaries.html">Use pre-built binaries</a>: Download and run the latest stable release of Erigon. This is the easiest option and requires no additional dependencies.</p>
</li>
<li>
<p><a href="getting-started/installation/docker.html">Use Docker</a>: Run Erigon in a Docker container for isolation from the host system. This avoids dependencies but requires installing Docker.</p>
</li>
<li>
<p><a href="getting-started/installation/build-Erigon-from-source.html">Build Erigon from source</a>: Build the Erigon source code directly on your system. This is the most complex option and requires a working Go environment.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="install-erigon-with-pre-built-binaries"><a class="header" href="#install-erigon-with-pre-built-binaries">Install Erigon with Pre-built Binaries</a></h1>
<p>You can download and install the latest version of Erigon (e.g., v3.1.0) directly from our GitHub releases page.</p>
<h2 id="1-select-your-platform-and-download"><a class="header" href="#1-select-your-platform-and-download">1. Select Your Platform and Download</a></h2>
<p>Go to the <a href="https://github.com/erigontech/erigon/releases">Erigon releases page</a> and select the latest version (or whichever version you prefer).</p>
<img src="getting-started/installation//images/releases.png" alt="Erigon Releases" style="display: block; margin: 0 auto;">
<p>Then, download the appropriate binary for your system:</p>
<ul>
<li>For <strong>Linux</strong>:
<ul>
<li><code>erigon_3.x.x_amd64.deb</code> for 64-bit Intel/AMD processors</li>
<li><code>erigon_3.x.x_arm64.deb</code> for 64-bit ARM processors</li>
<li><code>erigon_v3.x.x_linux_amd64.tar.gz</code> for 64-bit Intel/AMD processors</li>
<li><code>erigon_v3.x.x_linux_arm64.tar.gz</code> for 64-bit ARM processors</li>
</ul>
</li>
<li>For <strong>MacOS</strong>:
<ul>
<li><code>erigon_3.x.x_darwin_amd64.tar.gz</code> for 64-bit Intel/AMD processors</li>
<li><code>erigon_3.x.x_darwin_arm64.tar.gz</code> for 64-bit ARM processors</li>
</ul>
</li>
</ul>
<h3 id="checksums"><a class="header" href="#checksums">Checksums</a></h3>
<p>To verify the integrity of the downloaded file, you can use the checksums provided in the <code>erigon_v3.x.x_checksums.txt</code> file. This file contains SHA256 checksums for all Erigon binaries.</p>
<pre><code class="language-bash">BASE="https://github.com/erigontech/erigon/releases/download/v3.x.x"
wget $BASE/erigon_v3.x.x_checksums.txt
# then one of:
wget $BASE/erigon_3.x.x_amd64.deb
# or
wget $BASE/erigon_3.x.x_arm64.deb
# or
wget $BASE/erigon_v3.x.x_linux_amd64.tar.gz
# or
wget $BASE/erigon_v3.x.x_linux_arm64.tar.gz
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build-erigon-from-source"><a class="header" href="#build-erigon-from-source">Build Erigon from source</a></h1>
<p><em>How to build Erigon in Linux and MacOS from source</em></p>
<p>The basic Erigon configuration is suitable for most users who simply want to run a node. To build the latest stable release, use the following command:</p>
<pre><code class="language-bash">git clone --branch release/3.1 --single-branch https://github.com/erigontech/erigon.git
cd erigon
</code></pre>
<p>Next, compile the software using:</p>
<pre><code class="language-bash">make erigon
</code></pre>
<p>To speed up the compilation process, you can specify the number of processors to use with the <code>-j&lt;n&gt;</code> option, where <code>&lt;n&gt;</code> is the number of processors you want to utilize. For example, if your machine has 22 processors and you want to use 20 of them, you can run:</p>
<pre><code class="language-bash">make -j20 erigon
</code></pre>
<p>This will create the binary at <code>./build/bin/erigon</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="windows"><a class="header" href="#windows">Windows</a></h1>
<p><em>How to install and run Erigon 3 on Windows 10 and Windows 11</em></p>
<p>There are 3 options for running Erigon 3 on Windows, listed from easiest to most difficult installation:</p>
<ul>
<li>
<p><a href="getting-started/installation/docker.html">Use Docker</a>: Run Erigon in a Docker container for isolation from the host Windows system. This avoids dependencies on Windows but requires installing Docker.</p>
</li>
<li>
<p><a href="getting-started/installation/windows-build-executables.html">Build executable binaries natively for Windows</a>: Use the pre-built Windows executables that can be natively run on Windows without any emulation or containers required.</p>
</li>
<li>
<p><a href="getting-started/installation/windows-wsl.html">Use Windows Subsystem for Linux (WSL)</a>: Install the Windows Subsystem for Linux (WSL) to create a Linux environment within Windows. Erigon can then be installed in WSL by following the Linux installation instructions. This provides compatibility with Linux builds but involves more setup overhead.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build-executable-binaries-natively-for-windows"><a class="header" href="#build-executable-binaries-natively-for-windows">Build executable binaries natively for Windows</a></h1>
<p>Before proceeding, ensure that the <a href="getting-started/installation/../getting-started/hw-requirements.html">hardware</a> and <a href="getting-started/installation/../getting-started/sw-requirements.html">software</a> requirements are met.</p>
<h2 id="installing-chocolatey"><a class="header" href="#installing-chocolatey">Installing Chocolatey</a></h2>
<p>Install <em>Chocolatey package manager</em> by following these <a href="https://docs.chocolatey.org/en-us/choco/setup">instructions</a>.</p>
<p>Once your Windows machine has the above installed, open the <strong>Command Prompt</strong> by typing "<strong>cmd</strong>" in the search bar and check that you have correctly installed Chocolatey:</p>
<pre><code class="language-bash">choco -v
</code></pre>
<img src="getting-started/installation//images/choco-v.png" alt="" style="display: block; margin: 0 auto;">
<p>Now you need to install the following components: <code>cmake</code>, <code>make</code>, <code>mingw</code> by:</p>
<pre><code class="language-bash">choco install cmake make mingw
</code></pre>
<div class="warning">
<p><strong>Important note about Anti-Virus:</strong></p>
<p>During the compiler detection phase of <strong>MinGW</strong>, some temporary executable files are generated to test the compiler capabilities. It's been reported that some anti-virus programs detect these files as possibly infected with the <code>Win64/Kryptic.CIS</code> Trojan horse (or a variant of it). Although these are false positives, we have no control over the 100+ vendors of security products for Windows and their respective detection algorithms and we understand that this may make your experience with Windows builds uncomfortable. To work around this, you can either set exclusions for your antivirus software specifically for the<code>build\bin\mdbx\CMakeFiles</code> subfolder of the cloned repo, or you can run Erigon using the other two options below.</p>
</div>
<p>Make sure that the Windows System Path variable is set correctly. Use the search bar on your computer to search for “<strong>Edit the system environment variable</strong>”.</p>
<img src="getting-started/installation//images/Edit_sys_env.png" alt="" style="display: block; margin: 0 auto;">
<p>Click the “<strong>Environment Variables...</strong>” button.</p>
<img src="getting-started/installation//images/Edit_sys_env2.png" alt="" style="display: block; margin: 0 auto;">
<p>Look down at the "<strong>System variables</strong>" box and double click on "<strong>Path</strong>" to add a new path.</p>
<img src="getting-started/installation//images/System_var.png" alt="" style="display: block; margin: 0 auto;">
<p>Then click on the "<strong>New</strong>" button and paste the following path:</p>
<pre><code class="language-bash"> C:\ProgramData\chocolatey\lib\mingw\tools\install\mingw64\bin
</code></pre>
<img src="getting-started/installation//images/new_sys_var.png" alt="" style="display: block; margin: 0 auto;">
<h2 id="clone-the-erigon-repository"><a class="header" href="#clone-the-erigon-repository">Clone the Erigon repository</a></h2>
<p>Open the Command Prompt and type the following:</p>
<pre><code class="language-bash">git clone --branch release/3.1 --single-branch https://github.com/erigontech/erigon.git
</code></pre>
<p>You might need to change the <code>ExecutionPolicy</code> to allow scripts created locally or signed by a trusted publisher to run. Open a Powershell session as Administrator and type:</p>
<pre><code class="language-powershell">Set-ExecutionPolicy RemoteSigned
</code></pre>
<h2 id="compiling-erigon"><a class="header" href="#compiling-erigon">Compiling Erigon</a></h2>
<p>To compile Erigon there are two alternative methods:</p>
<ol>
<li><a href="getting-started/installation/windows-build-executables.html#1-compiling-from-the-wmakeps1-file-in-the-file-explorer">Compiling from the wmake.ps1 file in the File Explorer</a></li>
<li><a href="getting-started/installation/windows-build-executables.html#2-using-the-powershell-cli">Using the PowerShell CLI</a></li>
</ol>
<h3 id="1-compiling-from-the-wmakeps1-file-in-the-file-explorer"><a class="header" href="#1-compiling-from-the-wmakeps1-file-in-the-file-explorer">1. Compiling from the wmake.ps1 file in the File Explorer</a></h3>
<p>This is the fastest way which normally works for everyone. Open the File Explorer and go to the Erigon folder, then right click the <code>wmake</code> file and choose "<strong>Run with PowerShell</strong>".</p>
<img src="getting-started/installation//images/powershell.png" alt="" style="display: block; margin: 0 auto;">
<p>PowerShell will compile Erigon and all of its modules. All binaries will be placed in the <code>.\build\bin\</code> subfolder.</p>
<img src="getting-started/installation//images/powershell2.png" alt="" style="display: block; margin: 0 auto;">
<h3 id="2-using-the-powershell-cli"><a class="header" href="#2-using-the-powershell-cli">2. Using the PowerShell CLI</a></h3>
<p>In the search bar on your computer, search for “<strong>Windows PowerShell</strong>” and open it.</p>
<img src="getting-started/installation//images/powershell3.png" alt="" style="display: block; margin: 0 auto;">
<p>Change the working directory to "<strong>erigon</strong>"</p>
<pre><code class="language-bash">cd erigon
</code></pre>
<img src="getting-started/installation//images/powershell4.png" alt="" style="display: block; margin: 0 auto;">
<p>Before modifying security settings, ensure PowerShell script execution is allowed in your Windows account settings using the following command:</p>
<pre><code class="language-powershell">Set-ExecutionPolicy Bypass -Scope CurrentUser -Force
</code></pre>
<p>This change allows script execution, but use caution to avoid security risks. Remember to only make these adjustments if you trust the scripts you intend to run. Unauthorized changes can impact system security. For more info read <a href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.security/set-executionpolicy?view=powershell-7.3">Set-Execution Policy</a> documentation.</p>
<p>Now you can compile Erigon and/or any of its component:</p>
<pre><code class="language-powershell">.\wmake.ps1 [-target] &lt;targetname&gt;
</code></pre>
<p>For example, to build the Erigon executable write:</p>
<pre><code class="language-powershell">.\wmake.ps1 erigon
</code></pre>
<img src="getting-started/installation//images/powershell5.png" alt="" style="display: block; margin: 0 auto;">
<p>The executable binary <code>erigon.exe</code> should have been created in the <code>.\build\bin\</code> subfolder.</p>
<p>You can use the same command to build other binaries such as <code>RPCDaemon</code>, <code>TxPool</code>, <code>Sentry</code> and <code>Downloader</code>.</p>
<h2 id="running-erigon"><a class="header" href="#running-erigon">Running Erigon</a></h2>
<p>To start Erigon place your command prompt in the <code>.\build\bin\</code> subfolder and use:</p>
<pre><code class="language-powershell">start erigon.exe.
</code></pre>
<p>or from any place use the full address of the executable:</p>
<pre><code class="language-powershell">start C:\Users\username\AppData\Local\erigon.exe
</code></pre>
<p>See <a href="getting-started/installation/../basic-usage.html">basic usage</a> documentation on available options and flags to customize your Erigon experience.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="windows-subsystem-for-linux-wsl"><a class="header" href="#windows-subsystem-for-linux-wsl">Windows Subsystem for Linux (WSL)</a></h1>
<p>WSL enables running a complete GNU/Linux environment natively within Windows 10, providing Linux compatibility without the performance overhead of traditional virtualization.</p>
<p>To install WSL, follow Microsoft official instructions: <a href="https://learn.microsoft.com/en-us/windows/wsl/install">https://learn.microsoft.com/en-us/windows/wsl/install</a>.</p>
<blockquote>
<p><strong>Important</strong>: WSL Version 2 is the only version supported.</p>
</blockquote>
<p>Under this option you can build Erigon as you would on a regular Linux distribution (see detailed instructions <a href="getting-started/installation/linux.html">here</a>).</p>
<p>You can also point your data to any of the mounted Windows partitions ( e.g. <code>/mnt/c/[...]</code>, <code>/mnt/d/[...]</code> etc..) but be aware that performance will be affected: this is due to the fact that these mount points use <code>DrvFS</code>, which is a network file system, and additionally MDBX locks the db for exclusive access, meaning that only one process at a time can access the data.</p>
<blockquote>
<p>⚠️ <strong>Warning</strong>: The remote db RPCdaemon is an experimental feature and is not recommended, it is extremely slow. It is highly preferable to use the embedded RPCdaemon.</p>
</blockquote>
<p>This has implications for running <code>rpcdaemon</code>, which must be configured as a remote DB, even if it is running on the same machine. If your data is hosted on the native Linux filesystem instead, there are no restrictions. Also note that the default WSL2 environment has its own IP address, which does not match the network interface of the Windows host: take this into account when configuring NAT on port 30303 on your router.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="docker"><a class="header" href="#docker">Docker</a></h1>
<p><em>How to run a Erigon node with Docker</em></p>
<p>Using Docker allows starting Erigon packaged as a Docker image without installing the program directly on your system.</p>
<h3 id="general-info"><a class="header" href="#general-info">General Info</a></h3>
<ul>
<li>The new Docker images feature seven binaries as are included in the released archive: <code>erigon</code>, <code>integration</code>, <code>diag</code>, <code>sentry</code>, <code>txpool</code>, <code>downloader</code>, <code>rpcdaemon</code>.</li>
<li>Multi-platform docker image available for linux/amd64/v2 and linux/arm64 platforms and based on alpine:3.20.2; no need to pull another docker image for another different platform.</li>
<li>All build flags are now passed to the release workflow, allowing users to view previously missed build information in our released binaries and Docker images. Additionally, this change is expected to result in better build optimization.</li>
<li>Docker images now contain the label “org.opencontainers.image.revision,” which refers to the commit ID from the Erigon project used to build the artifacts.</li>
<li>With recent updates, all build configurations are now included in the release process. This provides users with more comprehensive build information for both binaries and Docker images, along with enhanced build optimizations.</li>
<li>Images are stored at <a href="https://hub.docker.com/r/erigontech/erigon">https://hub.docker.com/r/erigontech/erigon</a>.</li>
</ul>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<p>Having Docker Engine installed, see instructions <a href="https://docs.docker.com/engine/install/">here</a>.</p>
<h2 id="download-and-start-erigon-in-docker"><a class="header" href="#download-and-start-erigon-in-docker">Download and start Erigon in Docker</a></h2>
<p>Here are the steps to download and start Erigon in Docker:</p>
<ol>
<li>Download the latest version:</li>
</ol>
<pre><code class="language-bash">docker pull erigontech/erigon:
</code></pre>
<ol start="2">
<li>List the downloaded images to get the IMAGE ID:</li>
</ol>
<pre><code class="language-bash">docker images
</code></pre>
<ol start="3">
<li>Check which Erigon version has been downloaded:</li>
</ol>
<pre><code class="language-bash">docker run -it &lt;image_id&gt; --v
</code></pre>
<p>If you want to start Erigon add the options according to the <a href="getting-started/installation/../basic-usage.html">basic usage</a> page or the advanced customization page. For example:</p>
<pre><code class="language-bash">docker run -it 36f25992dd1a --chain=holesky --prune.mode=minimal
</code></pre>
<p>To exit the container press <code>Ctrl+C</code>; the container will stop.</p>
<h2 id="optional-setup-dedicated-user"><a class="header" href="#optional-setup-dedicated-user">Optional: Setup dedicated user</a></h2>
<p>User UID/GID need to be synchronized between the host OS and container so files are written with correct permission.</p>
<p>You may wish to setup a dedicated user/group on the host OS, in which case the following <code>make</code> targets are available.</p>
<pre><code class="language-bash"># create "erigon" user
make user_linux
# or
make user_macos
</code></pre>
<h3 id="environment-variables"><a class="header" href="#environment-variables">Environment Variables</a></h3>
<p>There is a <code>.env.example</code> file in the root of the repo.</p>
<pre><code>* DOCKER_UID - The UID of the docker user

* DOCKER_GID - The GID of the docker user

* XDG_DATA_HOME - The data directory which will be mounted to the docker containers
</code></pre>
<p>If not specified, the UID/GID will use the current user.</p>
<p>A good choice for <code>XDG_DATA_HOME</code> is to use the <code>~erigon/.ethereum</code> directory created by helper targets <code>make user_linux</code> or <code>make user_macos</code>.</p>
<h3 id="check-permissions"><a class="header" href="#check-permissions">Check: Permissions</a></h3>
<p>In all cases, <code>XDG_DATA_HOME</code> (specified or default) must be writeable by the user UID/GID in docker, which will be determined by the <code>DOCKER_UID</code> and <code>DOCKER_GID</code> at build time.</p>
<p>If a build or service startup is failing due to permissions, check that all the directories, UID, and GID controlled by these environment variables are correct.</p>
<h3 id="run"><a class="header" href="#run">Run</a></h3>
<p>Next command starts: <code>erigon</code> on port <code>30303</code>, <code>rpcdaemon</code> on port <code>8545</code>, <code>prometheus</code> on port <code>9090</code>, and <code>grafana</code> on port <code>3000</code>:</p>
<pre><code>#
# Will mount ~/.local/share/erigon to /home/erigon/.local/share/erigon inside container
#
make docker-compose
#
# or
#
# if you want to use a custom data directory
# or, if you want to use different uid/gid for a dedicated user
#
# To solve this, pass in the uid/gid parameters into the container.
#
# DOCKER_UID: the user id
# DOCKER_GID: the group id
# XDG_DATA_HOME: the data directory (default: ~/.local/share)
#
# Note: /preferred/data/folder must be read/writeable on host OS by user with UID/GID given
#       if you followed above instructions
#
# Note: uid/gid syntax below will automatically use uid/gid of running user so this syntax
#       is intended to be run via the dedicated user setup earlier
#
DOCKER_UID=$(id -u) DOCKER_GID=$(id -g) XDG_DATA_HOME=/preferred/data/folder DOCKER_BUILDKIT=1 COMPOSE_DOCKER_CLI_BUILD=1 make docker-compose
#
# if you want to run the docker, but you are not logged in as the $ERIGON_USER
# then you'll need to adjust the syntax above to grab the correct uid/gid
#
# To run the command via another user, use
#
ERIGON_USER=erigon
sudo -u ${ERIGON_USER} DOCKER_UID=$(id -u ${ERIGON_USER}) DOCKER_GID=$(id -g ${ERIGON_USER}) XDG_DATA_HOME=~${ERIGON_USER}/.ethereum DOCKER_BUILDKIT=1 COMPOSE_DOCKER_CLI_BUILD=1 make docker-compose
</code></pre>
<p><code>makefile</code> creates the initial directories for <code>erigon</code>, <code>prometheus</code> and <code>grafana</code>. The PID namespace is shared between erigon and rpcdaemon which is required to open Erigon's DB from another process (RPCDaemon local-mode). See: <a href="https://github.com/ledgerwatch/erigon/pull/2392/files">https://github.com/ledgerwatch/erigon/pull/2392/files</a></p>
<p>If your docker installation requires the docker daemon to run as root (which is by default), you will need to prefix the command above with <code>sudo</code>. However, it is sometimes recommended running docker (and therefore its containers) as a non-root user for security reasons. For more information about how to do this, refer to this <a href="https://docs.docker.com/engine/install/linux-postinstall/#manage-docker-as-a-non-root-user">article</a>.</p>
<div class="warning">
Windows support for docker-compose is not ready yet.
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="upgrading-from-a-previous-version"><a class="header" href="#upgrading-from-a-previous-version">Upgrading from a previous version</a></h1>
<p>Updating to the latest version of Erigon gives you access to the latest features and ensures optimal performance and stability.</p>
<h2 id="general-recommendations-before-upgrade"><a class="header" href="#general-recommendations-before-upgrade">General Recommendations Before Upgrade</a></h2>
<ul>
<li><strong>Read Release Notes</strong>: Carefully review the <a href="https://github.com/erigontech/erigon/releases">Release Notes</a> for breaking changes and new features relevant to your setup.</li>
<li><strong>Terminate your Erigon</strong>: End your current Erigon session by pressing <code>CTRL+C</code>.</li>
<li><strong>Backup</strong>: Always back up your <code>datadir</code> before performing major upgrades.</li>
</ul>
<h2 id="managing-your-data"><a class="header" href="#managing-your-data">Managing your Data</a></h2>
<p>Erigon 3.1 introduces a new snapshot format while continuing to support the old one. This means that new releases are fully compatible with your existing data. However, users who want the latest data files and data-specific fixes can perform an <strong>optional</strong> manual data upgrade:</p>
<ol>
<li>Backup your datadir.</li>
<li><a href="getting-started/installation/upgrading.html#upgrading-your-erigon-installation">Upgrade your Erigon installation</a> whether from a binary, compiled source code, or Docker.</li>
<li>To initiate the data upgrade, use the following command: <code>./build/bin/erigon snapshots reset --datadir /your/datadir</code>.</li>
<li>Run Erigon, it will reuse existing data and sync only newer snapshots.</li>
</ol>
<h3 id="snapshots-upgrade-options"><a class="header" href="#snapshots-upgrade-options">Snapshots Upgrade Options</a></h3>
<ul>
<li><code>erigon update-to-new-ver-format --datadir /your/datadir</code>: this option updates snapshots to be compatible with latest version, but you will not get the full benefits of the new snapshots.</li>
<li><code>erigon snapshots reset --datadir /your/datadir</code>: this command removes all old snapshots that have had performance improvements.</li>
</ul>
<p>Choose <code>upgrade</code> for a quicker process, or <code>reset</code> for maximum performance. If you choose <code>reset</code>, you'll need to wait for the new snapshots to download once Erigon starts.</p>
<blockquote>
<p>For more information see also <a href="getting-started/installation/upgrading.html#why-upgrading-erigon-doesnt-always-fix-your-data">Why Upgrading Erigon Doesn't Always Fix Your Data</a>.</p>
</blockquote>
<h3 id="snapshots-downgrade-options"><a class="header" href="#snapshots-downgrade-options">Snapshots Downgrade Options</a></h3>
<p>If upgrading snapshots(<code>3.0</code>to <code>3.1</code>) now happens automatically, you should follow these instructions for downgrading:</p>
<blockquote>
<p><strong>WARNING</strong>: This algorithm will remove incompatible <code>3.1</code> snapshot files because they are not backward-compatible.</p>
</blockquote>
<ol>
<li>Make sure that you're running erigon on 3.1.x version, use <code>erigon --version</code>.</li>
<li>Run <code>erigon --datadir ../your/datadir reset-to-old-ver-format</code> to reset your snapshots to old format.</li>
<li><code>git checkout v3.0.x</code> to checkout to preferred <code>3.0</code> version. For example now latest: <code>git checkout v3.0.15</code></li>
<li>Run your old version of Erigon.</li>
</ol>
<h2 id="upgrading-your-erigon-installation"><a class="header" href="#upgrading-your-erigon-installation">Upgrading your Erigon Installation</a></h2>
<p>Follow the below instructions depending on your installation method:</p>
<ul>
<li><a href="getting-started/installation/upgrading.html#pre-built-binaries">Pre-built binaries</a></li>
<li><a href="getting-started/installation/upgrading.html#docker">Docker</a></li>
<li><a href="getting-started/installation/upgrading.html#compiled-from-source">Compiled source code</a></li>
</ul>
<h3 id="pre-built-binaries"><a class="header" href="#pre-built-binaries">Pre-built Binaries</a></h3>
<p>Download the latest binary file from <a href="https://github.com/erigontech/erigon/releases">https://github.com/erigontech/erigon/releases</a>, do the <a href="getting-started/installation/../installation/prebuilt.html#checksums">checksum</a> and reinstall it, no other operation needed.</p>
<h3 id="docker-1"><a class="header" href="#docker-1">Docker</a></h3>
<p>If you're using Docker to run Erigon, the process to upgrade to a newer version of the software is straightforward and revolves around pulling the latest Docker image and then running it. Here's how you can upgrade Erigon using Docker:</p>
<ul>
<li>
<p><strong>Pull the Latest Docker Image</strong>: First, find out the tag of the new release from the <a href="https://hub.docker.com/r/erigontech/erigon">Erigon Docker Hub</a>. Once you know the tag, pull the new image:</p>
<pre><code class="language-bash">docker pull erigontech/erigon:&lt;new_version_tag&gt;
</code></pre>
<p>Replace &lt;new_version_tag&gt; with the actual version tag you wish to use. For example:</p>
<pre><code class="language-bash">docker pull erigontech/erigon:v3.1.0-rc1
</code></pre>
</li>
<li>
<p><strong>List Your Docker Images</strong>: Check your downloaded images to confirm the new image is there and get the new image ID:</p>
<pre><code class="language-bash">docker images
</code></pre>
</li>
<li>
<p><strong>Stop the Running Erigon Container</strong>: If you have a currently running Erigon container, you'll need to stop it before you can start the new version. First, find the container ID by listing the running containers:</p>
<pre><code class="language-bash">docker ps
</code></pre>
<p>Then stop the container using:</p>
<pre><code class="language-bash">docker stop &lt;container_id&gt;
</code></pre>
<p>Replace <code>&lt;container_id&gt;</code> with the actual ID of the container running Erigon.</p>
</li>
<li>
<p><strong>Remove the Old Container</strong>: (Optional) If you want to clean up, you can remove the old container after stopping it:</p>
<pre><code class="language-bash">docker rm &lt;container_id&gt;
</code></pre>
</li>
<li>
<p><strong>Run the New Image</strong>: Now you can start a new container with the new Erigon version using the new image ID:</p>
<pre><code class="language-bash">docker run -it &lt;new_image_id&gt; [options]
</code></pre>
</li>
<li>
<p><strong>Verify Operation</strong>: Ensure that Erigon starts correctly and connects to the desired network, verifying the logs for any initial errors.</p>
</li>
</ul>
<p>By following these steps, you'll keep your Docker setup clean and up-to-date with the latest Erigon version without needing to manually clean up or reconfigure your environment.</p>
<h3 id="compiled-from-source"><a class="header" href="#compiled-from-source">Compiled from source</a></h3>
<p>To upgrade Erigon to a newer version when you've originally installed it via Git and manual compilation, you should follow these steps without needing to delete the entire folder:</p>
<ul>
<li>
<p><strong>Navigate to your Erigon directory</strong>:</p>
<p>For example:</p>
<pre><code class="language-bash">cd erigon
</code></pre>
</li>
<li>
<p><strong>Fetch the latest changes from the repository</strong>: You need to make sure your local repository is up-to-date with the main GitHub repository. Run:</p>
<pre><code class="language-bash">git fetch --tags
</code></pre>
</li>
<li>
<p><strong>Check out</strong> the <a href="https://github.com/erigontech/erigon/releases">latest version</a> and switch to it using:</p>
<pre><code class="language-bash">git checkout &lt;new_version_tag&gt;
</code></pre>
<p>Replace <code>&lt;new_version_tag&gt;</code> with the version tag of the new release, for example:</p>
<pre><code class="language-bash">git checkout v3.1.0
</code></pre>
</li>
<li>
<p><strong>Rebuild Erigon</strong>: Since the codebase has changed, you need to compile the new version. Run:</p>
<pre><code class="language-bash">make erigon
</code></pre>
</li>
</ul>
<p>This process updates your installation to the latest version you specify, while maintaining your existing data. You're essentially just replacing the executable with a newer version.</p>
<h2 id="why-upgrading-erigon-doesnt-always-fix-your-data"><a class="header" href="#why-upgrading-erigon-doesnt-always-fix-your-data">Why Upgrading Erigon Doesn't Always Fix Your Data</a></h2>
<p>Upgrading Erigon involves a key distinction between its core software and its data files, which are managed separately. This approach is rooted in practicality and user control.</p>
<p>The Erigon <strong>software</strong> is the application that processes and interacts with blockchain data. However, the majority of the data itself, including the state of the network, exists in <strong>data files</strong> that you download and store locally.</p>
<p>If a bug is discovered, it is often in the data itself rather than a flaw in the Erigon code. In such a case, simply updating the Erigon binary won't resolve the issue because the faulty data remains on your disk. This is because Erigon upgrades do not normally alter the data files. You must reset and re-download the data snapshots to get the corrected files.</p>
<p>This separation prevents unnecessary and time-consuming processes. The Erigon team cannot regenerate months of data for every minor bug fix, and users shouldn't have to re-download terabytes of information with every new weekly software release.</p>
<p>This design also provides flexibility. A user might need a specific data fix but prefer to remain on an older software version due to a known bug or regression in the latest release. Similarly, a user might be satisfied with their current data set and only need to update the Erigon binary.</p>
<p>While this dual-versioning system may seem complex, it is a deliberate design choice that optimizes for both efficiency and user autonomy.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="migrating-from-geth"><a class="header" href="#migrating-from-geth">Migrating from Geth</a></h1>
<p>This guide provides a smooth and quick transition from <strong>Geth</strong> to <strong>Erigon</strong>. To begin, ensure you have sufficient disk space. The most secure method involves syncing an Erigon node on the same machine along with your existing Geth node. This allows for verification of the Erigon node's proper synchronization, functional verification, and minimal node downtime. This approach is highly recommended for public JSON-RPC providers and validators.</p>
<ul>
<li><strong>If you have enough disk space</strong>, <a href="getting-started/installation/migrating-from-geth.html#option-1-sync-erigon-alongside-geth">Option 1</a> is the recommended choice.</li>
<li><strong>If disk space is limited and downtime is not an option</strong>, we recommend extending the disk or, if not possible, syncing Erigon on a separate machine. Once synced, move all validator-related files to the new machine and decommission the old one.</li>
<li><strong>If downtime of 12 hours or more is acceptable</strong>, see <a href="getting-started/installation/migrating-from-geth.html#option-2-remove-geth-and-sync-erigon">Option 2</a>.</li>
</ul>
<h3 id="option-1-sync-erigon-alongside-geth"><a class="header" href="#option-1-sync-erigon-alongside-geth">Option 1: Sync Erigon Alongside Geth</a></h3>
<p>First, install Erigon and a consensus client of your choice.</p>
<blockquote>
<p>⚠️ <strong>Important considerations:</strong></p>
<ul>
<li>If you use the same consensus client for Erigon that's already paired with Geth, confirm their settings (e.g., data directories) do not conflict.</li>
<li>Ensure the network ports for the Erigon-paired consensus client and the Geth-paired consensus client do not conflict.</li>
<li>Verify that Erigon's JSON-RPC, Engine API, and P2P networking ports are different from Geth's. These ports are configured via command-line options: <code>--http.port &lt;port&gt;</code>, <code>--authrpc.port &lt;port&gt;</code>, and <code>--p2p.listen-addr &lt;IP:port&gt;</code>.</li>
</ul>
</blockquote>
<p>Once the above requirements are met, you can start syncing Erigon. To monitor the sync status, use the <code>eth_syncing</code> JSON-RPC method. When it returns <code>false</code>, Erigon is fully synced and ready to function as a validator. Alternatively, you can use a health check to monitor the sync.</p>
<p>After Erigon is fully synced, shut down both Geth and Erigon, along with their respective consensus clients. Then, restart Erigon using the same ports and JWT secret that Geth previously used. Check the logs for any warnings or errors and confirm that Erigon is following the chain correctly. If everything is in order, you can then safely remove Geth, its associated consensus client, and their data.</p>
<h3 id="option-2-remove-geth-and-sync-erigon"><a class="header" href="#option-2-remove-geth-and-sync-erigon">Option 2: Remove Geth and Sync Erigon</a></h3>
<p>This is the simplest option as it requires no configuration adjustments. However, the node will be down until Erigon finishes syncing.</p>
<ol>
<li>Shut down and remove Geth and its data.</li>
<li>Install Erigon.</li>
<li>Ensure Erigon uses the same network ports and JWT secret that Geth previously used. Otherwise, you must reconfigure the consensus client to match Erigon's new settings.</li>
</ol>
<p>Once these requirements are met, start syncing Erigon. While it syncs, ensure no errors appear in the logs of either Erigon or the consensus client. Note that the sync time can vary depending on the chain. You can periodically check the <code>eth_syncing</code> JSON-RPC method or the health check to monitor the progress.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="easy-nodes"><a class="header" href="#easy-nodes">Easy Nodes</a></h1>
<p>These guides are recommended if you want to test Erigon and have your node up and running in minutes without reading all the documentation.</p>
<ul>
<li><a href="easy-nodes/how-to-run-an-ethereum-node.html">Ethereum node</a></li>
<li><a href="easy-nodes/how-to-run-a-gnosis-chain-node.html">Gnosis Chain node</a></li>
<li><a href="easy-nodes/how-to-run-a-polygon-node.html">Polygon node</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-run-an-ethereum-node"><a class="header" href="#how-to-run-an-ethereum-node">How to run an Ethereum node</a></h1>
<h2 id="prerequisites-1"><a class="header" href="#prerequisites-1">Prerequisites</a></h2>
<ul>
<li>Check the <a href="easy-nodes/../getting-started/hw-requirements.html">hardware</a> prerequisites;</li>
<li>Check which <a href="easy-nodes/../basic/node.html">type of node</a> you want to run and the <a href="easy-nodes/../getting-started/hw-requirements.html#minimal-node-requirements">disk space</a> required.</li>
</ul>
<h2 id="install-erigon"><a class="header" href="#install-erigon">Install Erigon​</a></h2>
<p>To set up Erigon quickly, we recommend the following:</p>
<ul>
<li>For Linux and MacOS users, use our <a href="easy-nodes/../installation/prebuilt.html">pre-built binaries</a>;</li>
<li>For Windows users, <a href="easy-nodes/../installation/build_exec_win.html">build executable binaries natively</a>.</li>
</ul>
<h1 id="start-erigon"><a class="header" href="#start-erigon">Start Erigon​</a></h1>
<p>To execute a Ethereum full node using pre-compiled binaries, use the following basic command:</p>
<pre><code class="language-bash">erigon
</code></pre>
<h2 id="example-of-basic-configuration"><a class="header" href="#example-of-basic-configuration">Example of basic configuration​</a></h2>
<p>The command above allows you to run your local Erigon node on the Ethereum mainnet with Caplin, the embedded Consesus Layer. Additionally, you can include several options, as shown in the following example:</p>
<pre><code class="language-bash">erigon \
--datadir=&lt;your_data_dir&gt; \
--prune.mode=minimal \
--http.addr="0.0.0.0" \
--http.api=eth,web3,net,debug,trace,txpool \
--torrent.download.rate=512mb
</code></pre>
<h3 id="flags-explanation"><a class="header" href="#flags-explanation">Flags explanation</a></h3>
<ul>
<li><code>--datadir=&lt;your_data_dir&gt;</code> to store Erigon files in a non-default location. Default data directory is <code>./home/user/.local/share/erigon</code>.</li>
<li>Erigon is full node by default, use <code>--prune.mode=archive</code> to run a archive node or <code>--prune.mode=minimal</code> (EIP-4444). If you want to change <a href="easy-nodes/../basic/node.html">type of node</a> delete the <code>--datadir</code> folder content and restart Erigon with the appropriate flags.</li>
<li><code>--http.addr="0.0.0.0" --http.api=eth,web3,net,debug,trace,txpool</code> to use RPC and e.g. be able to connect your <a href="easy-nodes/../basic/wallet.html">wallet</a>.</li>
<li><code>--torrent.download.rate=512mb</code> to increase download speed. While the default downloading speed is 128mb, with this flag Erigon will use as much download speed as it can, up to a maximum of 512 megabytes per second. This means it will try to download data as quickly as possible, but it won't exceed the 512 MB/s limit you've set.</li>
<li>Default chain is <code>--chain=mainnet</code> for Ethereum mainnet. Use the flag <code>--chain=holesky</code> for Holesky testnet, <code>--chain=sepolia</code> for Sepolia testnet or <code>--chain=hoodi</code> for Hoodi testnet.</li>
</ul>
<p>To stop your Erigon node you can use the <code>CTRL+C</code> command.</p>
<p>When you get familiar with running Erigon from CLI you may also consider <a href="easy-nodes/../staking.html">staking</a> and/or run a <a href="easy-nodes/ethereum-with-an-external-cl.html">Ethereum node with an external Consensus Layer</a>.</p>
<p>Additional flags can be added to <a href="easy-nodes/../advanced/configuring.html">configure</a> Erigon with several <a href="easy-nodes/../advanced/options.html">options</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ethereum-with-an-external-cl"><a class="header" href="#ethereum-with-an-external-cl">Ethereum with an external CL</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-run-a-gnosis-chain-node"><a class="header" href="#how-to-run-a-gnosis-chain-node">How to run a Gnosis Chain node</a></h1>
<h2 id="prerequisites-2"><a class="header" href="#prerequisites-2">Prerequisites</a></h2>
<ul>
<li>Check the <a href="easy-nodes/../getting-started/hw-requirements.html">hardware</a> prerequisites;</li>
<li>Check which <a href="easy-nodes/../basic/node.html">type of node</a> you want to run and the <a href="easy-nodes/../getting-started/hw-requirements.html#minimal-node-requirements">disk space</a> required.</li>
</ul>
<h2 id="install-erigon-1"><a class="header" href="#install-erigon-1">Install Erigon​</a></h2>
<p>To set up Erigon quickly, we recommend the following:</p>
<ul>
<li>For Linux and MacOS users, use our <a href="easy-nodes/../installation/prebuilt.html">pre-built binaries</a>;</li>
<li>For Windows users, <a href="easy-nodes/../installation/build_exec_win.html">build executable binaries natively</a>.</li>
</ul>
<h1 id="start-erigon-1"><a class="header" href="#start-erigon-1">Start Erigon​</a></h1>
<p>To execute a Gnosis Chain full node using pre-compiled binaries, use the following basic command:</p>
<pre><code class="language-bash">erigon --chain=gnosis
</code></pre>
<h2 id="example-of-basic-configuration-1"><a class="header" href="#example-of-basic-configuration-1">Example of basic configuration​</a></h2>
<p>The command above allows you to run your local Erigon node on the Gnosis Chain. Additionally, you can include several options, as shown in the following example:</p>
<pre><code class="language-bash">erigon \
--chain=gnosis \
--datadir=&lt;your_data_dir&gt; \
--prune.mode=minimal \
--http.addr="0.0.0.0" \
--http.api=eth,web3,net,debug,trace,txpool \
--torrent.download.rate=512mb
</code></pre>
<h3 id="flags-explanation-1"><a class="header" href="#flags-explanation-1">Flags explanation</a></h3>
<ul>
<li><code>--chain=gnosis</code> specifies the Gnosis Chain network, use <code>--chain=chiado</code> for Chiado testnet.</li>
<li><code>--datadir=&lt;your_data_dir&gt;</code> to store Erigon files in a non-default location. Default data directory is <code>./home/user/.local/share/erigon</code>.</li>
<li>Erigon is full node by default, use <code>--prune.mode=archive</code> to run a archive node or <code>--prune.mode=minimal</code> (EIP-4444). If you want to change <a href="easy-nodes/../basic/node.html">type of node</a> delete the <code>--datadir</code> folder content and restart Erigon with the appropriate flags.</li>
<li><code>--http.addr="0.0.0.0" --http.api=eth,web3,net,debug,trace,txpool</code> to use RPC and e.g. be able to connect your <a href="easy-nodes/../basic/wallet.html">wallet</a>.</li>
<li><code>--torrent.download.rate=512mb</code> to increase download speed. While the default downloading speed is 128mb, with this flag Erigon will use as much download speed as it can, up to a maximum of 512 megabytes per second. This means it will try to download data as quickly as possible, but it won't exceed the 512 MB/s limit you've set.</li>
</ul>
<p>To stop your Erigon node you can use the <code>CTRL+C</code> command.</p>
<p>When you get familiar with running Erigon from CLI you may also consider <a href="easy-nodes/../staking.html">staking</a> and/or run a <a href="easy-nodes/gno_extcl.html">Gnosis chain node with an external Consensus Layer</a>.</p>
<p>Additional flags can be added to <a href="easy-nodes/../advanced/configuring.html">configure</a> Erigon with several <a href="easy-nodes/../advanced/options.html">options</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gnosis-with-an-external-cl"><a class="header" href="#gnosis-with-an-external-cl">Gnosis with an external CL</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-run-a-polygon-node"><a class="header" href="#how-to-run-a-polygon-node">How to run a Polygon node</a></h1>
<h2 id="prerequisites-3"><a class="header" href="#prerequisites-3">Prerequisites</a></h2>
<ul>
<li>Check the <a href="easy-nodes/../getting-started/hw-requirements.html">hardware</a> prerequisites;</li>
<li>Check which <a href="easy-nodes/../basic/node.html">type of node</a> you want to run and the <a href="easy-nodes/../getting-started/hw-requirements.html#minimal-node-requirements">disk space</a> required.</li>
</ul>
<h2 id="install-erigon-2"><a class="header" href="#install-erigon-2">Install Erigon​</a></h2>
<p>To set up Erigon quickly, we recommend the following:</p>
<ul>
<li>For Linux and MacOS users, use our <a href="easy-nodes/../installation/prebuilt.html">pre-built binaries</a>;</li>
<li>For Windows users, <a href="easy-nodes/../installation/build_exec_win.html">build executable binaries natively</a>.</li>
</ul>
<h1 id="start-erigon-2"><a class="header" href="#start-erigon-2">Start Erigon</a></h1>
<p>To execute an Erigon full node on the Polygon mainnet with remote Heimdall using pre-compiled binaries, use the following basic command:</p>
<pre><code class="language-bash">erigon --chain=bor-mainnet --bor.heimdall=https://heimdall-api.polygon.technology
</code></pre>
<h2 id="example-of-basic-configuration-2"><a class="header" href="#example-of-basic-configuration-2">Example of basic configuration​</a></h2>
<p>The command above allows you to run your local Erigon node on the Polygon mainnet. Additionally, you can include several options, as shown in the following example:</p>
<pre><code class="language-bash">erigon \
--chain=bor-mainnet \
--bor.heimdall=https://heimdall-api.polygon.technology \
--datadir=&lt;your_data_dir&gt; \
--prune.mode=minimal \
--http.addr="0.0.0.0" \
--http.api=eth,web3,net,debug,trace,txpool \
--torrent.download.rate=512mb
</code></pre>
<h3 id="flags-explanation-2"><a class="header" href="#flags-explanation-2">Flags explanation</a></h3>
<ul>
<li><code>--chain=bor-mainnet</code> and <code>--bor.heimdall=https://heimdall-api.polygon.technologyspecifies</code> specify respctevely the Polygon mainnet and the API endpoint for the Heimdall network; to use Amoy tesnet replace with flags <code>--chain=amoy --bor.heimdall=https://heimdall-api-amoy.polygon.technology</code>.</li>
<li><code>--datadir=&lt;your_data_dir&gt;</code> to store Erigon files in a non-default location. Default data directory is <code>./home/user/.local/share/erigon</code>.</li>
<li>Erigon is full node by default, use <code>--prune.mode=archive</code> to run a archive node or <code>--prune.mode=minimal</code> (EIP-4444). If you want to change <a href="easy-nodes/../basic/node.html">type of node</a> delete the <code>--datadir</code> folder content and restart Erigon with the appropriate flags.</li>
<li><code>--http.addr="0.0.0.0" --http.api=eth,web3,net,debug,trace,txpool</code> to use RPC and e.g. be able to connect your <a href="easy-nodes/../basic/wallet.html">wallet</a>.</li>
<li><code>--torrent.download.rate=512mb</code> to increase download speed. While the default downloading speed is 128mb, with this flag Erigon will use as much download speed as it can, up to a maximum of 512 megabytes per second. This means it will try to download data as quickly as possible, but it won't exceed the 512 MB/s limit you've set.</li>
</ul>
<p>To stop your Erigon node you can use the <code>CTRL+C</code> command.</p>
<p>Several other <a href="easy-nodes/../advanced/configuring.html">configurations</a> and <a href="easy-nodes/../advanced/options.html">options</a> are available.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fundamentals"><a class="header" href="#fundamentals">Fundamentals</a></h1>
<ul>
<li><a href="fundamentals/basic-usage.html">Basic Usage</a></li>
<li><a href="fundamentals/configuring-erigon.html">Configuring Erigon</a></li>
<li><a href="fundamentals/supported-networks.html">Supported Networks</a></li>
<li><a href="fundamentals/layer-2-networks.html">Layer 2 Networks</a></li>
<li><a href="fundamentals/default-ports.html">Default ports</a></li>
<li><a href="fundamentals/sync-modes.html">Sync Modes</a></li>
<li><a href="fundamentals/caplin.html">Caplin</a></li>
<li><a href="fundamentals/optimizing-storage.html">Optimizing Storage</a></li>
<li><a href="fundamentals/logs.html">Logs</a></li>
<li><a href="fundamentals/command-line-options.html">Command-line Options</a></li>
<li><a href="fundamentals/security.html">Security</a></li>
<li><a href="fundamentals/tls-authentication.html">TLS Authentication</a></li>
<li><a href="fundamentals/performance-tricks.html">Performance Tricks</a></li>
<li><a href="fundamentals/modules/modules.html">Modules</a>
<ul>
<li><a href="fundamentals/modules/rpc-daemon.html">RPC Daemon</a></li>
<li><a href="fundamentals/modules/txpool.html">TxPool</a></li>
<li><a href="fundamentals/modules/sentry.html">Sentry</a></li>
<li><a href="fundamentals/modules/downloader.html">Downloader</a></li>
</ul>
</li>
<li><a href="fundamentals/multiple-instances.html">Multiple instances / One machine</a></li>
<li><a href="fundamentals/web3-wallet.html">Web3 Wallet</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basic-usage"><a class="header" href="#basic-usage">Basic Usage</a></h1>
<p>Erigon is primarily controlled using the command line, started using the <code>./build/bin/erigon</code> command and stopped by pressing <code>CTRL-C</code>.</p>
<p>Using the command-line options allows for configurations, and several functionalities can be called using sub commands. To add a configuration flag to the command line simply add the argument and, optionally, its value:</p>
<pre><code class="language-shell">./build/bin/erigon [flag]
</code></pre>
<p>for example:</p>
<pre><code class="language-shell">./build/bin/erigon --chain=holesky
</code></pre>
<p>See here the full list of available <a href="fundamentals/">flags</a>.</p>
<h2 id="all-in-one-client"><a class="header" href="#all-in-one-client">All-in-One Client</a></h2>
<p>The all-in-one client is the preferred option for most users:</p>
<pre><code class="language-bash">./build/bin/erigon
</code></pre>
<p>This CLI command allows you to run an Ethereum <strong>full node</strong> where every process is integrated and no special configuration is needed.</p>
<p>The default Consensus Layer utilized is <a href="fundamentals/./fundamentals/caplin.html">Caplin</a>, the Erigon flagship embedded CL.</p>
<h2 id="basic-configuration"><a class="header" href="#basic-configuration">Basic Configuration​</a></h2>
<ul>
<li>
<p>Default data directory is <code>/home/usr/.local/share/erigon</code>. If you want to store Erigon files in a non-default location, add flag:</p>
<pre><code class="language-bash">--datadir=&lt;your_data_dir&gt;
</code></pre>
</li>
<li>
<p>Based on the <a href="fundamentals/fundamentals/sync-modes.html">sync mode</a> you want to run you can add <code>--prune.mode=archive</code> to run a archive node, <code>--prune.mode=full</code> for a full node or <code>--prune.mode=minimal</code> for a minimal node.
The default node is full node.</p>
</li>
<li>
<p><code>--chain=mainnet</code>, add the flag <code>--chain=sepolia</code> for Sepolia testnet or <code>--chain=holesky</code> for Holesky testnet.</p>
</li>
<li>
<p><code>--http.addr="0.0.0.0" --http.api=eth,web3,net,debug,trace,txpool</code> to use RPC and e.g. be able to connect your <a href="fundamentals/fundamentals/web3-wallet.html">wallet</a>.</p>
</li>
<li>
<p>To increase download speed add <code>--torrent.download.rate=512mb</code> (default is 16mb).</p>
</li>
</ul>
<p>To stop the Erigon node you can use the <code>CTRL+C</code> command.</p>
<p>Additional flags can be added to configure the node with several <a href="fundamentals/fundamentals/fundamentals.html">options</a>.</p>
<h2 id="testnets"><a class="header" href="#testnets">Testnets</a></h2>
<p>If you would like to give Erigon a try, but do not have spare 2TB on your drive, a good option is to start syncing one of the public <a href="fundamentals/fundamentals/supported-networks.html#testnets">testnets</a>, Holesky, adding the option <code>--chain=holesky</code> and using the default Consensus Layer, Caplin. You can also had the flag <code>--prune.mode=minimal</code> to have a node that is syncing fast while taking not so much disk space:</p>
<pre><code class="language-bash">./build/bin/erigon --chain=holesky --prune.mode=minimal
</code></pre>
<h2 id="help"><a class="header" href="#help">Help</a></h2>
<p>To learn about the available commands, open your terminal in your Erigon 3 installation directory and run:</p>
<pre><code class="language-bash">make help
</code></pre>
<p>This command will display a list of convenience commands available in the Makefile, along with their descriptions.</p>
<pre><code> go-version:                        print and verify go version
 validate_docker_build_args:        ensure docker build args are valid
 docker:                            validate, update submodules and build with docker
 setup_xdg_data_home:               TODO
 docker-compose:                    validate build args, setup xdg data home, and run docker-compose up
 dbg                                debug build allows see C stack traces, run it with GOTRACEBACK=crash. You don't need debug build for C pit for profiling. To profile C code use SETCGOTRCKEBACK=1
 erigon:                            build erigon
 all:                               run erigon with all commands
 db-tools:                          build db tools
 test:                              run unit tests with a 100s timeout
 test-integration:                  run integration tests with a 30m timeout
 lint-deps:                         install lint dependencies
 lintci:                            run golangci-lint linters
 lint:                              run all linters
 clean:                             cleans the go cache, build dir, libmdbx db dir
 devtools:                          installs dev tools (and checks for npm installation etc.)
 mocks:                             generate test mocks
 mocks-clean:                       cleans all generated test mocks
 solc:                              generate all solidity contracts
 abigen:                            generate abis using abigen
 gencodec:                          generate marshalling code using gencodec
 graphql:                           generate graphql code
 gen:                               generate all auto-generated code in the codebase
 bindings:                          generate test contracts and core contracts
 prometheus:                        run prometheus and grafana with docker-compose
 escape:                            run escape path={path} to check for memory leaks e.g. run escape path=cmd/erigon
 git-submodules:                    update git submodules
 install:                           copies binaries and libraries to DIST
 user_linux:                        create "erigon" user (Linux)
 user_macos:                        create "erigon" user (MacOS)
 hive:                              run hive test suite locally using docker e.g. OUTPUT_DIR=~/results/hive SIM=ethereum/engine make hive
 automated-tests                    run automated tests (BUILD_ERIGON=0 to prevent erigon build with local image tag)
 help:                              print commands help

</code></pre>
<p>For example, from your Erigon 3 installation directory, run:</p>
<pre><code class="language-bash">make clean
</code></pre>
<p>This will execute the clean target in the Makefile, which cleans the <code>go cache</code>, <code>build</code> directory, and <code>libmdbx</code> db directory.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuring-erigon"><a class="header" href="#configuring-erigon">Configuring Erigon</a></h1>
<p>The Erigon 3 CLI has a wide range of flags that can be used to customize its behavior. There are 3 ways to configure Erigon, listed by priority:</p>
<ul>
<li><a href="fundamentals/configuring-erigon.html#command-line-options">Command line options</a> (flags)</li>
<li><a href="fundamentals/configuring-erigon.html#configuration-file">Configuration file</a></li>
<li><a href="fundamentals/configuring-erigon.html#environment-variables">Environment variables</a></li>
</ul>
<h2 id="command-line-options"><a class="header" href="#command-line-options">Command line options</a></h2>
<p>Here's a breakdown of some of the flags, see <a href="fundamentals/configuring-erigon.html#options">options</a> for the full list:</p>
<h3 id="general-options"><a class="header" href="#general-options">General Options</a></h3>
<p>These flags cover the general behavior and configuration of the Erigon client.</p>
<ul>
<li><code>--datadir value</code>: Specifies the data directory for the databases.
<ul>
<li><strong>Default:</strong> <code>/home/usr/.local/share/erigon</code></li>
</ul>
</li>
<li><code>--ethash.dagdir value</code>: Sets the directory to store the ethash mining DAGs.
<ul>
<li><strong>Default:</strong> <code>/home/usr/.local/share/erigon-ethash</code></li>
</ul>
</li>
<li><code>--config value</code>: Sets Erigon flags using a <a href="fundamentals/configuring-erigon.html#configuration-file">YAML/TOML</a> file.</li>
<li><code>--version, -v</code>: Prints the version information.</li>
<li><code>--help, -h</code>: Displays help information.</li>
<li><code>--chain value</code>: Sets the name of the <a href="fundamentals/supported-networks.html">network</a> to join.
<ul>
<li><strong>Default:</strong> <code>mainnet</code></li>
</ul>
</li>
<li><code>--networkid value</code>: Explicitly sets the network ID.
<ul>
<li><strong>Default:</strong> <code>1</code></li>
</ul>
</li>
<li><code>--identity value</code>: Sets a custom node name.</li>
<li><code>--externalcl</code>: Enables the external consensus layer.
<ul>
<li><strong>Default:</strong> <code>false</code>, means that <a href="fundamentals/configuring-erigon.html#caplin-consensus-layer">Caplin</a> is enabled.</li>
</ul>
</li>
<li><code>--override.osaka value</code>: Manually specifies the Osaka fork time.
<ul>
<li><strong>Default:</strong> <code>0</code></li>
</ul>
</li>
<li><code>--vmdebug</code>: Records information for VM and contract debugging.
<ul>
<li><strong>Default:</strong> <code>false</code></li>
</ul>
</li>
<li><code>--gdbme</code>: Restarts Erigon under gdb for debugging.
<ul>
<li><strong>Default:</strong> <code>false</code></li>
</ul>
</li>
<li><code>--ethstats value</code>: The reporting URL for an ethstats service.</li>
<li><code>--trusted-setup-file value</code>: Absolute path to a <code>trusted_setup.json</code> file.</li>
<li><code>--persist.receipts, --experiment.persist.receipts.v2</code>: Downloads historical receipts.
<ul>
<li><strong>Default:</strong> <code>true</code> for minimal and full nodes, <code>false</code> for archive nodes</li>
</ul>
</li>
</ul>
<h3 id="database-and-caching"><a class="header" href="#database-and-caching">Database and Caching</a></h3>
<p>These flags control database performance and memory usage.</p>
<ul>
<li><code>--db.pagesize value</code>: Sets the fixed page size for the database.
<ul>
<li><strong>Default:</strong> <code>16KB</code></li>
</ul>
</li>
<li><code>--db.size.limit value</code>: Sets a runtime limit on the chaindata database size.
<ul>
<li><strong>Default:</strong> <code>1TB</code></li>
</ul>
</li>
<li><code>--db.writemap</code>: Enables <code>WRITE_MAP</code> for fast database writes.
<ul>
<li><strong>Default:</strong> <code>true</code></li>
</ul>
</li>
<li><code>--db.read.concurrency value</code>: Limits the number of parallel database reads.
<ul>
<li><strong>Default:</strong> <code>1408</code></li>
</ul>
</li>
<li><code>--database.verbosity value</code>: Enables internal database logs.
<ul>
<li><strong>Default:</strong> <code>2</code></li>
</ul>
</li>
<li><code>--batchSize value</code>: Sets the batch size for the execution stage.
<ul>
<li><strong>Default:</strong> <code>512M</code></li>
</ul>
</li>
<li><code>--bodies.cache value</code>: Sets the size limit for the block bodies cache.
<ul>
<li><strong>Default:</strong> <code>268435456</code></li>
</ul>
</li>
<li><code>--state.cache value</code>: Sets the amount of data to store in the StateCache.
<ul>
<li><strong>Default:</strong> <code>0MB</code></li>
</ul>
</li>
<li><code>--sync.parallel-state-flushing</code>: Enables parallel state flushing.
<ul>
<li><strong>Default:</strong> <code>true</code></li>
</ul>
</li>
</ul>
<h3 id="pruning-and-snapshots"><a class="header" href="#pruning-and-snapshots">Pruning and Snapshots</a></h3>
<p>Flags for managing how old chain data is handled and stored.</p>
<ul>
<li><code>--prune.mode value</code>: Selects a pruning preset (<code>full</code>, <code>archive</code>, <code>minimal</code>, <code>blocks</code>).
<ul>
<li><strong>Default:</strong> <code>"full"</code></li>
</ul>
</li>
<li><code>--prune.distance value</code>: Keeps state history for the latest <code>N</code> blocks.
<ul>
<li><strong>Default:</strong> <code>0</code></li>
</ul>
</li>
<li><code>--prune.distance.blocks value</code>: Keeps block history for the latest <code>N</code> blocks.
<ul>
<li><strong>Default:</strong> <code>0</code></li>
</ul>
</li>
<li><code>--prune.experimental.include-commitment-history, --experimental.commitment-history</code>: Enables faster <code>eth_getProof</code> for executed blocks.
<ul>
<li><strong>Default:</strong> <code>false</code></li>
</ul>
</li>
<li><code>--snap.keepblocks</code>: Keeps ancient blocks in the database for debugging.
<ul>
<li><strong>Default:</strong> <code>false</code></li>
</ul>
</li>
<li><code>--snap.stop</code>: Stops generating new snapshots.
<ul>
<li><strong>Default:</strong> <code>false</code></li>
</ul>
</li>
<li><code>--snap.state.stop</code>: Stops generating new state files.
<ul>
<li><strong>Default:</strong> <code>false</code></li>
</ul>
</li>
<li><code>--snap.skip-state-snapshot-download</code>: Skips state download and starts from genesis.
<ul>
<li><strong>Default:</strong> <code>false</code></li>
</ul>
</li>
</ul>
<h3 id="transaction-pool-txpool"><a class="header" href="#transaction-pool-txpool">Transaction Pool (TxPool)</a></h3>
<p>Options for configuring the transaction pool.</p>
<ul>
<li><code>--txpool.api.addr value</code>: The TxPool API network address.
<ul>
<li><strong>Default:</strong> Uses the value of <code>--private.api.addr</code></li>
</ul>
</li>
<li><code>--txpool.disable</code>: Disables the internal transaction pool.
<ul>
<li><strong>Default:</strong> <code>false</code></li>
</ul>
</li>
<li><code>--txpool.pricelimit value</code>: Sets the minimum gas price for acceptance into the pool.
<ul>
<li><strong>Default:</strong> <code>1</code></li>
</ul>
</li>
<li><code>--txpool.pricebump value</code>: Sets the price bump percentage to replace a transaction.
<ul>
<li><strong>Default:</strong> <code>10</code></li>
</ul>
</li>
<li><code>--txpool.blobpricebump value</code>: Sets the price bump percentage for replacing a type-3 blob transaction.
<ul>
<li><strong>Default:</strong> <code>100</code></li>
</ul>
</li>
<li><code>--txpool.accountslots value</code>: Sets the number of executable transaction slots per account.
<ul>
<li><strong>Default:</strong> <code>16</code></li>
</ul>
</li>
<li><code>--txpool.blobslots value</code>: Sets the maximum number of blobs per account.
<ul>
<li><strong>Default:</strong> <code>540</code></li>
</ul>
</li>
<li><code>--txpool.totalblobpoollimit value</code>: Sets the total limit on the number of all blobs in the pool.
<ul>
<li><strong>Default:</strong> <code>5400</code></li>
</ul>
</li>
<li><code>--txpool.globalslots value</code>: Sets the maximum number of executable transaction slots for all accounts.
<ul>
<li><strong>Default:</strong> <code>10000</code></li>
</ul>
</li>
<li><code>--txpool.globalbasefeeslots value</code>: Sets the maximum number of non-executable transactions with insufficient base fees.
<ul>
<li><strong>Default:</strong> <code>30000</code></li>
</ul>
</li>
<li><code>--txpool.globalqueue value</code>: Sets the maximum number of non-executable transaction slots for all accounts.
<ul>
<li><strong>Default:</strong> <code>30000</code></li>
</ul>
</li>
<li><code>--txpool.trace.senders value</code>: A comma-separated list of addresses whose transactions will be traced.</li>
<li><code>--txpool.commit.every value</code>: Sets how often transactions are committed to storage.
<ul>
<li><strong>Default:</strong> <code>15s</code></li>
</ul>
</li>
<li><code>--txpool.gossip.disable</code>: Disables P2P gossip of transactions.
<ul>
<li><strong>Default:</strong> <code>false</code></li>
</ul>
</li>
</ul>
<h3 id="network-and-peers"><a class="header" href="#network-and-peers">Network and Peers</a></h3>
<p>These flags manage network connectivity, peer discovery, and traffic control.</p>
<ul>
<li><code>--port value</code>: The main network listening port.
<ul>
<li><strong>Default:</strong> <code>30303</code></li>
</ul>
</li>
<li><code>--p2p.protocol value</code>: The version of the <code>eth</code> P2P protocol.
<ul>
<li><strong>Default:</strong> <code>68</code>, <code>67</code></li>
</ul>
</li>
<li><code>--p2p.allowed-ports value</code>: A comma-separated list of allowed ports for different P2P protocols.
<ul>
<li><strong>Default:</strong> <code>30303, 30304, 30305, 30306, 30307</code></li>
</ul>
</li>
<li><code>--nat value</code>: The NAT port mapping mechanism.</li>
<li><code>--nodiscover</code>: Disables peer discovery.
<ul>
<li><strong>Default:</strong> <code>false</code></li>
</ul>
</li>
<li><code>--v5disc</code>: Enables the experimental RLPx V5 (Topic Discovery) mechanism.
<ul>
<li><strong>Default:</strong> <code>false</code></li>
</ul>
</li>
<li><code>--netrestrict value</code>: Restricts network communication to specific IP networks.</li>
<li><code>--nodekey value</code>: The P2P node key file.</li>
<li><code>--nodekeyhex value</code>: The P2P node key as a hexadecimal string.</li>
<li><code>--discovery.dns value</code>: Sets DNS discovery entry points.</li>
<li><code>--bootnodes value</code>: Comma-separated enode URLs for P2P discovery bootstrap.</li>
<li><code>--staticpeers value</code>: Comma-separated enode URLs to connect to.</li>
<li><code>--trustedpeers value</code>: Comma-separated enode URLs for trusted peers.</li>
<li><code>--maxpeers value</code>: The maximum number of network peers.
<ul>
<li><strong>Default:</strong> <code>32</code></li>
</ul>
</li>
</ul>
<h3 id="rpc--api"><a class="header" href="#rpc--api">RPC &amp; API</a></h3>
<p>Flags for configuring various RPC servers and their behavior.</p>
<ul>
<li><code>--private.api.addr value</code>: The internal gRPC API address for Erigon's components.
<ul>
<li><strong>Default:</strong> <code>127.0.0.1:9090</code></li>
</ul>
</li>
<li><code>--private.api.ratelimit value</code>: Limits the number of simultaneous internal API requests.
<ul>
<li><strong>Default:</strong> <code>31872</code></li>
</ul>
</li>
<li><code>--http</code>: Enables the JSON-RPC HTTP server.
<ul>
<li><strong>Default:</strong> <code>true</code></li>
</ul>
</li>
<li><code>--http.enabled</code>: An alternative flag to enable the HTTP server.
<ul>
<li><strong>Default:</strong> <code>true</code></li>
</ul>
</li>
<li><code>--graphql</code>: Enables the GraphQL endpoint.
<ul>
<li><strong>Default:</strong> <code>false</code></li>
</ul>
</li>
<li><code>--http.addr value</code>: The HTTP-RPC server listening interface.
<ul>
<li><strong>Default:</strong> <code>localhost</code></li>
</ul>
</li>
<li><code>--http.port value</code>: The HTTP-RPC server listening port.
<ul>
<li><strong>Default:</strong> <code>8545</code></li>
</ul>
</li>
<li><code>--authrpc.addr value</code>: The HTTP-RPC server listening interface for the Engine API.
<ul>
<li><strong>Default:</strong> <code>localhost</code></li>
</ul>
</li>
<li><code>--authrpc.port value</code>: The HTTP-RPC server listening port for the Engine API.
<ul>
<li><strong>Default:</strong> <code>8551</code></li>
</ul>
</li>
<li><code>--authrpc.jwtsecret value</code>: The path to the JWT secret file for the consensus layer.</li>
<li><code>--http.compression</code>: Enables compression over HTTP-RPC.
<ul>
<li><strong>Default:</strong> <code>true</code></li>
</ul>
</li>
<li><code>--http.corsdomain value</code>: A comma-separated list of domains for cross-origin requests.</li>
<li><code>--http.vhosts value</code>: A comma-separated list of virtual hostnames.
<ul>
<li><strong>Default:</strong> <code>localhost</code></li>
</ul>
</li>
<li><code>--authrpc.vhosts value</code>: A comma-separated list of virtual hostnames for the Engine API.
<ul>
<li><strong>Default:</strong> <code>localhost</code></li>
</ul>
</li>
<li><code>--http.api value</code>: The APIs offered over the HTTP-RPC interface.
<ul>
<li><strong>Default:</strong> <code>eth,erigon,engine</code></li>
</ul>
</li>
<li><code>--ws</code>: Enables the WS-RPC server.
<ul>
<li><strong>Default:</strong> <code>false</code></li>
</ul>
</li>
<li><code>--ws.port value</code>: The WS-RPC server listening port.
<ul>
<li><strong>Default:</strong> <code>8546</code></li>
</ul>
</li>
<li><code>--ws.compression</code>: Enables compression over WebSocket.
<ul>
<li><strong>Default:</strong> <code>true</code></li>
</ul>
</li>
<li><code>--rpc.batch.concurrency value</code>: Limits the number of goroutines for batch requests.
<ul>
<li><strong>Default:</strong> <code>2</code></li>
</ul>
</li>
<li><code>--rpc.streaming.disable</code>: Disables JSON streaming for heavy endpoints.
<ul>
<li><strong>Default:</strong> <code>false</code></li>
</ul>
</li>
<li><code>--rpc.accessList value</code>: Specifies a granular API allowlist.</li>
<li><code>--rpc.gascap value</code>: Sets a cap on gas usage for <code>eth_call</code>/<code>estimateGas</code>.
<ul>
<li><strong>Default:</strong> <code>50000000</code></li>
</ul>
</li>
<li><code>--rpc.batch.limit value</code>: Sets the maximum number of requests in a batch.
<ul>
<li><strong>Default:</strong> <code>100</code></li>
</ul>
</li>
<li><code>--rpc.returndata.limit value</code>: Sets the maximum return data size for <code>eth_call</code>.
<ul>
<li><strong>Default:</strong> <code>100000</code></li>
</ul>
</li>
<li><code>--rpc.allow-unprotected-txs</code>: Allows unprotected transactions via RPC.
<ul>
<li><strong>Default:</strong> <code>false</code></li>
</ul>
</li>
<li><code>--rpc.txfeecap value</code>: Sets a cap on transaction fees in ether.
<ul>
<li><strong>Default:</strong> <code>1</code></li>
</ul>
</li>
<li><code>--rpc.slow value</code>: Logs RPC requests slower than the specified threshold.
<ul>
<li><strong>Default:</strong> <code>0s</code></li>
</ul>
</li>
<li><code>--rpc.evmtimeout value</code>: The maximum time to wait for an EVM call.
<ul>
<li><strong>Default:</strong> <code>5m0s</code></li>
</ul>
</li>
<li><code>--rpc.overlay.getlogstimeout value</code>: The maximum time to wait for <code>overlay_getLogs</code>.
<ul>
<li><strong>Default:</strong> <code>5m0s</code></li>
</ul>
</li>
<li><code>--rpc.overlay.replayblocktimeout value</code>: The maximum time to wait to replay a single block.
<ul>
<li><strong>Default:</strong> <code>10s</code></li>
</ul>
</li>
<li><code>--rpc.subscription.filters.maxlogs value</code>: Maximum logs to store per subscription.
<ul>
<li><strong>Default:</strong> <code>0</code></li>
</ul>
</li>
<li><code>--rpc.subscription.filters.maxheaders value</code>: Maximum block headers to store per subscription.
<ul>
<li><strong>Default:</strong> <code>0</code></li>
</ul>
</li>
<li><code>--rpc.subscription.filters.maxtxs value</code>: Maximum transactions to store per subscription.
<ul>
<li><strong>Default:</strong> <code>0</code></li>
</ul>
</li>
<li><code>--rpc.subscription.filters.maxaddresses value</code>: Maximum addresses per subscription to filter logs by.
<ul>
<li><strong>Default:</strong> <code>0</code></li>
</ul>
</li>
<li><code>--rpc.subscription.filters.maxtopics value</code>: Maximum topics per subscription to filter logs by.
<ul>
<li><strong>Default:</strong> <code>0</code></li>
</ul>
</li>
<li><code>--http.timeouts.read value</code>: Maximum duration for reading a request.
<ul>
<li><strong>Default:</strong> <code>30s</code></li>
</ul>
</li>
<li><code>--http.timeouts.write value</code>: Maximum duration before timing out a response write.
<ul>
<li><strong>Default:</strong> <code>30m0s</code></li>
</ul>
</li>
<li><code>--http.timeouts.idle value</code>: Maximum idle time for a connection with keep-alives enabled.
<ul>
<li><strong>Default:</strong> <code>2m0s</code></li>
</ul>
</li>
<li><code>--authrpc.timeouts.read value</code>: Maximum read duration for an Engine API request.
<ul>
<li><strong>Default:</strong> <code>30s</code></li>
</ul>
</li>
<li><code>--authrpc.timeouts.write value</code>: Maximum write duration for an Engine API response.
<ul>
<li><strong>Default:</strong> <code>30m0s</code></li>
</ul>
</li>
<li><code>--authrpc.timeouts.idle value</code>: Maximum idle time for an Engine API connection.
<ul>
<li><strong>Default:</strong> <code>2m0s</code></li>
</ul>
</li>
<li><code>--healthcheck</code>: Enables gRPC health checks.
<ul>
<li><strong>Default:</strong> <code>false</code></li>
</ul>
</li>
</ul>
<h3 id="logging-and-profiling"><a class="header" href="#logging-and-profiling">Logging and Profiling</a></h3>
<p>Flags for controlling logging and performance profiling.</p>
<ul>
<li><code>--log.json</code>: Formats console logs with JSON.
<ul>
<li><strong>Default:</strong> <code>false</code></li>
</ul>
</li>
<li><code>--log.console.json</code>: Formats console logs with JSON.
<ul>
<li><strong>Default:</strong> <code>false</code></li>
</ul>
</li>
<li><code>--log.dir.json</code>: Formats file logs with JSON.
<ul>
<li><strong>Default:</strong> <code>false</code></li>
</ul>
</li>
<li><code>--verbosity value</code>: Sets the log level for console logs.
<ul>
<li><strong>Default:</strong> <code>info</code></li>
</ul>
</li>
<li><code>--log.console.verbosity value</code>: Sets the log level for console logs.
<ul>
<li><strong>Default:</strong> <code>info</code></li>
</ul>
</li>
<li><code>--log.dir.disable</code>: Disables disk logging.
<ul>
<li><strong>Default:</strong> <code>false</code></li>
</ul>
</li>
<li><code>--log.dir.path value</code>: The path to store user and error logs.</li>
<li><code>--log.dir.prefix value</code>: The file name prefix for logs stored on disk.</li>
<li><code>--log.dir.verbosity value</code>: Sets the log verbosity for disk logs.
<ul>
<li><strong>Default:</strong> <code>info</code></li>
</ul>
</li>
<li><code>--log.delays</code>: Enables block delay logging.
<ul>
<li><strong>Default:</strong> <code>false</code></li>
</ul>
</li>
<li><code>--pprof</code>: Enables the pprof HTTP server.
<ul>
<li><strong>Default:</strong> <code>false</code></li>
</ul>
</li>
<li><code>--pprof.addr value</code>: The pprof HTTP server listening interface.
<ul>
<li><strong>Default:</strong> <code>127.0.0.1</code></li>
</ul>
</li>
<li><code>--pprof.port value</code>: The pprof HTTP server listening port.
<ul>
<li><strong>Default:</strong> <code>6060</code></li>
</ul>
</li>
<li><code>--pprof.cpuprofile value</code>: Writes a CPU profile to a file.</li>
<li><code>--trace value</code>: Writes an execution trace to a file.</li>
<li><code>--vmtrace value</code>: Sets the provider tracer.</li>
<li><code>--vmtrace.jsonconfig value</code>: Sets the tracer's configuration.</li>
<li><code>--metrics</code>: Enables metrics collection and reporting.
<ul>
<li><strong>Default:</strong> <code>false</code></li>
</ul>
</li>
<li><code>--metrics.addr value</code>: The stand-alone metrics HTTP server listening interface.
<ul>
<li><strong>Default:</strong> <code>127.0.0.1</code></li>
</ul>
</li>
<li><code>--metrics.port value</code>: The metrics HTTP server listening port.
<ul>
<li><strong>Default:</strong> <code>6061</code></li>
</ul>
</li>
</ul>
<h3 id="consensus-and-forks"><a class="header" href="#consensus-and-forks">Consensus and Forks</a></h3>
<p>Flags related to consensus mechanisms and network forks.</p>
<ul>
<li><code>--clique.checkpoint value</code>: The number of blocks after which to save the vote snapshot.
<ul>
<li><strong>Default:</strong> <code>10</code></li>
</ul>
</li>
<li><code>--clique.snapshots value</code>: The number of recent vote snapshots to keep in memory.
<ul>
<li><strong>Default:</strong> <code>1024</code></li>
</ul>
</li>
<li><code>--clique.signatures value</code>: The number of recent block signatures to keep in memory.
<ul>
<li><strong>Default:</strong> <code>16384</code></li>
</ul>
</li>
<li><code>--clique.datadir value</code>: The path to the clique database folder.</li>
<li><code>--fakepow</code>: Disables proof-of-work verification.
<ul>
<li><strong>Default:</strong> <code>false</code></li>
</ul>
</li>
<li><code>--gpo.blocks value</code>: The number of recent blocks to check for gas prices.
<ul>
<li><strong>Default:</strong> <code>20</code></li>
</ul>
</li>
<li><code>--gpo.percentile value</code>: The percentile of recent transaction gas prices to use for a suggested gas price.
<ul>
<li><strong>Default:</strong> <code>60</code></li>
</ul>
</li>
<li><code>--proposer.disable</code>: Disables the PoS proposer.
<ul>
<li><strong>Default:</strong> <code>false</code></li>
</ul>
</li>
<li><code>--bor.heimdall value</code>: The URL of the Heimdall service.
<ul>
<li><strong>Default:</strong> <code>http://localhost:1317</code></li>
</ul>
</li>
<li><code>--bor.withoutheimdall</code>: Runs without the Heimdall service.
<ul>
<li><strong>Default:</strong> <code>false</code></li>
</ul>
</li>
<li><code>--bor.period</code>: Overrides the bor block period.
<ul>
<li><strong>Default:</strong> <code>false</code></li>
</ul>
</li>
<li><code>--bor.minblocksize</code>: Ignores the bor block period and waits for <code>blocksize</code> transactions.
<ul>
<li><strong>Default:</strong> <code>false</code></li>
</ul>
</li>
<li><code>--polygon.pos.ssf</code>: Enables Polygon PoS Single Slot Finality.
<ul>
<li><strong>Default:</strong> <code>false</code></li>
</ul>
</li>
<li><code>--polygon.pos.ssf.block value</code>: Enables Polygon PoS Single Slot Finality from a specific block.
<ul>
<li><strong>Default:</strong> <code>0</code></li>
</ul>
</li>
</ul>
<h3 id="sentry"><a class="header" href="#sentry">Sentry</a></h3>
<p>Flags for configuring the Sentry component.</p>
<ul>
<li><code>--sentry.api.addr value</code>: A comma-separated list of sentry addresses.</li>
<li><code>--sentry.log-peer-info</code>: Logs detailed peer info when a peer connects or disconnects.
<ul>
<li><strong>Default:</strong> <code>false</code></li>
</ul>
</li>
<li><code>--sentinel.addr value</code>: The address for the sentinel component.
<ul>
<li><strong>Default:</strong> <code>localhost</code></li>
</ul>
</li>
<li><code>--sentinel.port value</code>: The port for the sentinel component.
<ul>
<li><strong>Default:</strong> <code>7777</code></li>
</ul>
</li>
<li><code>--sentinel.bootnodes value</code>: Comma-separated enode URLs for P2P discovery bootstrap for the sentinel.</li>
<li><code>--sentinel.staticpeers value</code>: Connects to comma-separated consensus static peers.</li>
</ul>
<h3 id="downloader"><a class="header" href="#downloader">Downloader</a></h3>
<p>Flags for controlling the downloader component.</p>
<ul>
<li><code>--downloader.api.addr value</code>: The downloader address.</li>
<li><code>--downloader.disable.ipv4</code>: Disables IPv4 for the downloader.
<ul>
<li><strong>Default:</strong> <code>false</code></li>
</ul>
</li>
<li><code>--downloader.disable.ipv6</code>: Disables IPv6 for the downloader.
<ul>
<li><strong>Default:</strong> <code>false</code></li>
</ul>
</li>
<li><code>--no-downloader</code>: Disables the downloader component.
<ul>
<li><strong>Default:</strong> <code>false</code></li>
</ul>
</li>
<li><code>--downloader.verify</code>: Verifies snapshots on startup.
<ul>
<li><strong>Default:</strong> <code>false</code></li>
</ul>
</li>
<li><code>--sync.loop.throttle value</code>: Sets the minimum time between sync loop starts.</li>
<li><code>--sync.loop.block.limit value</code>: Sets the maximum number of blocks to process per loop iteration.
<ul>
<li><strong>Default:</strong> <code>5000</code></li>
</ul>
</li>
<li><code>--sync.loop.break.after value</code>: Sets the last stage of the sync loop to run.</li>
<li><code>--bad.block value</code>: Marks a block as bad and forces a reorg.</li>
<li><code>--webseed value</code>: Comma-separated URLs for network support infrastructure.</li>
</ul>
<h3 id="caplin-consensus-layer"><a class="header" href="#caplin-consensus-layer">Caplin (Consensus Layer)</a></h3>
<p>Flags for configuring the Caplin consensus layer.</p>
<ul>
<li><code>--caplin.discovery.addr value</code>: The address for the Caplin DISCV5 protocol.
<ul>
<li><strong>Default:</strong> <code>0.0.0.0</code></li>
</ul>
</li>
<li><code>--caplin.discovery.port value</code>: The port for the Caplin DISCV5 protocol.
<ul>
<li><strong>Default:</strong> <code>4000</code></li>
</ul>
</li>
<li><code>--caplin.discovery.tcpport value</code>: The TCP port for the Caplin DISCV5 protocol.
<ul>
<li><strong>Default:</strong> <code>4001</code></li>
</ul>
</li>
<li><code>--caplin.checkpoint-sync-url value</code>: The checkpoint sync endpoint.</li>
<li><code>--caplin.subscribe-all-topics</code>: Subscribes to all gossip topics.
<ul>
<li><strong>Default:</strong> <code>false</code></li>
</ul>
</li>
<li><code>--caplin.max-peer-count value</code>: The maximum number of peers to connect to.
<ul>
<li><strong>Default:</strong> <code>128</code></li>
</ul>
</li>
<li><code>--caplin.enable-upnp</code>: Enables NAT porting for Caplin.
<ul>
<li><strong>Default:</strong> <code>false</code></li>
</ul>
</li>
<li><code>--caplin.max-inbound-traffic-per-peer value</code>: The maximum inbound traffic per second per peer.
<ul>
<li><strong>Default:</strong> <code>1MB</code></li>
</ul>
</li>
<li><code>--caplin.max-outbound-traffic-per-peer value</code>: The maximum outbound traffic per second per peer.
<ul>
<li><strong>Default:</strong> <code>1MB</code></li>
</ul>
</li>
<li><code>--caplin.adaptable-maximum-traffic-requirements</code>: Makes the node adaptable to traffic based on the number of validators.
<ul>
<li><strong>Default:</strong> <code>true</code></li>
</ul>
</li>
<li><code>--caplin.blocks-archive</code>: Enables backfilling for blocks.
<ul>
<li><strong>Default:</strong> <code>false</code></li>
</ul>
</li>
<li><code>--caplin.blobs-archive</code>: Enables backfilling for blobs.
<ul>
<li><strong>Default:</strong> <code>false</code></li>
</ul>
</li>
<li><code>--caplin.states-archive</code>: Enables the archival node for historical states.
<ul>
<li><strong>Default:</strong> <code>false</code></li>
</ul>
</li>
<li><code>--caplin.blobs-immediate-backfill</code>: Tells Caplin to immediately backfill blobs.
<ul>
<li><strong>Default:</strong> <code>false</code></li>
</ul>
</li>
<li><code>--caplin.blobs-no-pruning</code>: Disables blob pruning.
<ul>
<li><strong>Default:</strong> <code>false</code></li>
</ul>
</li>
<li><code>--caplin.checkpoint-sync.disable</code>: Disables checkpoint sync.
<ul>
<li><strong>Default:</strong> <code>false</code></li>
</ul>
</li>
<li><code>--caplin.snapgen</code>: Enables snapshot generation.
<ul>
<li><strong>Default:</strong> <code>false</code></li>
</ul>
</li>
<li><code>--caplin.mev-relay-url value</code>: The MEV relay endpoint.</li>
<li><code>--caplin.validator-monitor</code>: Enables Caplin validator monitoring metrics.
<ul>
<li><strong>Default:</strong> <code>false</code></li>
</ul>
</li>
<li><code>--caplin.custom-config value</code>: Sets a custom config for Caplin.</li>
<li><code>--caplin.custom-genesis value</code>: Sets a custom genesis for Caplin.</li>
<li><code>--caplin.use-engine-api</code>: Uses the Engine API for internal Caplin.
<ul>
<li><strong>Default:</strong> <code>false</code></li>
</ul>
</li>
</ul>
<h3 id="shutter-network-encrypted-transactions"><a class="header" href="#shutter-network-encrypted-transactions">Shutter Network Encrypted Transactions</a></h3>
<p>Flags for configuring the Shutter Network encrypted transactions mempool.</p>
<ul>
<li><code>--shutter</code>: Enables the Shutter encrypted transactions mempool.
<ul>
<li><strong>Default:</strong> <code>false</code></li>
</ul>
</li>
<li><code>--shutter.p2p.bootstrap.nodes value</code>: Overrides the default P2P bootstrap nodes.</li>
<li><code>--shutter.p2p.listen.port value</code>: Overrides the default P2P listen port.
<ul>
<li><strong>Default:</strong> <code>0</code></li>
</ul>
</li>
</ul>
<h3 id="downloader-1"><a class="header" href="#downloader-1">Downloader</a></h3>
<p>Flags for managing the Downloader for data synchronization.</p>
<ul>
<li><code>--torrent.port value</code>: The port to listen for the BitTorrent protocol.
<ul>
<li><strong>Default:</strong> <code>42069</code></li>
</ul>
</li>
<li><code>--torrent.maxpeers value</code>: An unused parameter.
<ul>
<li><strong>Default:</strong> <code>100</code></li>
</ul>
</li>
<li><code>--torrent.conns.perfile value</code>: The number of connections per file.
<ul>
<li><strong>Default:</strong> <code>10</code></li>
</ul>
</li>
<li><code>--torrent.trackers.disable</code>: Disables conventional BitTorrent trackers.
<ul>
<li><strong>Default:</strong> <code>false</code></li>
</ul>
</li>
<li><code>--torrent.upload.rate value</code>: The upload rate in bytes per second.
<ul>
<li><strong>Default:</strong> <code>32mb</code></li>
</ul>
</li>
<li><code>--torrent.download.rate value</code>: The download rate in bytes per second.</li>
<li><code>--torrent.webseed.download.rate value</code>: The download rate for webseeds.</li>
<li><code>--torrent.verbosity value</code>: Sets the verbosity level for BitTorrent logs.
<ul>
<li><strong>Default:</strong> <code>1</code></li>
</ul>
</li>
</ul>
<h2 id="configuration-file"><a class="header" href="#configuration-file">Configuration file</a></h2>
<p>You can configure Erigon using a YAML or TOML configuration file by specifying its path with the <code>--config</code> flag.</p>
<blockquote>
<p><strong>Note</strong>: flags specified in the configuration file can be overridden by directly setting them in the Erigon command line.</p>
</blockquote>
<p>Both in YAML and TOML files boolean operators (<code>false</code>, <code>true</code>) and strings without spaces can be specified without quotes, while strings with spaces must be included in <code>""</code> or <code>''</code> quotes.</p>
<h3 id="yaml"><a class="header" href="#yaml">YAML</a></h3>
<p>Use the <code>--config</code> flag to point at the YAML configuration file.</p>
<pre><code class="language-bash">./build/bin/erigon --config ./config.yaml --chain=holesky
</code></pre>
<p>Example of a YAML config file:</p>
<pre><code class="language-yaml">datadir : 'your datadir'
chain : "mainnet"
http : true
http.api : ["eth","debug","net"]
</code></pre>
<p>In this case the <code>--chain</code> flag in the command line will override the value in the YAML file and Erigon will run on the Holesky testnet.</p>
<h3 id="toml"><a class="header" href="#toml">TOML</a></h3>
<p>Use the <code>--config</code> flag to point at the TOML configuration file.</p>
<pre><code class="language-bash">./build/bin/erigon --config ./config.toml
</code></pre>
<p>Example of a TOML config file:</p>
<pre><code class="language-toml">datadir = 'your datadir'
chain = "mainnet"
http = true
"http.api" = ["eth","debug","net"]
</code></pre>
<h2 id="environment-variables-1"><a class="header" href="#environment-variables-1">Environment variables</a></h2>
<p>Erigon supports configuration through environment variables, primarily for experimental features and advanced settings.</p>
<h3 id="core-environment-variables"><a class="header" href="#core-environment-variables">Core Environment Variables</a></h3>
<p><strong>Database and Performance:</strong></p>
<ul>
<li><code>MDBX_LOCK_IN_RAM</code> - Locks MDBX database in RAM for better performance</li>
<li><code>MDBX_DIRTY_SPACE_MB</code> - Sets dirty space limit for MDBX database</li>
<li><code>SNAPSHOT_MADV_RND</code> - Controls snapshot memory advice randomization (default: <code>true</code>)</li>
</ul>
<p><strong>Synchronization and Pruning:</strong></p>
<ul>
<li><code>NO_PRUNE</code> - Disables pruning when set to true <a href="fundamentals/configuring-erigon.html#0-4">5</a></li>
<li><code>NO_MERGE</code> - Disables merging operations <a href="fundamentals/configuring-erigon.html#0-5">6</a></li>
<li><code>PRUNE_TOTAL_DIFFICULTY</code> - Controls total difficulty pruning (default: <code>true</code>)</li>
<li><code>MAX_REORG_DEPTH</code> - Sets maximum reorganization depth (default: <code>512</code>)</li>
</ul>
<p><strong>Execution and Processing:</strong></p>
<ul>
<li><code>EXEC3_PARALLEL</code> - Enables parallel execution in version 3</li>
<li><code>EXEC3_WORKERS</code> - Sets number of execution workers</li>
<li><code>STAGES_ONLY_BLOCKS</code> - Limits stages to blocks only</li>
</ul>
<h3 id="memory-and-debugging-variables"><a class="header" href="#memory-and-debugging-variables">Memory and Debugging Variables</a></h3>
<p><strong>Memory Management:</strong></p>
<ul>
<li><code>NO_MEMSTAT</code> - Disables memory statistics collection</li>
<li><code>SAVE_HEAP_PROFILE</code> - Enables automatic heap profiling</li>
<li><code>HEAP_PROFILE_THRESHOLD</code> - Memory usage percentage threshold for heap profiling (default: 35%)</li>
</ul>
<p><strong>Tracing and Debugging:</strong></p>
<ul>
<li><code>TRACE_ACCOUNTS</code> - Comma-separated list of accounts to trace</li>
<li><code>TRACE_BLOCKS</code> - Comma-separated list of block numbers to trace</li>
<li><code>TRACE_INSTRUCTIONS</code> - Enables instruction-level tracing</li>
</ul>
<h3 id="docker-environment-variables"><a class="header" href="#docker-environment-variables">Docker Environment Variables</a></h3>
<p>When running Erigon in Docker, you can configure user permissions and data directories:</p>
<ul>
<li><code>DOCKER_UID</code> - The UID of the docker user</li>
<li><code>DOCKER_GID</code> - The GID of the docker user</li>
<li><code>XDG_DATA_HOME</code> - The data directory mounted to containers</li>
</ul>
<h3 id="usage-examples"><a class="header" href="#usage-examples">Usage Examples</a></h3>
<p><strong>Basic Performance Tuning:</strong></p>
<pre><code class="language-bash">export MDBX_LOCK_IN_RAM=true
export SNAPSHOT_MADV_RND=false
./build/bin/erigon --datadir=/path/to/data
</code></pre>
<p><strong>Memory Debugging:</strong></p>
<pre><code class="language-bash">export SAVE_HEAP_PROFILE=true
export HEAP_PROFILE_THRESHOLD=45
./build/bin/erigon --datadir=/path/to/data
</code></pre>
<p><strong>Docker Deployment:</strong></p>
<pre><code class="language-bash">export DOCKER_UID=$(id -u)
export DOCKER_GID=$(id -g)
export XDG_DATA_HOME=/preferred/data/folder
make docker-compose
</code></pre>
<h2 id="options"><a class="header" href="#options">Options</a></h2>
<p><em>All available options</em></p>
<p>The <code>--help</code> flag listing is reproduced below for your convenience.</p>
<pre><code class="language-bash">./build/bin/erigon --help
</code></pre>
<pre><code class="language-shell">NAME:
   erigon - erigon

USAGE:
   erigon [command] [flags]

VERSION:
   3.1.0-816f2232

COMMANDS:
   init                                         Bootstrap and initialize a new genesis block
   import                                       Import a blockchain file
   snapshots, seg, snapshot, segments, segment  Managing historical data segments (partitions)
   support                                      Connect Erigon instance to a diagnostics system for support
   help, h                                      Shows a list of commands or help for one command

GLOBAL OPTIONS:
   --datadir value                                                                     Data directory for the databases (default: /home/usr/.local/share/erigon)
   --ethash.dagdir value                                                               Directory to store the ethash mining DAGs (default: /home/usr/.local/share/erigon-ethash)
   --externalcl                                                                        Enables the external consensus layer (default: false)
   --txpool.disable                                                                    External pool and block producer, see ./cmd/txpool/readme.md for more info. Disabling internal txpool and block producer. (default: false)
   --txpool.pricelimit value                                                           Minimum gas price (fee cap) limit to enforce for acceptance into the pool (default: 1)
   --txpool.pricebump value                                                            Price bump percentage to replace an already existing transaction (default: 10)
   --txpool.blobpricebump value                                                        Price bump percentage to replace existing (type-3) blob transaction (default: 100)
   --txpool.accountslots value                                                         Minimum number of executable transaction slots guaranteed per account (default: 16)
   --txpool.blobslots value                                                            Max allowed total number of blobs (within type-3 txs) per account (default: 540)
   --txpool.totalblobpoollimit value                                                   Total limit of number of all blobs in txs within the txpool (default: 5400)
   --txpool.globalslots value                                                          Maximum number of executable transaction slots for all accounts (default: 10000)
   --txpool.globalbasefeeslots value                                                   Maximum number of non-executable transactions where only not enough baseFee (default: 30000)
   --txpool.globalqueue value                                                          Maximum number of non-executable transaction slots for all accounts (default: 30000)
   --txpool.trace.senders value                                                        Comma separated list of addresses, whose transactions will traced in transaction pool with debug printing
   --txpool.commit.every value                                                         How often transactions should be committed to the storage (default: 15s)
   --prune.distance value                                                              Keep state history for the latest N blocks (default: everything) (default: 0)
   --prune.distance.blocks value                                                       Keep block history for the latest N blocks (default: everything) (default: 0)
   --prune.mode value                                                                  Choose a pruning preset to run onto. Available values: "full", "archive", "minimal", "blocks".
                                                                                             full: Keep only necessary blocks and latest state,
                                                                                             blocks: Keep all blocks but not the state history,
                                                                                             archive: Keep the entire state history and all blocks,
                                                                                             minimal: Keep only latest state (default: "full")
   --prune.experimental.include-commitment-history, --experimental.commitment-history  Enables blazing fast eth_getProof for executed block (default: false)
   --batchSize value                                                                   Batch size for the execution stage (default: "512M")
   --bodies.cache value                                                                Limit on the cache for block bodies (default: "268435456")
   --database.verbosity value                                                          Enabling internal db logs. Very high verbosity levels may require recompile db. Default: 2, means warning. (default: 2)
   --private.api.addr value                                                            Erigon's components (txpool, rpcdaemon, sentry, downloader, ...) can be deployed as independent Processes on same/another server. Then components will connect to erigon by this internal grpc API. example: 127.0.0.1:9090, empty string means not to start the listener. do not expose to public network. serves remote database interface (default: "127.0.0.1:9090")
   --private.api.ratelimit value                                                       Amount of requests server handle simultaneously - requests over this limit will wait. Increase it - if clients see 'request timeout' while server load is low - it means your 'hot data' is small or have much RAM.  (default: 31872)
   --etl.bufferSize value                                                              Buffer size for ETL operations. (default: "256MB")
   --tls                                                                               Enable TLS handshake (default: false)
   --tls.cert value                                                                    Specify certificate
   --tls.key value                                                                     Specify key file
   --tls.cacert value                                                                  Specify certificate authority
   --state.stream.disable                                                              Disable streaming of state changes from core to RPC daemon (default: false)
   --sync.loop.throttle value                                                          Sets the minimum time between sync loop starts (e.g. 1h30m, default is none)
   --bad.block value                                                                   Marks block with given hex string as bad and forces initial reorg before normal staged sync
   --http                                                                              JSON-RPC server (enabled by default). Use --http=false to disable it (default: true)
   --http.enabled                                                                      JSON-RPC HTTP server (enabled by default). Use --http.enabled=false to disable it (default: true)
   --graphql                                                                           Enable the graphql endpoint (default: false)
   --http.addr value                                                                   HTTP-RPC server listening interface (default: "localhost")
   --http.port value                                                                   HTTP-RPC server listening port (default: 8545)
   --authrpc.addr value                                                                HTTP-RPC server listening interface for the Engine API (default: "localhost")
   --authrpc.port value                                                                HTTP-RPC server listening port for the Engine API (default: 8551)
   --authrpc.jwtsecret value                                                           Path to the token that ensures safe connection between CL and EL
   --http.compression                                                                  Enable compression over HTTP-RPC. Use --http.compression=false to disable it (default: true)
   --http.corsdomain value                                                             Comma separated list of domains from which to accept cross origin requests (browser enforced)
   --http.vhosts value                                                                 Comma separated list of virtual hostnames from which to accept requests (server enforced). Accepts 'any' or '*' as wildcard. (default: "localhost")
   --authrpc.vhosts value                                                              Comma separated list of virtual hostnames from which to accept Engine API requests (server enforced). Accepts 'any' or '*' as wildcard. (default: "localhost")
   --http.api value                                                                    API's offered over the HTTP-RPC interface (default: "eth,erigon,engine")
   --ws.port value                                                                     WS-RPC server listening port (default: 8546)
   --ws                                                                                Enable the WS-RPC server (default: false)
   --ws.compression                                                                    Enable compression over WebSocket (enabled by default in case WS-RPC is enabled). Use --ws.enabled=false to disable it (default: true)
   --http.trace                                                                        Print all HTTP requests to logs with INFO level (default: false)
   --http.dbg.single                                                                   Allow pass HTTP header 'dbg: true' to printt more detailed logs - how this request was executed (default: false)
   --state.cache value                                                                 Amount of data to store in StateCache (enabled if no --datadir set). Set 0 to disable StateCache. Defaults to 0MB (default: "0MB")
   --rpc.batch.concurrency value                                                       Does limit amount of goroutines to process 1 batch request. Means 1 bach request can't overload server. 1 batch still can have unlimited amount of request (default: 2)
   --rpc.streaming.disable                                                             Erigon has enabled json streaming for some heavy endpoints (like trace_*). It's a trade-off: greatly reduce amount of RAM (in some cases from 30GB to 30mb), but it produce invalid json format if error happened in the middle of streaming (because json is not streaming-friendly format) (default: false)
   --db.read.concurrency value                                                         Does limit amount of parallel db reads. Default: equal to GOMAXPROCS (or number of CPU) (default: 1408)
   --rpc.accessList value                                                              Specify granular (method-by-method) API allowlist
   --trace.compat                                                                      Bug for bug compatibility with OE for trace_ routines (default: false)
   --rpc.gascap value                                                                  Sets a cap on gas that can be used in eth_call/estimateGas (default: 50000000)
   --rpc.batch.limit value                                                             Maximum number of requests in a batch (default: 100)
   --rpc.returndata.limit value                                                        Maximum number of bytes returned from eth_call or similar invocations (default: 100000)
   --rpc.allow-unprotected-txs                                                         Allow for unprotected (non-EIP155 signed) transactions to be submitted via RPC (default: false)
   --rpc.txfeecap value                                                                Sets a cap on transaction fee (in ether) that can be sent via the RPC APIs (0 = no cap) (default: 1)
   --txpool.api.addr value                                                             TxPool api network address, for example: 127.0.0.1:9090 (default: use value of --private.api.addr)
   --trace.maxtraces value                                                             Sets a limit on traces that can be returned in trace_filter (default: 200)
   --http.timeouts.read value                                                          Maximum duration for reading the entire request, including the body. (default: 30s)
   --http.timeouts.write value                                                         Maximum duration before timing out writes of the response. It is reset whenever a new request's header is read. (default: 30m0s)
   --http.timeouts.idle value                                                          Maximum amount of time to wait for the next request when keep-alive connections are enabled. If http.timeouts.idle is zero, the value of http.timeouts.read is used. (default: 2m0s)
   --authrpc.timeouts.read value                                                       Maximum duration for reading the entire request, including the body. (default: 30s)
   --authrpc.timeouts.write value                                                      Maximum duration before timing out writes of the response. It is reset whenever a new request's header is read. (default: 30m0s)
   --authrpc.timeouts.idle value                                                       Maximum amount of time to wait for the next request when keep-alive connections are enabled. If authrpc.timeouts.idle is zero, the value of authrpc.timeouts.read is used. (default: 2m0s)
   --rpc.evmtimeout value                                                              Maximum amount of time to wait for the answer from EVM call. (default: 5m0s)
   --rpc.overlay.getlogstimeout value                                                  Maximum amount of time to wait for the answer from the overlay_getLogs call. (default: 5m0s)
   --rpc.overlay.replayblocktimeout value                                              Maximum amount of time to wait for the answer to replay a single block when called from an overlay_getLogs call. (default: 10s)
   --rpc.subscription.filters.maxlogs value                                            Maximum number of logs to store per subscription. (default: 0)
   --rpc.subscription.filters.maxheaders value                                         Maximum number of block headers to store per subscription. (default: 0)
   --rpc.subscription.filters.maxtxs value                                             Maximum number of transactions to store per subscription. (default: 0)
   --rpc.subscription.filters.maxaddresses value                                       Maximum number of addresses per subscription to filter logs by. (default: 0)
   --rpc.subscription.filters.maxtopics value                                          Maximum number of topics per subscription to filter logs by. (default: 0)
   --snap.keepblocks                                                                   Keep ancient blocks in db (useful for debug) (default: false)
   --snap.stop                                                                         Workaround to stop producing new snapshots, if you meet some snapshots-related critical bug. It will stop move historical data from DB to new immutable snapshots. DB will grow and may slightly slow-down - and removing this flag in future will not fix this effect (db size will not greatly reduce). (default: false)
   --snap.state.stop                                                                   Workaround to stop producing new state files, if you meet some state-related critical bug. It will stop aggregate DB history in a state files. DB will grow and may slightly slow-down - and removing this flag in future will not fix this effect (db size will not greatly reduce). (default: false)
   --snap.skip-state-snapshot-download                                                 Skip state download and start from genesis block (default: false)
   --db.pagesize value                                                                 DB is splitted to 'pages' of fixed size. Can't change DB creation. Must be power of 2 and '256b &lt;= pagesize &lt;= 64kb'. Default: equal to OperationSystem's pageSize. Bigger pageSize causing: 1. More writes to disk during commit 2. Smaller b-tree high 3. Less fragmentation 4. Less overhead on 'free-pages list' maintainance (a bit faster Put/Commit) 5. If expecting DB-size &gt; 8Tb then set pageSize &gt;= 8Kb (default: "16KB")
   --db.size.limit value                                                               Runtime limit of chaindata db size (can change at any time) (default: "1TB")
   --db.writemap                                                                       Enable WRITE_MAP feature for fast database writes and fast commit times (default: true)
   --torrent.port value                                                                Port to listen and serve BitTorrent protocol (default: 42069)
   --torrent.maxpeers value                                                            Unused parameter (reserved for future use) (default: 100)
   --torrent.conns.perfile value                                                       Number of connections per file (default: 10)
   --torrent.trackers.disable                                                          Disable conventional BitTorrent trackers (default: false)
   --torrent.upload.rate value                                                         Bytes per second, example: 32mb (default: "32mb")
   --torrent.download.rate value                                                       Bytes per second, example: 32mb. Shared with webseeds unless that rate is set separately.
   --torrent.webseed.download.rate value                                               Bytes per second for webseeds, example: 32mb. If not set, rate limit is shared with torrent.download.rate
   --torrent.verbosity value                                                           0=silent, 1=error, 2=warn, 3=info, 4=debug, 5=detail (must set --verbosity to equal or higher level and has default: 2) (default: 1)
   --port value                                                                        Network listening port (default: 30303)
   --p2p.protocol value [ --p2p.protocol value ]                                       Version of eth p2p protocol (default: 68, 67)
   --p2p.allowed-ports value [ --p2p.allowed-ports value ]                             Allowed ports to pick for different eth p2p protocol versions as follows &lt;porta&gt;,&lt;portb&gt;,..,&lt;porti&gt; (default: 30303, 30304, 30305, 30306, 30307)
   --nat value                                                                         NAT port mapping mechanism (any|none|upnp|pmp|stun|extip:&lt;IP&gt;)
                                                                                            "" or "none"         Default - do not nat
                                                                                            "extip:77.12.33.4"   Will assume the local machine is reachable on the given IP
                                                                                            "any"                Uses the first auto-detected mechanism
                                                                                            "upnp"               Uses the Universal Plug and Play protocol
                                                                                            "pmp"                Uses NAT-PMP with an auto-detected gateway address
                                                                                            "pmp:192.168.0.1"    Uses NAT-PMP with the given gateway address
                                                                                            "stun"               Uses STUN to detect an external IP using a default server
                                                                                            "stun:&lt;server&gt;"      Uses STUN to detect an external IP using the given server (host:port)
   --nodiscover                                                                        Disables the peer discovery mechanism (manual peer addition) (default: false)
   --v5disc                                                                            Enables the experimental RLPx V5 (Topic Discovery) mechanism (default: false)
   --netrestrict value                                                                 Restricts network communication to the given IP networks (CIDR masks)
   --nodekey value                                                                     P2P node key file
   --nodekeyhex value                                                                  P2P node key as hex (for testing)
   --discovery.dns value                                                               Sets DNS discovery entry points (use "" to disable DNS)
   --bootnodes value                                                                   Comma separated enode URLs for P2P discovery bootstrap
   --staticpeers value                                                                 Comma separated enode URLs to connect to
   --trustedpeers value                                                                Comma separated enode URLs which are always allowed to connect, even above the peer limit
   --maxpeers value                                                                    Maximum number of network peers (network disabled if set to 0) (default: 32)
   --chain value                                                                       name of the network to join (default: "mainnet")
   --dev.period value                                                                  Block period to use in developer mode (0 = mine only if transaction pending) (default: 0)
   --vmdebug                                                                           Record information useful for VM and contract debugging (default: false)
   --networkid value                                                                   Explicitly set network id (integer)(For testnets: use --chain &lt;testnet_name&gt; instead) (default: 1)
   --persist.receipts, --experiment.persist.receipts.v2                                Download historical Receipts. If disabled: using state-history to re-exec transactions and generate Receipts - all RPC: eth_getLogs, eth_getBlockReceipts will work (just higher latency) (default: true)
   --fakepow                                                                           Disables proof-of-work verification (default: false)
   --gpo.blocks value                                                                  Number of recent blocks to check for gas prices (default: 20)
   --gpo.percentile value                                                              Suggested gas price is the given percentile of a set of recent transaction gas prices (default: 60)
   --allow-insecure-unlock                                                             Allow insecure account unlocking when account-related RPCs are exposed by http (default: false)
   --identity value                                                                    Custom node name
   --clique.checkpoint value                                                           Number of blocks after which to save the vote snapshot to the database (default: 10)
   --clique.snapshots value                                                            Number of recent vote snapshots to keep in memory (default: 1024)
   --clique.signatures value                                                           Number of recent block signatures to keep in memory (default: 16384)
   --clique.datadir value                                                              Path to clique db folder
   --mine                                                                              Enable mining (default: false)
   --proposer.disable                                                                  Disables PoS proposer (default: false)
   --miner.notify value                                                                Comma separated HTTP URL list to notify of new work packages
   --miner.gaslimit value                                                              Target gas limit for mined blocks (default: 0)
   --miner.etherbase value                                                             Public address for block mining rewards (default: "0")
   --miner.gasprice value                                                              Minimum gas price for mining a transaction (default: 0)
   --miner.extradata value                                                             Block extra data set by the miner (default = client version)
   --miner.noverify                                                                    Disable remote sealing verification (default: false)
   --miner.sigfile value                                                               Private key to sign blocks with
   --miner.recommit value                                                              Time interval to recreate the block being mined (default: 3s)
   --sentry.api.addr value                                                             Comma separated sentry addresses '&lt;host&gt;:&lt;port&gt;,&lt;host&gt;:&lt;port&gt;'
   --sentry.log-peer-info                                                              Log detailed peer info when a peer connects or disconnects. Enable to integrate with observer. (default: false)
   --downloader.api.addr value                                                         downloader address '&lt;host&gt;:&lt;port&gt;'
   --downloader.disable.ipv4                                                           Turns off ipv4 for the downloader (default: false)
   --downloader.disable.ipv6                                                           Turns off ipv6 for the downloader (default: false)
   --no-downloader                                                                     Disables downloader component (default: false)
   --downloader.verify                                                                 Verify snapshots on startup. It will not report problems found, but re-download broken pieces. (default: false)
   --healthcheck                                                                       Enable grpc health check (default: false)
   --bor.heimdall value                                                                URL of Heimdall service (default: "http://localhost:1317")
   --webseed value                                                                     Comma-separated URL's, holding metadata about network-support infrastructure (like S3 buckets with snapshots, bootnodes, etc...)
   --bor.withoutheimdall                                                               Run without Heimdall service (for testing purposes) (default: false)
   --bor.period                                                                        Override the bor block period (for testing purposes) (default: false)
   --bor.minblocksize                                                                  Ignore the bor block period and wait for 'blocksize' transactions (for testing purposes) (default: false)
   --aa                                                                                Enable AA transactions (default: false)
   --ethstats value                                                                    Reporting URL of a ethstats service (nodename:secret@host:port)
   --override.osaka value                                                              Manually specify the Osaka fork time, overriding the bundled setting (default: 0)
   --caplin.discovery.addr value                                                       Address for Caplin DISCV5 protocol (default: "0.0.0.0")
   --caplin.discovery.port value                                                       Port for Caplin DISCV5 protocol (default: 4000)
   --caplin.discovery.tcpport value                                                    TCP Port for Caplin DISCV5 protocol (default: 4001)
   --caplin.checkpoint-sync-url value [ --caplin.checkpoint-sync-url value ]           checkpoint sync endpoint
   --caplin.subscribe-all-topics                                                       Subscribe to all gossip topics (default: false)
   --caplin.max-peer-count value                                                       Max number of peers to connect (default: 128)
   --caplin.enable-upnp                                                                Enable NAT porting for Caplin (default: false)
   --caplin.max-inbound-traffic-per-peer value                                         Max inbound traffic per second per peer (default: "1MB")
   --caplin.max-outbound-traffic-per-peer value                                        Max outbound traffic per second per peer (default: "1MB")
   --caplin.adaptable-maximum-traffic-requirements                                     Make the node adaptable to the maximum traffic requirement based on how many validators are being ran (default: true)
   --sentinel.addr value                                                               Address for sentinel (default: "localhost")
   --sentinel.port value                                                               Port for sentinel (default: 7777)
   --sentinel.bootnodes value [ --sentinel.bootnodes value ]                           Comma separated enode URLs for P2P discovery bootstrap
   --sentinel.staticpeers value [ --sentinel.staticpeers value ]                       connect to comma-separated Consensus static peers
   --ots.search.max.pagesize value                                                     Max allowed page size for search methods (default: 25)
   --silkworm.exec                                                                     Enable Silkworm block execution (default: false)
   --silkworm.rpc                                                                      Enable embedded Silkworm RPC service (default: false)
   --silkworm.sentry                                                                   Enable embedded Silkworm Sentry service (default: false)
   --silkworm.verbosity value                                                          Set the log level for Silkworm console logs (default: "info")
   --silkworm.contexts value                                                           Number of I/O contexts used in embedded Silkworm RPC and Sentry services (zero means use default in Silkworm) (default: 0)
   --silkworm.rpc.log                                                                  Enable interface log for embedded Silkworm RPC service (default: false)
   --silkworm.rpc.log.maxsize value                                                    Max interface log file size in MB for embedded Silkworm RPC service (default: 1)
   --silkworm.rpc.log.maxfiles value                                                   Max interface log files for embedded Silkworm RPC service (default: 100)
   --silkworm.rpc.log.response                                                         Dump responses in interface logs for embedded Silkworm RPC service (default: false)
   --silkworm.rpc.workers value                                                        Number of worker threads used in embedded Silkworm RPC service (zero means use default in Silkworm) (default: 0)
   --silkworm.rpc.compatibility                                                        Preserve JSON-RPC compatibility using embedded Silkworm RPC service (default: true)
   --beacon.api value [ --beacon.api value ]                                           Enable beacon API (available endpoints: beacon, builder, config, debug, events, node, validator, lighthouse)
   --beacon.api.addr value                                                             sets the host to listen for beacon api requests (default: "localhost")
   --beacon.api.cors.allow-methods value [ --beacon.api.cors.allow-methods value ]     set the cors' allow methods (default: "GET", "POST", "PUT", "DELETE", "OPTIONS")
   --beacon.api.cors.allow-origins value [ --beacon.api.cors.allow-origins value ]     set the cors' allow origins
   --beacon.api.cors.allow-credentials                                                 set the cors' allow credentials (default: false)
   --beacon.api.port value                                                             sets the port to listen for beacon api requests (default: 5555)
   --beacon.api.read.timeout value                                                     Sets the seconds for a read time out in the beacon api (default: 5)
   --beacon.api.write.timeout value                                                    Sets the seconds for a write time out in the beacon api (default: 31536000)
   --beacon.api.protocol value                                                         Protocol for beacon API (default: "tcp")
   --beacon.api.ide.timeout value                                                      Sets the seconds for a write time out in the beacon api (default: 25)
   --caplin.blocks-archive                                                             sets whether backfilling is enabled for caplin (default: false)
   --caplin.blobs-archive                                                              sets whether backfilling is enabled for caplin (default: false)
   --caplin.states-archive                                                             enables archival node for historical states in caplin (it will enable block archival as well) (default: false)
   --caplin.blobs-immediate-backfill                                                   sets whether caplin should immediatelly backfill blobs (4096 epochs) (default: false)
   --caplin.blobs-no-pruning                                                           disable blob pruning in caplin (default: false)
   --caplin.checkpoint-sync.disable                                                    disable checkpoint sync in caplin (default: false)
   --caplin.snapgen                                                                    enables snapshot generation in caplin (default: false)
   --caplin.mev-relay-url value                                                        MEV relay endpoint. Caplin runs in builder mode if this is set
   --caplin.validator-monitor                                                          Enable caplin validator monitoring metrics (default: false)
   --caplin.custom-config value                                                        set the custom config for caplin
   --caplin.custom-genesis value                                                       set the custom genesis for caplin
   --caplin.use-engine-api                                                             Use engine API for internal Caplin. useful for testing and if CL network is degraded (default: false)
   --trusted-setup-file value                                                          Absolute path to trusted_setup.json file
   --rpc.slow value                                                                    Print in logs RPC requests slower than given threshold: 100ms, 1s, 1m. Exluded methods: eth_getBlock,eth_getBlockByNumber,eth_getBlockByHash,eth_blockNumber,erigon_blockNumber,erigon_getHeaderByNumber,erigon_getHeaderByHash,erigon_getBlockByTimestamp,eth_call (default: 0s)
   --txpool.gossip.disable                                                             Disabling p2p gossip of txs. Any txs received by p2p - will be dropped. Some networks like 'Optimism execution engine'/'Optimistic Rollup' - using it to protect against MEV attacks (default: false)
   --sync.loop.block.limit value                                                       Sets the maximum number of blocks to process per loop iteration (default: 5000)
   --sync.loop.break.after value                                                       Sets the last stage of the sync loop to run
   --sync.parallel-state-flushing                                                      Enables parallel state flushing (default: true)
   --chaos.monkey                                                                      Enable 'chaos monkey' to generate spontaneous network/consensus/etc failures. Use ONLY for testing (default: false)
   --shutter                                                                           Enable the Shutter encrypted transactions mempool (defaults to false) (default: false)
   --shutter.p2p.bootstrap.nodes value [ --shutter.p2p.bootstrap.nodes value ]         Use to override the default p2p bootstrap nodes (defaults to using the values in the embedded config)
   --shutter.p2p.listen.port value                                                     Use to override the default p2p listen port (defaults to 23102) (default: 0)
   --polygon.pos.ssf                                                                   Enabling Polygon PoS Single Slot Finality (default: false)
   --polygon.pos.ssf.block value                                                       Enabling Polygon PoS Single Slot Finality since block (default: 0)
   --gdbme                                                                             restart erigon under gdb for debug purposes (default: false)
   --experimental.concurrent-commitment                                                EXPERIMENTAL: enables concurrent trie for commitment (default: false)
   --pprof                                                                             Enable the pprof HTTP server (default: false)
   --pprof.addr value                                                                  pprof HTTP server listening interface (default: "127.0.0.1")
   --pprof.port value                                                                  pprof HTTP server listening port (default: 6060)
   --pprof.cpuprofile value                                                            Write CPU profile to the given file
   --trace value                                                                       Write execution trace to the given file
   --vmtrace value                                                                     Set the provider tracer
   --vmtrace.jsonconfig value                                                          Set the config of the tracer
   --metrics                                                                           Enable metrics collection and reporting (default: false)
   --metrics.addr value                                                                Enable stand-alone metrics HTTP server listening interface (default: "127.0.0.1")
   --metrics.port value                                                                Metrics HTTP server listening port (default: 6061)
   --diagnostics.disabled                                                              Disable diagnostics (default: true)
   --diagnostics.endpoint.addr value                                                   Diagnostics HTTP server listening interface (default: "127.0.0.1")
   --diagnostics.endpoint.port value                                                   Diagnostics HTTP server listening port (default: 6062)
   --diagnostics.speedtest                                                             Enable speed test (default: false)
   --log.json                                                                          Format console logs with JSON (default: false)
   --log.console.json                                                                  Format console logs with JSON (default: false)
   --log.dir.json                                                                      Format file logs with JSON (default: false)
   --verbosity value                                                                   Set the log level for console logs (default: "info")
   --log.console.verbosity value                                                       Set the log level for console logs (default: "info")
   --log.dir.disable                                                                   disable disk logging (default: false)
   --log.dir.path value                                                                Path to store user and error logs to disk
   --log.dir.prefix value                                                              The file name prefix for logs stored to disk
   --log.dir.verbosity value                                                           Set the log verbosity for logs stored to disk (default: "info")
   --log.delays                                                                        Enable block delay logging (default: false)
   --config value                                                                      Sets erigon flags from YAML/TOML file
   --help, -h                                                                          show help
   --version, -v                                                                       print the version
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="supported-networks"><a class="header" href="#supported-networks">Supported Networks</a></h1>
<p>The default flag is <code>--chain=mainnet</code>, which enables Erigon 3 to operate on the Ethereum mainnet.
Utilize the flag <code>--chain=&lt;tag&gt;</code> to synchronize with one of the supported networks. For example, to synchronize Holesky, one of the Ethereum testnets, use:</p>
<pre><code class="language-bash">./build/bin/erigon --chain=holesky
</code></pre>
<h1 id="mainnets"><a class="header" href="#mainnets">Mainnets</a></h1>
<div class="table-wrapper"><table><thead><tr><th>Chain</th><th>Tag</th><th>ChainId</th></tr></thead><tbody>
<tr><td>Ethereum</td><td>mainnet</td><td>1</td></tr>
<tr><td>Polygon</td><td>bor-mainnet</td><td>137</td></tr>
<tr><td>Gnosis</td><td>gnosis</td><td>100</td></tr>
</tbody></table>
</div>
<h1 id="testnets-1"><a class="header" href="#testnets-1">Testnets</a></h1>
<h2 id="ethereum-testnets"><a class="header" href="#ethereum-testnets">Ethereum testnets</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Chain</th><th>Tag</th><th>ChainId</th></tr></thead><tbody>
<tr><td>Holesky</td><td>holesky</td><td>17000</td></tr>
<tr><td>Sepolia</td><td>sepolia</td><td>11155111</td></tr>
<tr><td>Hoodi</td><td>hoodi</td><td>560048</td></tr>
</tbody></table>
</div>
<h2 id="polygon-testnets"><a class="header" href="#polygon-testnets">Polygon testnets</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Chain</th><th>Tag</th><th>ChainId</th></tr></thead><tbody>
<tr><td>Amoy</td><td>amoy</td><td>80002</td></tr>
</tbody></table>
</div>
<h2 id="gnosis-chain-testnets"><a class="header" href="#gnosis-chain-testnets">Gnosis Chain Testnets</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Chain</th><th>Tag</th><th>ChainId</th></tr></thead><tbody>
<tr><td>Chiado</td><td>chiado</td><td>10200</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="layer-2-networks"><a class="header" href="#layer-2-networks">Layer 2 Networks</a></h1>
<h2 id="running-an-op-node-alongside-erigon"><a class="header" href="#running-an-op-node-alongside-erigon">Running an Op-Node alongside Erigon</a></h2>
<p>To run an op-node alongside Erigon, follow these steps:</p>
<ol>
<li><strong>Start Erigon with Caplin Enabled</strong>:
If Caplin is running as the consensus layer (CL), use the <code>--caplin.blobs-immediate-backfill</code> flag to ensure the last 18 days of blobs are backfilled, which is critical for proper synchronization with the op-node, assuming you start from a snapshot.
<pre><code class="language-bash">./build/bin/erigon --caplin.blobs-immediate-backfill
</code></pre>
</li>
<li><strong>Run the Op-Node</strong>:
Configure the op-node with the <code>--l1.trustrpc</code> flag to trust the Erigon RPC layer as the L1 node. This setup ensures smooth communication and synchronization.</li>
</ol>
<p>This configuration enables the op-node to function effectively with Erigon serving as both the L1 node and the CL.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="default-ports-and-firewalls"><a class="header" href="#default-ports-and-firewalls">Default Ports and Firewalls</a></h1>
<p>Erigon use the following default port for each service:</p>
<div class="table-wrapper"><table><thead><tr><th>Component</th><th>Port</th><th>Protocol</th><th>Purpose</th><th>Should Expose</th></tr></thead><tbody>
<tr><td>engine</td><td><code>9090</code></td><td>TCP</td><td>gRPC Server</td><td>Private</td></tr>
<tr><td>engine</td><td><code>42069</code></td><td>TCP &amp; UDP</td><td>Snap sync (Bittorrent)</td><td>Public</td></tr>
<tr><td>engine</td><td><code>8551</code></td><td>TCP</td><td>Engine API (JWT auth)</td><td>Private</td></tr>
<tr><td>sentry</td><td><code>30303</code></td><td>TCP &amp; UDP</td><td>eth/68 peering</td><td>Public</td></tr>
<tr><td>sentry</td><td><code>30304</code></td><td>TCP &amp; UDP</td><td>eth/67 peering</td><td>Public</td></tr>
<tr><td>sentry</td><td><code>9091</code></td><td>TCP</td><td>incoming gRPC Connections</td><td>Private</td></tr>
<tr><td>rpcdaemon</td><td><code>8545</code></td><td>TCP</td><td>HTTP &amp; WebSockets &amp; GraphQL</td><td>Private</td></tr>
<tr><td>shutter</td><td><code>23102</code></td><td>TCP</td><td>Peering</td><td>Public</td></tr>
</tbody></table>
</div>
<p>Typically, <code>30303</code> and <code>30304</code> are exposed to the internet to allow incoming peering connections. <code>9090</code> is exposed only internally for rpcdaemon or other connections, (e.g. rpcdaemon -&gt; erigon). Port <code>8551</code> (JWT authenticated) is exposed only internally for Engine API JSON-RPC queries from the Consensus Layer node.</p>
<p>To ensure proper P2P functionality for both the Execution and Consensus layers use a minimal configuration without exposing unnecessary services:</p>
<ul>
<li>Avoid exposing other ports unless necessary for specific use cases (e.g., JSON-RPC or WebSocket);</li>
<li>Regularly audit your firewall rules to ensure they are aligned with your infrastructure needs;</li>
<li>Use monitoring tools like Prometheus or Grafana to track P2P communication metrics.</li>
</ul>
<h2 id="command-line-switches-for-network-and-port-configuration"><a class="header" href="#command-line-switches-for-network-and-port-configuration">Command-Line Switches for Network and Port Configuration</a></h2>
<p>Here is an extensive list of port-related options from the <a href="fundamentals/../fundamentals/configuring-erigon.html#options">options</a> list:</p>
<h3 id="engine"><a class="header" href="#engine">Engine</a></h3>
<ul>
<li><code>--private.api.addr [value]</code>: Erigon's internal gRPC API, empty string means not to start the listener (default: <code>127.0.0.1:9090</code>)</li>
<li><code>--txpool.api.addr [value]</code>: TxPool api network address, (default: use value of <code>--private.api.addr</code>)</li>
<li><code>--torrent.port [value]</code>: Port to listen and serve BitTorrent protocol (default: <code>42069</code>)</li>
<li><code>--authrpc.port [value]</code>: HTTP-RPC server listening port for the Engine API (default: <code>8551</code>)</li>
</ul>
<h3 id="sentry-1"><a class="header" href="#sentry-1">Sentry</a></h3>
<ul>
<li><code>--port [value]</code>: Network listening port (default: <code>30303</code>)</li>
<li><code>--p2p.allowed-ports [value]</code>: Allowed ports to pick for different eth p2p protocol versions (default: <code>30303</code>, <code>30304</code>, <code>30305</code>, <code>30306</code>, <code>30307</code>)</li>
<li><code>--sentry.api.addr [value]</code>:  Comma separated sentry addresses <code>&lt;host&gt;:&lt;port&gt;,&lt;host&gt;:&lt;port&gt;</code> (default <code>127.0.0.1:9091</code>)</li>
</ul>
<h3 id="rpcdaemon"><a class="header" href="#rpcdaemon">RPCdaemon</a></h3>
<ul>
<li><code>--ws.port [value]</code>: WS-RPC server listening port (default: <code>8546</code>)</li>
<li><code>--http.port [value]</code>: HTTP-RPC server listening port (default: <code>8545</code>)</li>
</ul>
<h3 id="caplin"><a class="header" href="#caplin">Caplin</a></h3>
<ul>
<li><code>--caplin.discovery.port [value]</code>: Port for Caplin DISCV5 protocol (default: <code>4000</code>)</li>
<li><code>--caplin.discovery.tcpport [value]</code>: TCP Port for Caplin DISCV5 protocol (default: <code>4001</code>)</li>
</ul>
<h3 id="beaconapi"><a class="header" href="#beaconapi">BeaconAPI</a></h3>
<ul>
<li><code>--beacon.api.port [value]</code>: Sets the port to listen for beacon api requests (default: <code>5555</code>)</li>
</ul>
<h3 id="diagnostics"><a class="header" href="#diagnostics">Diagnostics</a></h3>
<ul>
<li><code>--diagnostics.endpoint.port [value]</code>: Diagnostics HTTP server listening port (default: <code>6062</code>)</li>
</ul>
<h2 id="shutter-network-default-ports"><a class="header" href="#shutter-network-default-ports">Shutter Network Default Ports</a></h2>
<p>The default peering port for Shutter is <code>23102</code> (TCP), to change it use <code>--shutter.p2p.listen.port &lt;value&gt;</code>.</p>
<p>Bootstrap nodes are used to help new nodes discover other nodes in the network. By default, the embedded configuration values are used, but these can be overridden with <code>--shutter.p2p.bootstrap.nodes &lt;value&gt;</code>.</p>
<h3 id="shared-ports"><a class="header" href="#shared-ports">Shared ports</a></h3>
<ul>
<li><code>--pprof.port [value]</code>: pprof HTTP server listening port (default: <code>6060</code>)</li>
<li><code>--metrics.port [value]</code>: Metrics HTTP server listening port (default: <code>6061</code>)</li>
<li><code>--downloader.api.addr [value]</code>: Downloader address <code>&lt;host&gt;:&lt;port&gt;</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sync-modes"><a class="header" href="#sync-modes">Sync Modes</a></h1>
<p>Erigon 3 introduces a flexible approach to node configuration, offering three distinct types to suit various user needs. Depending on your need, you can choose from three different node types.</p>
<div class="table-wrapper"><table><thead><tr><th>Usage</th><th>Minimal Node</th><th>Full Node</th><th>Archive Node</th></tr></thead><tbody>
<tr><td>Privacy, RPC</td><td><strong>Yes</strong></td><td><strong>Yes</strong></td><td><strong>Yes</strong></td></tr>
<tr><td>Contribute to network</td><td>No</td><td><strong>Yes</strong></td><td><strong>Yes</strong></td></tr>
<tr><td>Research</td><td>No</td><td>No</td><td><strong>Yes</strong></td></tr>
<tr><td>Staking</td><td><strong>Yes</strong></td><td><strong>Yes</strong></td><td><strong>Yes</strong></td></tr>
</tbody></table>
</div>
<p>In order to switch type of node, you must first delete the <code>/chaindata</code> folder in the chosen <code>--datadir</code> directory.</p>
<blockquote>
<p><strong>Persisting receipts</strong>, which are pre-calculated receipts, are enabled by default for minimal and full node. To disable them use the flag <code>--persist.receipts=false</code>.</p>
</blockquote>
<h2 id="minimal-node"><a class="header" href="#minimal-node">Minimal node</a></h2>
<p>Erigon 3 implements support for <a href="https://eips.ethereum.org/EIPS/eip-4444">EIP-4444</a> through its minimal node configuration, enabled by the flag <code>--prune.mode=minimal</code>. For example:</p>
<pre><code class="language-bash">./build/bin/erigon --prune.mode=minimal
</code></pre>
<p>Minimal node is suitable for users with constrained <a href="fundamentals/../getting-started/hardware-requirements.html#minimal-node-requirements">hardware</a> who wants to achieve more <strong>privacy</strong> during their interaction with EVM, like for example sending transactions with your node. Minimal node is also suitable for staking.</p>
<h2 id="full-node"><a class="header" href="#full-node">Full node</a></h2>
<p>Erigon 3 is full node by default (<code>--prune.mode=full</code>). This configuration delivers <strong>faster sync times</strong> and reduced resource consumption for everyday operation, maintaining essential data while <strong>reducing storage requirements</strong>. We recommend running a full node whenever possible, as it supports the network's decentralization, resilience, and robustness, aligning with Ethereum's trustless and distributed ethos. Given the reduced <a href="fundamentals/../getting-started/hardware-requirements.html#full-node-requirements">disk space</a> requirements of Erigon 3, the full node configuration is suitable for the majority of users.</p>
<h2 id="archive-node"><a class="header" href="#archive-node">Archive node</a></h2>
<p>Ethereum's state refers to account balances, contracts, and consensus data. Archive nodes retain all historical state and require significantly more <a href="fundamentals/../getting-started/hardware-requirements.html#archive-node-requirements">disk space</a>. They are typically used for block explorers or deep analytical queries. They provide comprehensive historical data, making them optimal for conducting extensive research on the chain, ranging from searching for old states of the EVM to implementing advanced block explorers, such as <a href="fundamentals/../tools/otterscan.html">Otterscan</a>, and undertaking development activities.</p>
<p>Erigon 3 has consistently reduced the disk space requirements for running an archive node, rendering it more affordable and accessible to a broader range of users. To run an archive node use the flag <code>--prune.mode=archive</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="caplin-1"><a class="header" href="#caplin-1">Caplin</a></h1>
<p>Caplin, the novel embedded Consensus Layer, brings unparalleled performance, efficiency, and reliability to Ethereum infrastructure. Its innovative design minimize disk usage, enabling faster transaction processing and a more secure network. By <strong>integrating the consensus layer into the EVM-node</strong>, Caplin eliminates the need for separate disk storage, reducing overall system complexity and improving overall efficiency.</p>
<p><strong>OtterSync</strong>, a new syncing algorithm, further enhances performance by shifting 98% of the computation to network bandwidth, reducing sync times and improving chain tip performance, disk footprint, and decentralization.</p>
<h1 id="caplin-usage"><a class="header" href="#caplin-usage">Caplin Usage</a></h1>
<p>Caplin is enabled by default, at which point an external consensus layer is no longer needed.</p>
<pre><code class="language-bash">./build/bin/erigon
</code></pre>
<p>Caplin also has an archive mode for historical states, blocks, and blobs. These can be enabled with the following flags:</p>
<ul>
<li><code>--caplin.states-archive</code>: Enables the storage and retrieval of historical state data, allowing access to past states of the blockchain for debugging, analytics, or other use cases.</li>
<li><code>--caplin.blocks-archive</code>: Enables the storage of historical block data, making it possible to query or analyze full block history.</li>
<li><code>--caplin.blobs-archive</code>: Enables the storage of historical blobs, ensuring access to additional off-chain data that might be required for specific applications.</li>
</ul>
<p>In addition, Caplin can backfill recent blobs for an op-node or other uses with the new flag:</p>
<ul>
<li><code>--caplin.blobs-immediate-backfill</code>: Backfills the last 18 days' worth of blobs to quickly populate historical blob data for operational needs or analytics.</li>
</ul>
<p>Caplin can also be used for <a href="fundamentals//staking/caplin.html">block production</a>, aka <strong>staking</strong>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="optimizing-storage"><a class="header" href="#optimizing-storage">Optimizing Storage</a></h1>
<p><em>Using fast disks and cheap disks</em></p>
<p>For optimal performance, it's recommended to store the datadir on a fast NVMe-RAID disk. However, if this is not feasible, you can store the history on a cheaper disk and still achieve good performance.</p>
<h2 id="step-1-store-datadir-on-the-slow-disk"><a class="header" href="#step-1-store-datadir-on-the-slow-disk">Step 1: Store datadir on the slow disk</a></h2>
<p>Place the <code>datadir</code> on the slower disk. Then, create symbolic links (using <code>ln -s</code>) to the <strong>fast disk</strong> for the following sub-folders:</p>
<ul>
<li><code>chaindata</code></li>
<li><code>snapshots/domain</code></li>
</ul>
<p>This will speed up the execution of E3.</p>
<p>On the <strong>slow disk</strong> place <code>datadir</code> folder with the following structure:</p>
<ul>
<li><code>chaindata</code> (linked to fast disk)</li>
<li><code>snapshots</code>
<ul>
<li><code>domain</code> (linked to fast disk)</li>
<li><code>history</code></li>
<li><code>idx</code></li>
<li><code>accessor</code></li>
</ul>
</li>
<li><code>temp</code></li>
</ul>
<h2 id="step-2-speed-up-history-access-optional"><a class="header" href="#step-2-speed-up-history-access-optional">Step 2: Speed Up History Access (Optional)</a></h2>
<p>If you need to further improve performance try the following improvements step by step:</p>
<ol>
<li>Store the <code>snapshots/accessor</code> folder on the fast disk. This should provide a noticeable speed boost.</li>
<li>If the speed is still not satisfactory, move the <code>snapshots/idx</code> folder to the fast disk.</li>
<li>If performance is still an issue, consider moving the entire <code>snapshots/history</code> folder to the fast disk.</li>
</ol>
<p>By following these steps, you can optimize your Erigon 3 storage setup to achieve a good balance between performance and cost.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="logs"><a class="header" href="#logs">Logs</a></h1>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>Erigon utilizes a sophisticated logging framework to provide detailed visibility into the synchronization process and operational status. This document provides an exhaustive analysis of the logging messages generated during blockchain synchronization and normal operation.</p>
<h2 id="logging-framework-architecture"><a class="header" href="#logging-framework-architecture">Logging Framework Architecture</a></h2>
<h3 id="core-logging-system"><a class="header" href="#core-logging-system">Core Logging System</a></h3>
<p>Erigon implements a custom logging framework that supports structured logging with key-value pairs and multiple output handlers.</p>
<h3 id="configuration-options"><a class="header" href="#configuration-options">Configuration Options</a></h3>
<p>Erigon provides extensive logging configuration through command-line flags. Key configuration options include:</p>
<ul>
<li><code>--log.json</code>: Enable JSON formatting for console logs</li>
<li><code>--verbosity</code>: Set console log level (default: <code>2</code>)</li>
<li><code>--log.dir.path</code>: Specify directory for log files</li>
<li><code>--log.dir.verbosity</code>: Set file log level</li>
<li><code>--log.delays</code>: Enable block delay logging</li>
</ul>
<p><strong>Log Levels</strong></p>
<p>The logging system defines six distinct log levels in hierarchical order:</p>
<ul>
<li><strong>LvlCrit (0)</strong>: Critical errors that may cause application termination</li>
<li><strong>LvlError (1)</strong>: Error conditions that require attention</li>
<li><strong>LvlWarn (2)</strong>: Warning messages for potentially problematic situations</li>
<li><strong>LvlInfo (3)</strong>: General informational messages</li>
<li><strong>LvlDebug (4)</strong>: Detailed debugging information</li>
<li><strong>LvlTrace (5)</strong>: Most verbose tracing information</li>
</ul>
<p>The log level is set by using the <code>--verbosity</code> flag, for example:</p>
<pre><code>./build/bin/erigon --verbosity=1
</code></pre>
<p><strong>Logger Interface</strong></p>
<p>The core Logger interface provides methods for each log level and supports contextual logging.</p>
<h2 id="staged-synchronization-architecture"><a class="header" href="#staged-synchronization-architecture">Staged Synchronization Architecture</a></h2>
<h3 id="stage-definitions"><a class="header" href="#stage-definitions">Stage Definitions</a></h3>
<p>Erigon's synchronization process is organized into sequential stages, each handling specific aspects of blockchain data processing.</p>
<p>The primary synchronization stages include:</p>
<ul>
<li><strong>Snapshots (OtterSync)</strong>: Download and process blockchain snapshots</li>
<li><strong>Headers</strong>: Download and validate block headers</li>
<li><strong>BlockHashes</strong>: Generate block number to hash mappings</li>
<li><strong>Bodies</strong>: Download and validate block bodies</li>
<li><strong>Senders</strong>: Recover transaction senders from signatures</li>
<li><strong>Execution</strong>: Execute transactions and update state</li>
<li><strong>CustomTrace</strong>: Generate custom execution traces</li>
<li><strong>Translation</strong>: Translate smart contracts (EVM to TEVM)</li>
<li><strong>WitnessProcessing</strong>: Process witness data for Polygon chains</li>
<li><strong>TxLookup</strong>: Generate transaction lookup indices</li>
<li><strong>Finish</strong>: Finalization stage</li>
</ul>
<h3 id="stage-progress-tracking"><a class="header" href="#stage-progress-tracking">Stage Progress Tracking</a></h3>
<p>Each stage maintains progress information in the database, allowing for resumable synchronization.</p>
<h2 id="synchronization-logging-messages"><a class="header" href="#synchronization-logging-messages">Synchronization Logging Messages</a></h2>
<h3 id="main-sync-loop-logging"><a class="header" href="#main-sync-loop-logging">Main Sync Loop Logging</a></h3>
<p>The core synchronization engine provides detailed logging about stage execution and timing.</p>
<p><strong>Stage Execution Messages:</strong></p>
<ul>
<li>Stage start: Debug-level message indicating stage commencement</li>
<li>Stage completion: Info-level message for stages taking over 60 seconds, Debug-level for shorter stages</li>
<li>Stage timing: Detailed execution duration tracking</li>
</ul>
<p><strong>Unwind Operations:</strong>
The sync engine logs unwind operations when blockchain reorganizations occur.</p>
<h3 id="snapshot-stage-ottersync"><a class="header" href="#snapshot-stage-ottersync">Snapshot Stage (OtterSync)</a></h3>
<p>The snapshot synchronization stage provides distinctive logging with custom branding.</p>
<p><strong>Key Log Messages:</strong></p>
<ul>
<li>Startup announcement with OtterSync branding</li>
<li>Download progress for header-chain snapshots</li>
<li>Snapshot verification and processing status</li>
</ul>
<h3 id="headers-stage"><a class="header" href="#headers-stage">Headers Stage</a></h3>
<p>The Headers stage generates comprehensive logging for block header synchronization.</p>
<p><strong>Common Log Messages:</strong></p>
<ul>
<li>"Waiting for headers..." - Indicates the stage is waiting for peer responses</li>
<li>Header download progress with block ranges</li>
<li>Validation status and error conditions</li>
<li>Consensus layer integration messages</li>
</ul>
<h3 id="bodies-stage"><a class="header" href="#bodies-stage">Bodies Stage</a></h3>
<p>The Bodies stage logs detailed information about block body processing.</p>
<p><strong>Typical Log Messages:</strong></p>
<ul>
<li>"Processing bodies..." - Shows current processing range</li>
<li>Download progress and completion status</li>
<li>Body validation results</li>
<li>Canonical chain marking operations</li>
</ul>
<h3 id="additional-stage-logging-patterns"><a class="header" href="#additional-stage-logging-patterns">Additional Stage Logging Patterns</a></h3>
<p><strong>Execution Stages:</strong>
Each execution-related stage follows similar logging patterns with stage-specific context and progress indicators.</p>
<p><strong>Error Handling:</strong>
All stages implement comprehensive error logging with contextual information to aid in debugging synchronization issues.</p>
<h2 id="operational-logging"><a class="header" href="#operational-logging">Operational Logging</a></h2>
<h3 id="performance-monitoring"><a class="header" href="#performance-monitoring">Performance Monitoring</a></h3>
<p>Erigon provides detailed performance logging through timing measurements.</p>
<p><strong>Timing Reports:</strong></p>
<ul>
<li>Individual stage execution times</li>
<li>Overall synchronization cycle duration</li>
<li>Performance metrics for monitoring and optimization</li>
</ul>
<h3 id="debug-and-development-support"><a class="header" href="#debug-and-development-support">Debug and Development Support</a></h3>
<p>The logging system includes extensive debugging capabilities:</p>
<ul>
<li>Environment-based stage stopping for development</li>
<li>Stack traces for unwind operations</li>
<li>Detailed context preservation across stage transitions</li>
</ul>
<h2 id="log-message-structure"><a class="header" href="#log-message-structure">Log Message Structure</a></h2>
<h3 id="structured-logging-format"><a class="header" href="#structured-logging-format">Structured Logging Format</a></h3>
<p>All log messages follow a consistent structured format with key-value pairs for machine parsing and human readability.</p>
<p><strong>Standard Fields:</strong></p>
<ul>
<li>Timestamp (t)</li>
<li>Log level (lvl)</li>
<li>Message (msg)</li>
<li>Contextual key-value pairs</li>
</ul>
<h3 id="prefix-system"><a class="header" href="#prefix-system">Prefix System</a></h3>
<p>The sync engine uses a sophisticated prefix system to identify stage context.</p>
<p>The prefix format includes stage position and total count (e.g., "1/10 Headers") for easy identification of sync progress.</p>
<h2 id="diagnostic-integration"><a class="header" href="#diagnostic-integration">Diagnostic Integration</a></h2>
<p>Erigon integrates with a diagnostic system that provides additional telemetry and monitoring capabilities beyond standard logging, allowing for real-time sync status monitoring and performance analysis.</p>
<h2 id="notes"><a class="header" href="#notes">Notes</a></h2>
<p>This logging system is designed to provide comprehensive visibility into Erigon's complex synchronization process while maintaining performance. The structured nature of the logs makes them suitable for both human operators and automated monitoring systems. The staged approach allows for granular control over logging verbosity and enables precise debugging of synchronization issues.</p>
<p>The logging framework's flexibility supports various deployment scenarios, from development environments requiring verbose debugging output to production systems optimized for performance monitoring and alerting.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="security"><a class="header" href="#security">Security</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tls-authentication"><a class="header" href="#tls-authentication">TLS Authentication</a></h1>
<h2 id="introduction-1"><a class="header" href="#introduction-1">Introduction</a></h2>
<p>TLS authentication can be enabled to ensure communication integrity and access control to the Erigon node.</p>
<p>At a high level, the process consists of:</p>
<ol>
<li><a href="fundamentals/tls-authentication.html#1-generating-the-key-pair-for-the-certificate-authority-ca">Generate the Certificate Authority (CA) key pair</a></li>
<li><a href="fundamentals/tls-authentication.html#2-creating-the-ca-certificate-file">Create the Certificate Authority certificate file</a></li>
<li><a href="fundamentals/tls-authentication.html#3-generating-a-key-pair">Generate a key pair</a></li>
<li><a href="fundamentals/tls-authentication.html#4-creating-the-certificate-file-for-each-public-key">Create the certificate file for each public key</a></li>
<li><a href="fundamentals/tls-authentication.html#5-deploy-the-files-on-each-instance">Deploy the files to each instance</a></li>
<li><a href="fundamentals/tls-authentication.html#6-run-erigon-and-rpcdaemon-with-the-correct-tags">Run Erigon and RPCdaemon with the correct tags</a></li>
</ol>
<p>The following is a detailed description of how to use the <strong>OpenSSL</strong> suite of tools to secure the connection between a remote Erigon node and a remote or local RPCdaemon. The same procedure applies to any Erigon component you wish to run separately; it is recommended to name the files accordingly.</p>
<blockquote>
<p>⚠️<strong>Warning</strong>: To maintain a high level of security, it is recommended to create all the keys locally and then copy the 3 required files remotely to the remote node.</p>
</blockquote>
<h3 id="prerequisites-4"><a class="header" href="#prerequisites-4">Prerequisites</a></h3>
<p>Make sure you have <a href="https://openssl-library.org/source/">openssl</a> installed.</p>
<h3 id="notes-1"><a class="header" href="#notes-1">Notes</a></h3>
<p>Normally, the "client side" (in our case, the RPCdaemon) will check that the server's host name matches the "Common Name" attribute of the "server" certificate. At this time, this check is disabled and will be re-enabled when the instructions above on how to correctly generate Common Name certificates are updated. For example, if you are running the Erigon instance in the Google Cloud, you will need to specify the internal IP in the <code>-private.api.addr</code> option. You will also need to open the firewall on the port you use to connect to the Erigon instances.</p>
<h2 id="1-generating-the-key-pair-for-the-certificate-authority-ca"><a class="header" href="#1-generating-the-key-pair-for-the-certificate-authority-ca">1. Generating the key pair for the Certificate Authority (CA)</a></h2>
<p>Generate the CA key pair using Elliptic Curve (as opposed to RSA). The generated CA key will be in the <code>CA-key.pem</code> file.</p>
<blockquote>
<p>⚠️<strong>Warning</strong>: Access to this file will allow anyone to later add any new instance key pair to the “cluster of trust”, so keep this file safe.</p>
</blockquote>
<pre><code class="language-bash">openssl ecparam -name prime256v1 -genkey -noout -out CA-key.pem
</code></pre>
<h2 id="2-creating-the-ca-certificate-file"><a class="header" href="#2-creating-the-ca-certificate-file">2. Creating the CA certificate file</a></h2>
<p>Create CA self-signed certificate (this command will ask questions, the answers aren’t important for now, but at least the first one needs to be filled in with some data). The file created by this command will be called <code>CA-cert.pem</code>:</p>
<pre><code class="language-bash">openssl req -x509 -new -nodes -key CA-key.pem -sha256 -days 3650 -out CA-cert.pem
</code></pre>
<h2 id="3-generating-a-key-pair"><a class="header" href="#3-generating-a-key-pair">3. Generating a key pair</a></h2>
<p>Generate a key pair for the Erigon node:</p>
<pre><code class="language-bash">openssl ecparam -name prime256v1 -genkey -noout -out erigon-key.pem
</code></pre>
<p>Also generate a key pair for the RPC daemon:</p>
<pre><code class="language-bash">openssl ecparam -name prime256v1 -genkey -noout -out RPC-key.pem
</code></pre>
<h2 id="4-creating-the-certificate-file-for-each-public-key"><a class="header" href="#4-creating-the-certificate-file-for-each-public-key">4. Creating the certificate file for each public key</a></h2>
<p>Now create the Certificate Signing Request for the Erigon key pair, and from this request, produce the certificate (signed by the CA) that proves that this key is now part of the “cluster of trust”:</p>
<pre><code class="language-bash">openssl x509 -req -in erigon.csr -CA CA-cert.pem -CAkey CA-key.pem -CAcreateserial -out erigon.crt -days 3650 -sha256
</code></pre>
<p>Then create the certificate signing request for the RPC daemon key pair:</p>
<pre><code class="language-bash">openssl req -new -key RPC-key.pem -out RPC.csr
</code></pre>
<p>From this request, produce the certificate (signed by CA), proving that this key is now part of the “cluster of trust”:</p>
<pre><code class="language-bash">openssl x509 -req -in RPC.csr -CA CA-cert.pem -CAkey CA-key.pem -CAcreateserial -out RPC.crt -days 3650 -sha256
</code></pre>
<h2 id="5-deploy-the-files-on-each-instance"><a class="header" href="#5-deploy-the-files-on-each-instance">5. Deploy the files on each instance</a></h2>
<p>These three files must be placed in the /erigon folder on the machine running Erigon:</p>
<p><code>CA-cert.pem</code></p>
<p><code>erigon-key.pem</code></p>
<p><code>erigon.crt</code></p>
<p>On the RPCdaemon machine, these three files must also be placed in the /erigon folder:</p>
<p><code>CA-cert.pem</code></p>
<p><code>RPC key.pem</code></p>
<p><code>RPC.crtv</code></p>
<h2 id="6-run-erigon-and-rpcdaemon-with-the-correct-tags"><a class="header" href="#6-run-erigon-and-rpcdaemon-with-the-correct-tags">6. Run Erigon and RPCdaemon with the correct tags</a></h2>
<p>Once all the files have been moved, Erigon must be run with these additional options:</p>
<pre><code class="language-bash">--tls --tls.cacert CA-cert.pem --tls.key erigon-key.pem --tls.cert erigon.crt
</code></pre>
<p>While the RPC daemon must be started with these additional options:</p>
<pre><code class="language-bash">--tls.key RPC-key.pem --tls.cacert CA-cert.pem --tls.cert RPC.crt
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="performance-tricks"><a class="header" href="#performance-tricks">Performance Tricks</a></h1>
<p>These instructions are designed to improve the performance of Erigon 3, particularly for synchronization and memory management, on cloud drives and other systems with specific performance characteristics.</p>
<h2 id="increase-sync-speed"><a class="header" href="#increase-sync-speed">Increase Sync Speed</a></h2>
<ul>
<li>Set <code>--sync.loop.block.limit=10_000</code> and <code>--batchSize=2g</code> to speed up the synchronization process.</li>
</ul>
<pre><code class="language-bash">--sync.loop.block.limit=10_000 --batchSize=2g
</code></pre>
<ul>
<li>Increase download speed with flag <code>--torrent.download.rate=[value]</code> setting your max speed (default value is 128MB). For example:</li>
</ul>
<pre><code class="language-bash">--torrent.download.rate=512mb
</code></pre>
<h2 id="optimize-for-cloud-drives"><a class="header" href="#optimize-for-cloud-drives">Optimize for Cloud Drives</a></h2>
<ul>
<li>Set <code>SNAPSHOT_MADV_RND=false</code> to enable the operating system's cache prefetching for better performance on cloud drives with good throughput but bad latency.</li>
</ul>
<pre><code class="language-bash">SNAPSHOT_MADV_RND=false
</code></pre>
<h2 id="lock-latest-state-in-ram"><a class="header" href="#lock-latest-state-in-ram">Lock Latest State in RAM</a></h2>
<ul>
<li>Use <code>vmtouch -vdlw /mnt/erigon/snapshots/domain/*bt</code> to lock the latest state in RAM, preventing it from being evicted due to high historical RPC traffic.</li>
</ul>
<pre><code class="language-bash">vmtouch -vdlw /mnt/erigon/snapshots/domain/*bt
</code></pre>
<ul>
<li>Run <code>ls /mnt/erigon/snapshots/domain/*.kv | parallel vmtouch -vdlw</code> to apply the same locking to all relevant files.</li>
</ul>
<h2 id="handle-memory-allocation-issues"><a class="header" href="#handle-memory-allocation-issues">Handle Memory Allocation Issues</a></h2>
<ul>
<li>If you encounter issues with memory allocation, run the following to flush any pending write operations and free up memory:</li>
</ul>
<pre><code class="language-bash">sync &amp;&amp; sudo sysctl vm.drop_caches=3
</code></pre>
<ul>
<li>Alternatively, set:</li>
</ul>
<pre><code class="language-bash">echo 1 &gt; /proc/sys/vm/compact_memory
</code></pre>
<p>to help with memory allocation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modules"><a class="header" href="#modules">Modules</a></h1>
<p>Erigon is by default an "all-in-one" binary solution, but it's possible start any internal component as a separated processes:</p>
<ul>
<li><a href="fundamentals/modules/rpc-daemon.html">RPCDaemon</a>, the JSON RPC layer. (Most battle-tested external component)</li>
<li><a href="fundamentals/modules/txpool.html">TxPool</a>, the transaction pool</li>
<li><a href="fundamentals/modules/sentry.html">Sentry</a>, the p2p layer</li>
<li><a href="fundamentals/modules/downloader.html">Downloader</a>, the history download layer (we don't recommend run it externally)</li>
<li><a href="fundamentals/modules/fundamentals/caplin.html">Caplin</a>, the novel Consensus Layer</li>
</ul>
<p>This may be for security, scalability, decentralisation, resource limitation, custom implementation, or any other reason you/your team deems appropriate. See the appropriate section to understand how to start each service separately.</p>
<blockquote>
<p>⚠️ <strong>Warning</strong>: Don't start services as separated processes unless you have clear reason for it.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rpc-daemon"><a class="header" href="#rpc-daemon">RPC Daemon</a></h1>
<p><em>Remote Procedure Call</em></p>
<p>The RPC daemon is a crucial component of Erigon, enabling JSON remote procedure calls and providing access to various APIs. It is designed to operate effectively both as an internal or as an external component. For detailed instructions on running it remotely, refer to the documentation <a href="https://github.com/erigontech/erigon/blob/main/cmd/rpcdaemon/README.md#running-remotely">here</a>.</p>
<h2 id="erigon-rpc-method-guidelines"><a class="header" href="#erigon-rpc-method-guidelines">Erigon RPC Method Guidelines</a></h2>
<p>This document provides guidelines for understanding and using the various RPC methods available in Erigon.</p>
<ol>
<li>
<p><strong>Compatibility with <code>eth</code> namespace</strong></p>
<ul>
<li>Erigon aims to be compatible with all standard Ethereum JSON-RPC API methods, as described <a href="https://ethereum.org/en/developers/docs/apis/json-rpc/">here</a>. See also <a href="https://github.com/erigontech/erigon/blob/main/docs/readthedocs/source/rpc/index.rst">here</a> for examples.</li>
</ul>
</li>
<li>
<p><strong>Compatibility with standard Geth methods</strong></p>
<ul>
<li>All methods featured by Geth including <a href="https://geth.ethereum.org/docs/interacting-with-geth/rpc#websockets-server">WebSocket Server</a>, <a href="https://geth.ethereum.org/docs/interacting-with-geth/rpc#ipc-server">IPC Server</a>, TLS, <a href="https://geth.ethereum.org/docs/interacting-with-geth/rpc/graphql">GraphQL</a>, etc..., are supported by Erigon.</li>
</ul>
</li>
<li>
<p><strong>Otterscan Methods (<code>ots_</code>)</strong></p>
<ul>
<li>In addition to the standard Geth methods, Erigon includes RPC methods prefixed with <code>ots_</code> for <strong>Otterscan</strong>. These are specific to the Otterscan functionality integrated with Erigon. See more details <a href="https://docs.otterscan.io/api-docs/ots-api">here</a>.</li>
</ul>
</li>
<li>
<p><strong>Erigon Extensions (<code>erigon_</code>)</strong></p>
<ul>
<li>Erigon introduces some small extensions to the Geth API, denoted by the <code>erigon_</code> prefix aimed to enhance the functionality, see more details <a href="https://github.com/erigontech/erigon/blob/main/cmd/rpcdaemon/README.md#rpc-implementation-status">here</a> about implementation status.</li>
</ul>
</li>
<li>
<p><strong>gRPC API</strong></p>
<ul>
<li>Erigon also exposes a <strong>gRPC</strong> API for lower-level data access. This is primarily used by Erigon’s components when they are deployed separately as independent processes (either on the same or different servers).</li>
<li>This gRPC API is also accessible to users. For more information, visit the <a href="https://github.com/erigontech/interfaces">Erigon Interfaces GitHub repository</a>.</li>
</ul>
</li>
<li>
<p><strong>Trace Module (<code>trace_</code>)</strong></p>
<ul>
<li>Erigon includes <strong><a href="fundamentals/modules/JSONRPC-trace-module.html">the <code>trace_</code> module</a></strong>, which originates from OpenEthereum. This module provides additional functionality related to tracing transactions and state changes, which is valuable for advanced debugging and analysis.</li>
</ul>
</li>
</ol>
<h2 id="more-info"><a class="header" href="#more-info">More info</a></h2>
<p>For a comprehensive understanding of the RPC daemon's functionality, configuration, and usage, please refer to <a href="https://github.com/erigontech/erigon/blob/main/cmd/rpcdaemon/README.md">https://github.com/erigontech/erigon/blob/main/cmd/rpcdaemon/README.md</a> (also contained in your locally compiled Erigon folder at <code>/cmd/rpcdaemon</code>) which covers the following key topics:</p>
<ol>
<li><strong>Introduction</strong>: An overview of the RPC daemon, its benefits, and how it integrates with Erigon.</li>
<li><strong>Getting Started</strong>: Step-by-step guides for running the RPC daemon locally and remotely, including configuration options and command-line flags.</li>
<li><strong>Healthcheck</strong>: Information on performing health checks using POST requests or GET requests with custom headers.</li>
<li><strong>Testing and debugging</strong>: Examples of testing the RPC daemon using <code>curl</code> commands and Postman, debugging.</li>
<li><strong>FAQ</strong>: Frequently asked questions and answers covering topics such as prune options, RPC implementation status, and securing communication between the RPC daemon and Erigon instance.</li>
<li><strong>For Developers</strong>: Resources for developers, including code generation and information on working with the RPC daemon.</li>
<li><strong>Relations between prune options and RPC methods</strong>: Explains how prune options affect RPC methods.</li>
<li><strong>RPC Implementation Status</strong>: Provides a table showing the current implementation status of Erigon's RPC daemon.</li>
<li><strong>Securing the communication between RPC daemon and Erigon instance via TLS and authentication</strong>: Outlines the steps to secure communication between the RPC daemon and Erigon instance.</li>
<li><strong>Ethstats</strong>: Describes how to run ethstats with the RPC daemon.</li>
<li><strong>Allowing only specific methods (Allowlist)</strong>: Explains how to restrict access to specific RPC methods.</li>
</ol>
<h2 id="command-line-options-1"><a class="header" href="#command-line-options-1">Command Line Options</a></h2>
<p>To display available options for RPCdaemon digit:</p>
<pre><code class="language-bash">./build/bin/rpcdaemon --help
</code></pre>
<p>The <code>--help</code> flag listing is reproduced below for your convenience.</p>
<pre><code>rpcdaemon is JSON RPC server that connects to Erigon node for remote DB access

Usage:
  rpcdaemon [flags]

Flags:
      --datadir string                              path to Erigon working directory
      --db.read.concurrency int                     Does limit amount of parallel db reads. Default: equal to GOMAXPROCS (or number of CPU) (default 1408)
      --diagnostics.disabled                        Disable diagnostics
      --diagnostics.endpoint.addr string            Diagnostics HTTP server listening interface (default "127.0.0.1")
      --diagnostics.endpoint.port uint              Diagnostics HTTP server listening port (default 6062)
      --diagnostics.speedtest                       Enable speed test
      --graphql                                     enables graphql endpoint (disabled by default)
      --grpc                                        Enable GRPC server
      --grpc.addr string                            GRPC server listening interface (default "localhost")
      --grpc.healthcheck                            Enable GRPC health check
      --grpc.port int                               GRPC server listening port (default 8547)
  -h, --help                                        help for rpcdaemon
      --http.addr string                            HTTP server listening interface (default "localhost")
      --http.api strings                            API's offered over the RPC interface: eth,erigon,web3,net,debug,trace,txpool,db. Supported methods: https://github.com/erigontech/erigon/tree/main/cmd/rpcdaemon (default [eth,erigon])
      --http.compression                            Disable http compression (default true)
      --http.corsdomain strings                     Comma separated list of domains from which to accept cross origin requests (browser enforced)
      --http.dbg.single                             Allow pass HTTP header 'dbg: true' to printt more detailed logs - how this request was executed
      --http.enabled                                enable http server (default true)
      --http.port int                               HTTP server listening port (default 8545)
      --http.timeouts.idle duration                 Maximum amount of time to wait for the next request when keep-alives are enabled. If http.timeouts.idle is zero, the value of http.timeouts.read is used (default 2m0s)
      --http.timeouts.read duration                 Maximum duration for reading the entire request, including the body. (default 30s)
      --http.timeouts.write duration                Maximum duration before timing out writes of the response. It is reset whenever a new request's header is read (default 30m0s)
      --http.trace                                  Trace HTTP requests with INFO level
      --http.url string                             HTTP server listening url. will OVERRIDE http.addr and http.port. will NOT respect http paths. prefix supported are tcp, unix
      --http.vhosts strings                         Comma separated list of virtual hostnames from which to accept requests (server enforced). Accepts '*' wildcard. (default [localhost])
      --https.addr string                           rpc HTTPS server listening interface (default "localhost")
      --https.cert string                           certificate for rpc HTTPS server
      --https.enabled                               enable http server
      --https.key string                            key file for rpc HTTPS server
      --https.port int                              rpc HTTPS server listening port. default to http+363 if not set
      --https.url string                            rpc HTTPS server listening url. will OVERRIDE https.addr and https.port. will NOT respect paths. prefix supported are tcp, unix
      --log.console.json                            Format console logs with JSON
      --log.console.verbosity string                Set the log level for console logs (default "info")
      --log.delays                                  Enable block delay logging
      --log.dir.disable                             disable disk logging
      --log.dir.json                                Format file logs with JSON
      --log.dir.path string                         Path to store user and error logs to disk
      --log.dir.prefix string                       The file name prefix for logs stored to disk
      --log.dir.verbosity string                    Set the log verbosity for logs stored to disk (default "info")
      --log.json                                    Format console logs with JSON
      --metrics                                     Enable metrics collection and reporting
      --metrics.addr string                         Enable stand-alone metrics HTTP server listening interface (default "127.0.0.1")
      --metrics.port int                            Metrics HTTP server listening port (default 6061)
      --ots.search.max.pagesize uint                Max allowed page size for search methods (default 25)
      --polygon.sync                                Enable if Erigon has been synced using the new polygon sync component
      --pprof                                       Enable the pprof HTTP server
      --pprof.addr string                           pprof HTTP server listening interface (default "127.0.0.1")
      --pprof.cpuprofile string                     Write CPU profile to the given file
      --pprof.port int                              pprof HTTP server listening port (default 6060)
      --private.api.addr string                     Erigon's components (txpool, rpcdaemon, sentry, downloader, ...) can be deployed as independent Processes on same/another server. Then components will connect to erigon by this internal grpc API. Example: 127.0.0.1:9090 (default "127.0.0.1:9090")
      --rpc.accessList string                       Specify granular (method-by-method) API allowlist
      --rpc.allow-unprotected-txs                   Allow for unprotected (non-EIP155 signed) transactions to be submitted via RPC
      --rpc.batch.concurrency uint                  Does limit amount of goroutines to process 1 batch request. Means 1 bach request can't overload server. 1 batch still can have unlimited amount of request (default 2)
      --rpc.batch.limit int                         Maximum number of requests in a batch (default 100)
      --rpc.evmtimeout duration                     Maximum amount of time to wait for the answer from EVM call. (default 5m0s)
      --rpc.gascap uint                             Sets a cap on gas that can be used in eth_call/estimateGas (default 50000000)
      --rpc.maxgetproofrewindblockcount.limit int   Max GetProof rewind block count (default 100000)
      --rpc.overlay.getlogstimeout duration         Maximum amount of time to wait for the answer from the overlay_getLogs call. (default 5m0s)
      --rpc.overlay.replayblocktimeout duration     Maximum amount of time to wait for the answer to replay a single block when called from an overlay_getLogs call. (default 10s)
      --rpc.returndata.limit int                    Maximum number of bytes returned from eth_call or similar invocations (default 100000)
      --rpc.slow duration                           Print in logs RPC requests slower than given threshold: 100ms, 1s, 1m. Excluded methods: eth_getBlock,eth_getBlockByNumber,eth_getBlockByHash,eth_blockNumber,erigon_blockNumber,erigon_getHeaderByNumber,erigon_getHeaderByHash,erigon_getBlockByTimestamp,eth_call
      --rpc.streaming.disable                       Erigon has enabled json streaming for some heavy endpoints (like trace_*). It's a trade-off: greatly reduce amount of RAM (in some cases from 30GB to 30mb), but it produce invalid json format if error happened in the middle of streaming (because json is not streaming-friendly format)
      --rpc.subscription.filters.maxaddresses int   Maximum number of addresses per subscription to filter logs by.
      --rpc.subscription.filters.maxheaders int     Maximum number of block headers to store per subscription.
      --rpc.subscription.filters.maxlogs int        Maximum number of logs to store per subscription.
      --rpc.subscription.filters.maxtopics int      Maximum number of topics per subscription to filter logs by.
      --rpc.subscription.filters.maxtxs int         Maximum number of transactions to store per subscription.
      --rpc.txfeecap float                          Sets a cap on transaction fee (in ether) that can be sent via the RPC APIs (0 = no cap) (default 1)
      --socket.enabled                              Enable IPC server
      --socket.url string                           IPC server listening url. prefix supported are tcp, unix (default "unix:///var/run/erigon.sock")
      --state.cache string                          Amount of data to store in StateCache (enabled if no --datadir set). Set 0 to disable StateCache. Defaults to 0MB RAM (default "0MB")
      --tls.cacert string                           CA certificate for client side TLS handshake for GRPC
      --tls.cert string                             certificate for client side TLS handshake for GRPC
      --tls.key string                              key file for client side TLS handshake for GRPC
      --trace string                                Write execution trace to the given file
      --trace.compat                                Bug for bug compatibility with OE for trace_ routines
      --trace.maxtraces uint                        Sets a limit on traces that can be returned in trace_filter (default 200)
      --txpool.api.addr string                      txpool api network address, for example: 127.0.0.1:9090 (default: use value of --private.api.addr)
      --verbosity string                            Set the log level for console logs (default "info")
      --ws                                          Enable Websockets - Same port as HTTP[S]
      --ws.api.subscribelogs.channelsize int        Size of the channel used for websocket logs subscriptions (default 8192)
      --ws.compression                              Enable Websocket compression (RFC 7692)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="txpool"><a class="header" href="#txpool">Txpool</a></h1>
<p>The transaction pool, also known as the mempool, is a dynamic storage area where pending transactions are held before being confirmed and added to the blockchain. Each node on the Ethereum network maintains its own local transaction pool, which is combined with others to form the global pool.</p>
<p>In Erigon, the txpool is a dedicated API namespace that stores pending and queued transactions in local memory. Its primary function is to manage transactions waiting to be processed by miners.</p>
<p>The TxPool component is typically run as an internal Erigon component, but it can also be operated as a separate process, providing flexibility in transaction management.</p>
<h2 id="txpool-as-an-internal-erigon-component"><a class="header" href="#txpool-as-an-internal-erigon-component">Txpool as an internal Erigon component</a></h2>
<p>Txpool is run as an internal Erigon component by default.</p>
<h2 id="txpool-as-a-separate-process-experimental"><a class="header" href="#txpool-as-a-separate-process-experimental">Txpool as a separate process (experimental)</a></h2>
<p>Running an external txpool can provide a more secure, scalable, and flexible transaction management solution, which can be particularly beneficial in high-performance or high-availability Ethereum node deployments.</p>
<ol>
<li>Before TxPool can be using as a separate process the executable must be built:</li>
</ol>
<pre><code class="language-bash">cd erigon
make txpool
</code></pre>
<ol start="2">
<li>Together with external TxPool also <a href="fundamentals/modules/sentry.html">Sentry</a> and <a href="fundamentals/modules/JSONRPC-daemon.html">RPCDaemon</a> must be compiled and run separately.</li>
</ol>
<pre><code class="language-bash">make sentry
</code></pre>
<pre><code class="language-bash">make rpcdaemon
</code></pre>
<ol start="3">
<li>Now Erigon and other services can be started as separate processes</li>
</ol>
<pre><code class="language-sh">./build/bin/erigon --txpool.disable --private.api.addr=localhost:9090 --datadir=&lt;your datadir&gt; --http=false
</code></pre>
<p>If Erigon is on a different device, add the flags <code>--pprof --pprof.addr 0.0.0.0</code> or TxPool will listen on localhost by default.</p>
<pre><code class="language-sh">./build/bin/sentry --sentry.api.addr=localhost:9091 --datadir=&lt;your datadir&gt;
</code></pre>
<pre><code class="language-sh">./build/bin/txpool --private.api.addr=localhost:9090 --sentry.api.addr=localhost:9091 --txpool.api.addr=localhost:9094 --datadir=&lt;your datadir&gt;
</code></pre>
<pre><code class="language-sh">./build/bin/rpcdaemon --private.api.addr=localhost:9090 --datadir=&lt;your datadir&gt; --txpool.api.addr=localhost:9094
</code></pre>
<h2 id="flags-explanation-3"><a class="header" href="#flags-explanation-3">Flags explanation</a></h2>
<ul>
<li>
<p><code>--txpool.disable</code>: This flag disables the internal transaction pool (txpool) and block producer (default: <code>false</code>). When running the txpool as a separate process, this flag is used to prevent the internal txpool from interfering with the external one.</p>
</li>
<li>
<p><code>--private.api.addr=localhost:9090</code>: This flag sets the address and port for the private API. The private API is used for internal communication between Erigon components (default: <code>127.0.0.1:9090</code>).</p>
</li>
<li>
<p><code>--datadir=&lt;your datadir&gt;</code>: This flag specifies the data directory for Erigon. This is where Erigon stores its databases and other data.</p>
</li>
<li>
<p><code>--http=false</code>: This flag disables the HTTP API server in Erigon (default: <code>true)</code>. When running the txpool as a separate process, this flag is used to prevent the internal HTTP server from interfering with the external txpool.</p>
</li>
<li>
<p><code>--sentry.api.addr=localhost:9091</code>: This flag sets the address and port for the sentry API. The sentry API is used for communication between the txpool and the sentry.</p>
</li>
<li>
<p><code>--txpool.api.addr=localhost:9094</code>: This flag sets the address and port for the txpool API (default: use value of <code>--private.api.addr</code>). The txpool API is used for communication between the txpool and other Erigon components.</p>
</li>
<li>
<p><code>--pprof</code>: Enable the pprof HTTP server (default: <code>false</code>)</p>
</li>
<li>
<p><code>--pprof.addr 0.0.0.0</code>: This flag sets the address for the pprof HTTP server (default: <code>127.0.0.1</code>). The pprof server is used for profiling and debugging Erigon. By setting this flag to <code>0.0.0.0</code>, the pprof server is made accessible from outside the local machine.</p>
</li>
</ul>
<h2 id="command-line-options-2"><a class="header" href="#command-line-options-2">Command Line Options</a></h2>
<p>To display available options for Txpool digit:</p>
<pre><code class="language-bash">./build/bin/txpool --help
</code></pre>
<p>The <code>--help</code> flag listing is reproduced below for your convenience.</p>
<pre><code>./build/bin/txpool --help
Launch external Transaction Pool instance - same as built-into Erigon, but as independent Process

Usage:
  txpool [flags]

Flags:
      --datadir string                     Data directory for the databases (default "/home/user/.local/share/erigon")
      --db.writemap                        Enable WRITE_MAP feature for fast database writes and fast commit times (default true)
      --diagnostics.disabled               Disable diagnostics
      --diagnostics.endpoint.addr string   Diagnostics HTTP server listening interface (default "127.0.0.1")
      --diagnostics.endpoint.port uint     Diagnostics HTTP server listening port (default 6062)
      --diagnostics.speedtest              Enable speed test
  -h, --help                               help for txpool
      --log.console.json                   Format console logs with JSON
      --log.console.verbosity string       Set the log level for console logs (default "info")
      --log.delays                         Enable block delay logging
      --log.dir.disable                    disable disk logging
      --log.dir.json                       Format file logs with JSON
      --log.dir.path string                Path to store user and error logs to disk
      --log.dir.prefix string              The file name prefix for logs stored to disk
      --log.dir.verbosity string           Set the log verbosity for logs stored to disk (default "info")
      --log.json                           Format console logs with JSON
      --metrics                            Enable metrics collection and reporting
      --metrics.addr string                Enable stand-alone metrics HTTP server listening interface (default "127.0.0.1")
      --metrics.port int                   Metrics HTTP server listening port (default 6061)
      --pprof                              Enable the pprof HTTP server
      --pprof.addr string                  pprof HTTP server listening interface (default "127.0.0.1")
      --pprof.cpuprofile string            Write CPU profile to the given file
      --pprof.port int                     pprof HTTP server listening port (default 6060)
      --private.api.addr string            execution service &lt;host&gt;:&lt;port&gt; (default "localhost:9090")
      --sentry.api.addr strings            comma separated sentry addresses '&lt;host&gt;:&lt;port&gt;,&lt;host&gt;:&lt;port&gt;' (default [localhost:9091])
      --tls.cacert string                  CA certificate for client side TLS handshake
      --tls.cert string                    certificate for client side TLS handshake
      --tls.key string                     key file for client side TLS handshake
      --trace string                       Write execution trace to the given file
      --txpool.accountslots uint           Minimum number of executable transaction slots guaranteed per account (default 16)
      --txpool.api.addr string             txpool service &lt;host&gt;:&lt;port&gt; (default "localhost:9094")
      --txpool.blobpricebump uint          Price bump percentage to replace an existing blob (type-3) transaction (default 100)
      --txpool.blobslots uint              Max allowed total number of blobs (within type-3 txs) per account (default 48)
      --txpool.commit.every duration       How often transactions should be committed to the storage (default 15s)
      --txpool.globalbasefeeslots int      Maximum number of non-executable transactions where only not enough baseFee (default 30000)
      --txpool.globalqueue int             Maximum number of non-executable transaction slots for all accounts (default 30000)
      --txpool.globalslots int             Maximum number of executable transaction slots for all accounts (default 10000)
      --txpool.gossip.disable              Disabling p2p gossip of txs. Any txs received by p2p - will be dropped. Some networks like 'Optimism execution engine'/'Optimistic Rollup' - using it to protect against MEV attacks
      --txpool.pricebump uint              Price bump percentage to replace an already existing transaction (default 10)
      --txpool.pricelimit uint             Minimum gas price (fee cap) limit to enforce for acceptance into the pool (default 1)
      --txpool.totalblobpoollimit uint     Total limit of number of all blobs in txs within the txpool (default 480)
      --txpool.trace.senders strings       Comma separated list of addresses, whose transactions will traced in transaction pool with debug printing
      --verbosity string                   Set the log level for console logs (default "info")
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sentry-2"><a class="header" href="#sentry-2">Sentry</a></h1>
<p><em>P2P network management</em></p>
<p>Sentry connects Erigon to the Ethereum P2P network, enabling the discovery of other participants across the Internet and secure communication with them. It performs these main functions:</p>
<ul>
<li>
<p>Peer discovery via the following:</p>
<ul>
<li>Kademlia DHT</li>
<li>DNS lookup</li>
<li>Configured static peers</li>
<li>Node info saved in the database</li>
<li>Boot nodes pre-configured in the source code</li>
</ul>
</li>
<li>
<p>Peer management:</p>
<ul>
<li>handshakes</li>
<li>holding p2p connection even if Erigon is restarted</li>
</ul>
</li>
</ul>
<p>The ETH core interacts with the Ethereum p2p network through the Sentry component. Sentry provides a simple interface to the core, with functions to download data, receive notifications about gossip messages, upload data on request from peers, and broadcast gossip messages either to a selected set of peers or to all peers.</p>
<h2 id="running-with-an-external-sentry-or-multiple-sentries"><a class="header" href="#running-with-an-external-sentry-or-multiple-sentries">Running with an external Sentry or multiple Sentries</a></h2>
<p>It is possible to have multiple Sentry to increase connectivity to the network or to obscure the location of the core computer. In this case it is necessary to define address and port of each Sentry that should be connected to the Core.</p>
<p>Before using the Sentry component the executable must be built:</p>
<pre><code class="language-bash">cd erigon
make sentry
</code></pre>
<p>Then it can be launched as an independent component with the command:</p>
<pre><code class="language-bash">./build/bin/sentry
</code></pre>
<h3 id="example"><a class="header" href="#example">Example</a></h3>
<p>In this example we will run an instance of Erigon and Sentry on the same machine.</p>
<p>Following is the Sentry client running separately:</p>
<pre><code class="language-bash">./build/bin/sentry --datadir=~/.local/share/erigon
</code></pre>
<p>And Erigon attaching to it:</p>
<pre><code class="language-bash">./build/bin/erigon --sentry.api.addr=127.0.0.1:9091
</code></pre>
<p>Erigon might be attached to several Sentry instances running across different machines. As per Erigon help:</p>
<pre><code class="language-bash">--sentry.api.addr value
</code></pre>
<p>Where <code>value</code> is comma separated sentry addresses <code>&lt;host&gt;:&lt;port&gt;,&lt;host&gt;:&lt;port&gt;</code>.</p>
<h2 id="more-info-1"><a class="header" href="#more-info-1">More info</a></h2>
<p>For other information regarding Sentry functionality, configuration, and usage, please refer to the embedded file you can find in your compiled Erigon folder at <code>./cmd/sentry/README.md</code>.</p>
<h3 id="command-line-options-3"><a class="header" href="#command-line-options-3">Command Line Options</a></h3>
<p>To display available options for Sentry digit:</p>
<pre><code class="language-bash">./build/bin/sentry --help
</code></pre>
<p>The <code>--help</code> flag listing is reproduced below for your convenience.</p>
<pre><code>Run p2p sentry

Usage:
  sentry [flags]

Flags:
      --datadir string                     Data directory for the databases (default "/home/user/.local/share/erigon")
      --diagnostics.disabled               Disable diagnostics
      --diagnostics.endpoint.addr string   Diagnostics HTTP server listening interface (default "127.0.0.1")
      --diagnostics.endpoint.port uint     Diagnostics HTTP server listening port (default 6062)
      --diagnostics.speedtest              Enable speed test
      --discovery.dns strings              Sets DNS discovery entry points (use "" to disable DNS)
      --healthcheck                        Enabling grpc health check
  -h, --help                               help for sentry
      --log.console.json                   Format console logs with JSON
      --log.console.verbosity string       Set the log level for console logs (default "info")
      --log.delays                         Enable block delay logging
      --log.dir.disable                    disable disk logging
      --log.dir.json                       Format file logs with JSON
      --log.dir.path string                Path to store user and error logs to disk
      --log.dir.prefix string              The file name prefix for logs stored to disk
      --log.dir.verbosity string           Set the log verbosity for logs stored to disk (default "info")
      --log.json                           Format console logs with JSON
      --maxpeers int                       Maximum number of network peers (network disabled if set to 0) (default 32)
      --maxpendpeers int                   Maximum number of TCP connections pending to become connected peers (default 1000)
      --metrics                            Enable metrics collection and reporting
      --metrics.addr string                Enable stand-alone metrics HTTP server listening interface (default "127.0.0.1")
      --metrics.port int                   Metrics HTTP server listening port (default 6061)
      --nat string                         NAT port mapping mechanism (any|none|upnp|pmp|stun|extip:&lt;IP&gt;)
                                           			 "" or "none"         Default - do not nat
                                           			 "extip:77.12.33.4"   Will assume the local machine is reachable on the given IP
                                           			 "any"                Uses the first auto-detected mechanism
                                           			 "upnp"               Uses the Universal Plug and Play protocol
                                           			 "pmp"                Uses NAT-PMP with an auto-detected gateway address
                                           			 "pmp:192.168.0.1"    Uses NAT-PMP with the given gateway address
                                           			 "stun"               Uses STUN to detect an external IP using a default server
                                           			 "stun:&lt;server&gt;"      Uses STUN to detect an external IP using the given server (host:port)
                                           
      --netrestrict string                 Restricts network communication to the given IP networks (CIDR masks)
      --nodiscover                         Disables the peer discovery mechanism (manual peer addition)
      --p2p.allowed-ports uints            Allowed ports to pick for different eth p2p protocol versions as follows &lt;porta&gt;,&lt;portb&gt;,..,&lt;porti&gt; (default [30303,30304,30305,30306,30307])
      --p2p.protocol uint                  Version of eth p2p protocol (default 68)
      --port int                           Network listening port (default 30303)
      --pprof                              Enable the pprof HTTP server
      --pprof.addr string                  pprof HTTP server listening interface (default "127.0.0.1")
      --pprof.cpuprofile string            Write CPU profile to the given file
      --pprof.port int                     pprof HTTP server listening port (default 6060)
      --sentry.api.addr string             grpc addresses (default "localhost:9091")
      --staticpeers strings                Comma separated enode URLs to connect to
      --trace string                       Write execution trace to the given file
      --trustedpeers strings               Comma separated enode URLs which are always allowed to connect, even above the peer limit
      --verbosity string                   Set the log level for console logs (default "info")
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="downloader-2"><a class="header" href="#downloader-2">Downloader</a></h1>
<p><em>Seeding/downloading historical data</em></p>
<p>The Downloader is a service responsible for seeding and downloading historical data using the BitTorrent protocol. Data is stored in the form of immutable <code>.seg</code> files, known as <strong>snapshots</strong>. The Ethereum core instructs the Downloader to download specific files, identified by their unique info hashes, which include both block headers and block bodies. The Downloader then communicates with the BitTorrent network to retrieve the necessary files, as specified by the Ethereum core.</p>
<blockquote>
<p><strong>Warning</strong>: While all Erigon components are separable and can be run on different machines, the Downloader must run on the same machine as Erigon to be able to share downloaded and seeded files.</p>
</blockquote>
<p>For a comprehensive understanding of the Downloader's functionality, configuration, and usage, please refer to <a href="https://github.com/erigontech/erigon/blob/main/cmd/downloader/readme.md">./cmd/downloader/README.md</a> with the following key topics:</p>
<ol>
<li><strong>Snapshots overview</strong>: An introduction to snapshots, their benefits, and how they are created and used in Erigon.</li>
<li><strong>Starting Erigon with snapshots support</strong>: Instructions on how to start Erigon with snapshots support, either by default or as a separate process.</li>
<li><strong>Creating new networks or bootnodes</strong>: A guide on how to create new networks or bootnodes, including creating new snapshots and starting the Downloader.</li>
<li><strong>Architecture</strong>: An overview of the Downloader's architecture, including how it works with Erigon and the different ways .torrent files can be created.</li>
<li><strong>Utilities</strong>: A list of available utilities, including <code>torrent_cat</code>, <code>torrent_magnet</code>, and <code>torrent_clean</code>.</li>
<li><strong>Remote manifest verify</strong>: Instructions on how to verify that remote webseeds have available manifests and all manifested files are available.</li>
<li><strong>Faster rsync</strong>: Tips on how to use <code>rsync</code> for faster file transfer.</li>
<li><strong>Release details</strong>: Information on how to start automatic commits of new hashes to the <code>master</code> branch.</li>
<li><strong>Creating a seedbox</strong>: A guide on how to create a seedbox to support a new network or type of snapshots.</li>
</ol>
<p>Some of the key sections in the documentation include:</p>
<ul>
<li><strong>How to create new snapshots</strong>: Instructions on how to create new snapshots, including using the <code>seg</code> command and creating .torrent files.</li>
<li><strong>How to start the Downloader</strong>: Instructions on how to start the Downloader, either as a separate process or as part of Erigon.</li>
<li><strong>How to verify .seg files</strong>: Instructions on how to verify that .seg files have the same checksum as the current .torrent files.</li>
</ul>
<p>By referring to the embedded documentation file, you can gain a deeper understanding of the Downloader's capabilities and how to effectively utilize it in your Erigon setup.</p>
<h2 id="command-line-options-4"><a class="header" href="#command-line-options-4">Command line options</a></h2>
<p>To display available options for downloader digit:</p>
<pre><code class="language-bash">./build/bin/downloader --help
</code></pre>
<p>The <code>--help</code> flag listing is reproduced below for your convenience.</p>
<pre><code>snapshot downloader

Usage:
   [flags]
   [command]

Examples:
go run ./cmd/downloader --datadir &lt;your_datadir&gt; --downloader.api.addr 127.0.0.1:9093

Available Commands:
  completion      Generate the autocompletion script for the specified shell
  help            Help about any command
  manifest        
  manifest-verify 
  torrent_cat     
  torrent_clean   Remove all .torrent files from datadir directory
  torrent_create  
  torrent_hashes  
  torrent_magnet  

Flags:
      --chain string                       name of the network to join (default "mainnet")
      --datadir string                     Data directory for the databases (default "/home/admin/.local/share/erigon")
      --db.writemap                        Enable WRITE_MAP feature for fast database writes and fast commit times (default true)
      --diagnostics.disabled               Disable diagnostics
      --diagnostics.endpoint.addr string   Diagnostics HTTP server listening interface (default "127.0.0.1")
      --diagnostics.endpoint.port uint     Diagnostics HTTP server listening port (default 6062)
      --diagnostics.speedtest              Enable speed test
      --downloader.api.addr string         external downloader api network address, for example: 127.0.0.1:9093 serves remote downloader interface (default "127.0.0.1:9093")
      --downloader.disable.ipv4            Turns off ipv6 for the downloader
      --downloader.disable.ipv6            Turns off ipv6 for the downloader
  -h, --help                               help for this command
      --log.console.json                   Format console logs with JSON
      --log.console.verbosity string       Set the log level for console logs (default "info")
      --log.delays                         Enable block delay logging
      --log.dir.disable                    disable disk logging
      --log.dir.json                       Format file logs with JSON
      --log.dir.path string                Path to store user and error logs to disk
      --log.dir.prefix string              The file name prefix for logs stored to disk
      --log.dir.verbosity string           Set the log verbosity for logs stored to disk (default "info")
      --log.json                           Format console logs with JSON
      --metrics                            Enable metrics collection and reporting
      --metrics.addr string                Enable stand-alone metrics HTTP server listening interface (default "127.0.0.1")
      --metrics.port int                   Metrics HTTP server listening port (default 6061)
      --nat string                         NAT port mapping mechanism (any|none|upnp|pmp|stun|extip:&lt;IP&gt;)
                                           			 "" or "none"         Default - do not nat
                                           			 "extip:77.12.33.4"   Will assume the local machine is reachable on the given IP
                                           			 "any"                Uses the first auto-detected mechanism
                                           			 "upnp"               Uses the Universal Plug and Play protocol
                                           			 "pmp"                Uses NAT-PMP with an auto-detected gateway address
                                           			 "pmp:192.168.0.1"    Uses NAT-PMP with the given gateway address
                                           			 "stun"               Uses STUN to detect an external IP using a default server
                                           			 "stun:&lt;server&gt;"      Uses STUN to detect an external IP using the given server (host:port)
                                           
      --pprof                              Enable the pprof HTTP server
      --pprof.addr string                  pprof HTTP server listening interface (default "127.0.0.1")
      --pprof.cpuprofile string            Write CPU profile to the given file
      --pprof.port int                     pprof HTTP server listening port (default 6060)
      --seedbox                            Turns downloader into independent (doesn't need Erigon) software which discover/download/seed new files - useful for Erigon network, and can work on very cheap hardware. It will: 1) download .torrent from webseed 2) download new files after upgrade 3) we planing add discovery of new files soon
      --torrent.conns.perfile int          Number of connections per file (default 10)
      --torrent.download.rate string       Bytes per second, example: 32mb (default "128mb")
      --torrent.download.slots int         Amount of files to download in parallel. (default 128)
      --torrent.maxpeers int               Unused parameter (reserved for future use) (default 100)
      --torrent.port int                   Port to listen and serve BitTorrent protocol (default 42069)
      --torrent.staticpeers string         Comma separated host:port to connect to
      --torrent.upload.rate string         Bytes per second, example: 32mb (default "4mb")
      --torrent.verbosity int              0=silent, 1=error, 2=warn, 3=info, 4=debug, 5=detail (must set --verbosity to equal or higher level and has default: 2) (default 2)
      --trace string                       Write execution trace to the given file
      --verbosity string                   Set the log level for console logs (default "info")
      --verify                             Verify snapshots on startup. It will not report problems found, but re-download broken pieces.
      --verify.failfast                    Stop on first found error. Report it and exit
      --verify.files string                Limit list of files to verify
      --webseed string                     Comma-separated URL's, holding metadata about network-support infrastructure (like S3 buckets with snapshots, bootnodes, etc...)

Use " [command] --help" for more information about a command.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="multiple-instances--one-machine-review"><a class="header" href="#multiple-instances--one-machine-review">Multiple instances / One machine [REVIEW]</a></h1>
<p>Erigon supports running multiple instances on the same machine by configuring distinct ports and data directories for each instance. Multiple instances are fully supported but require careful configuration to avoid port conflicts and resource contention. The modular architecture allows for flexible deployment patterns, from fully integrated instances to distributed service architectures. The primary consideration is the performance impact from shared disk access, especially during initial synchronization phases.</p>
<h2 id="required-configuration-flags"><a class="header" href="#required-configuration-flags">Required Configuration Flags</a></h2>
<p>To avoid conflicts between instances, you must define <strong>6 essential flags</strong> for each instance:</p>
<ul>
<li><code>--datadir</code> - Separate data directory for each instance</li>
<li><code>--port</code> - P2P networking port (default: <code>30303</code>)</li>
<li><code>--http.port</code> - HTTP JSON-RPC port (default: <code>8545</code>)</li>
<li><code>--authrpc.port</code> - Engine API port (default: <code>8551</code>)</li>
<li><code>--torrent.port</code> - BitTorrent protocol port (default: <code>42069</code>)</li>
<li><code>--private.api.addr</code> - Internal gRPC API address (default: <code>127.0.0.1:9090</code>)</li>
</ul>
<h2 id="example-configuration"><a class="header" href="#example-configuration">Example Configuration</a></h2>
<p>Here's how to run mainnet and sepolia instances simultaneously:</p>
<pre><code class="language-bash"># Mainnet instance
./build/bin/erigon \
  --datadir="&lt;your_mainnet_data_path&gt;" \
  --chain=mainnet \
  --port=30303 \
  --http.port=8545 \
  --authrpc.port=8551 \
  --torrent.port=42069 \
  --private.api.addr=127.0.0.1:9090 \
  --http --ws \
  --http.api=eth,debug,net,trace,web3,erigon

# Sepolia instance
./build/bin/erigon \
  --datadir="&lt;your_sepolia_data_path&gt;" \
  --chain=sepolia \
  --port=30304 \
  --http.port=8546 \
  --authrpc.port=8552 \
  --torrent.port=42068 \
  --private.api.addr=127.0.0.1:9091 \
  --http --ws \
  --http.api=eth,debug,net,trace,web3,erigon
</code></pre>
<h2 id="docker-compose-multi-instance-setup"><a class="header" href="#docker-compose-multi-instance-setup">Docker Compose Multi-Instance Setup</a></h2>
<p>For containerized deployments, the docker-compose configuration shows how services can be orchestrated with proper port isolation:</p>
<p>The compose file demonstrates the port allocation strategy:</p>
<ul>
<li><strong>9090-9094</strong>: Internal gRPC services (execution, sentry, consensus, downloader, txpool)</li>
<li><strong>8545, 8551</strong>: External HTTP APIs</li>
<li><strong>30303, 42069</strong>: P2P networking ports</li>
</ul>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<h3 id="1-resource-management"><a class="header" href="#1-resource-management">1. Resource Management</a></h3>
<p><strong>Memory Considerations:</strong>
Erigon uses memory-mapped files (MDBX) where the OS manages page cache. Multiple instances will share the same page cache efficiently, but be aware that:</p>
<ul>
<li>Each instance uses ~4GB RAM during genesis sync and ~1GB during normal operation</li>
<li>OS page cache can utilize unlimited memory and is shared between instances</li>
<li>Memory usage shown by <code>htop</code> includes OS page cache and may appear inflated</li>
</ul>
<blockquote>
<p>⚠️ <strong>Disk Performance Warning:</strong> Multiple instances accessing the same disk concurrently will impact performance due to increased random disk access. This is particularly problematic during the "Blocks Execution stage" which performs many random reads. <strong>Avoid running multiple genesis syncs on the same disk.</strong></p>
</blockquote>
<h3 id="2-database-configuration"><a class="header" href="#2-database-configuration">2. Database Configuration</a></h3>
<p>For multiple instances, consider adjusting database parameters to reduce resource contention:</p>
<pre><code class="language-bash"># Reduce memory-mapped database growth to minimize disk churn
--db.growth.step=32MB
--db.size.limit=512MB
</code></pre>
<h3 id="3-network-port-management"><a class="header" href="#3-network-port-management">3. Network Port Management</a></h3>
<p><strong>Default Port Allocation:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Component</th><th>Default Port</th><th>Protocol</th><th>Purpose</th></tr></thead><tbody>
<tr><td>Engine</td><td>9090</td><td>TCP</td><td>gRPC Server (Private)</td></tr>
<tr><td>Engine</td><td>42069</td><td>TCP/UDP</td><td>BitTorrent (Public)</td></tr>
<tr><td>Engine</td><td>8551</td><td>TCP</td><td>Engine API (Private)</td></tr>
<tr><td>Sentry</td><td>30303/30304</td><td>TCP/UDP</td><td>P2P Peering (Public)</td></tr>
<tr><td>RPCDaemon</td><td>8545</td><td>TCP</td><td>HTTP/WebSocket (Private)</td></tr>
</tbody></table>
</div>
<h3 id="4-service-separation"><a class="header" href="#4-service-separation">4. Service Separation</a></h3>
<p>Erigon supports modular deployment where components can run as separate processes:</p>
<p>For multiple instances, you can:</p>
<ul>
<li>Run each instance with integrated services (default)</li>
<li>Separate heavy components like <code>downloader</code> or <code>rpcdaemon</code> to dedicated processes</li>
<li>Use the <code>--private.api.addr</code> flag for inter-service communication</li>
</ul>
<h3 id="5-monitoring-and-logging"><a class="header" href="#5-monitoring-and-logging">5. Monitoring and Logging</a></h3>
<p>Configure separate log directories for each instance:</p>
<pre><code class="language-bash"># Instance 1
--log.dir.path=/logs/mainnet

# Instance 2  
--log.dir.path=/logs/sepolia
</code></pre>
<p>For Prometheus monitoring, each instance should expose metrics on different ports.</p>
<h2 id="performance-optimization"><a class="header" href="#performance-optimization">Performance Optimization</a></h2>
<h3 id="cloud-storage-considerations"><a class="header" href="#cloud-storage-considerations">Cloud Storage Considerations</a></h3>
<p>If using network-attached storage, apply these optimizations:</p>
<pre><code class="language-bash"># Reduce disk latency impact
export ERIGON_SNAPSHOT_MADV_RND=false
--db.pagesize=64kb

# For Polygon networks
--sync.loop.block.limit=10000
</code></pre>
<h3 id="memory-locking-for-performance"><a class="header" href="#memory-locking-for-performance">Memory Locking for Performance</a></h3>
<p>For production setups with sufficient RAM, you can lock critical data in memory:</p>
<pre><code class="language-bash"># Lock domain snapshots in RAM
vmtouch -vdlw /mnt/erigon/snapshots/domain/*bt
ls /mnt/erigon/snapshots/domain/*.kv | parallel vmtouch -vdlw
</code></pre>
<pre><code class="language-markdown">vmtouch -vdlw /mnt/erigon/snapshots/domain/*bt
ls /mnt/erigon/snapshots/domain/*.kv | parallel vmtouch -vdlw
</code></pre>
<p>If it is failing with "can't allocate memory", try:</p>
<pre><code>sync &amp;&amp; sudo sysctl vm.drop_caches=3
echo 1 &gt; /proc/sys/vm/compact_memory
</code></pre>
<blockquote>
<p><strong>Warning:</strong>: Running multiple instances of Erigon on the same machine will cause concurrent disk access, which can negatively impact performance. One of Erigon's main optimizations is to reduce disk random access, but the "Blocks Execution stage" still performs many random reads, making it the slowest stage. Therefore, <strong>we do not recommend running multiple genesis syncs on the same disk</strong>. However, if the genesis sync has already been completed, it is acceptable to run multiple Erigon instances on the same disk.</p>
</blockquote>
<p>What can be done:</p>
<ul>
<li>reduce disk latency (not throughput, not iops)
<ul>
<li>use latency-critical cloud-drives</li>
<li>or attached-NVMe (at least for initial sync)</li>
</ul>
</li>
<li>increase RAM</li>
<li>if you throw enough RAM, then can set env variable <code>ERIGON_SNAPSHOT_MADV_RND=false</code></li>
<li>Use <code>--db.pagesize=64kb</code> (less fragmentation, more IO)</li>
<li>Or use Erigon3 (it also sensitive for disk-latency - but it will download 99% of history)</li>
</ul>
<pre><code class="language-yaml"># Ports: `9090` execution engine (private api), `9091` sentry, `9092` consensus engine, `9093` snapshot downloader, `9094` TxPool
# Ports: `8545` json rpc, `8551` consensus json rpc, `30303` eth p2p protocol, `42069` bittorrent protocol,

# Connections: erigon -&gt; (sentries, downloader), rpcdaemon -&gt; (erigon, txpool), txpool -&gt; erigon
</code></pre>
<h3 id="how-ram-is-used"><a class="header" href="#how-ram-is-used">How RAM is used</a></h3>
<p>Erigon will utilize all available RAM, but this memory will not be directly owned by Erigon's process. Instead, the operating system (OS) will manage this memory. The OS will keep the frequently accessed parts of the database (DB) in RAM. If the OS needs to allocate RAM for other programs or for a second instance of Erigon, it will handle the memory management accordingly. This mechanism is known as PageCache.</p>
<p>Erigon itself consumes less than 2GB of RAM. Therefore, Erigon will benefit from having more RAM available, as it can use all of it without needing any reconfiguration. The same PageCache can be shared by other processes running on the same machine, simply by opening the same DB file. For example, if RPCDaemon is started with the <code>--datadir</code> option, it will open Erigon's DB and utilize the same PageCache. This means that if data A is already in RAM because it is frequently accessed and RPCDaemon reads it, it will read it from RAM rather than from the disk, leveraging shared memory.</p>
<pre><code class="language-go">	// These are set to prevent disk and page size churn which can be excessive
	// when running multiple nodes
	// MdbxGrowthStep impacts disk usage, MdbxDBSizeLimit impacts page file usage
	n.nodeCfg.MdbxGrowthStep = 32 * datasize.MB
	n.nodeCfg.MdbxDBSizeLimit = 512 * datasize.MB
</code></pre>
<pre><code class="language-yaml">      --datadir=/home/erigon/.local/share/erigon --chain=dev --private.api.addr=0.0.0.0:9090 --mine --log.dir.path=/logs/node1
    ports:
      - "8551:8551"
    volumes:
      - datadir:/home/erigon/.local/share/erigon
      - ./logdir:/logs
    user: ${DOCKER_UID}:${DOCKER_GID}
    restart: unless-stopped
    mem_swappiness: 0

  erigon-node2:
    profiles:
      - second
    image: erigontech/erigon:$ERIGON_TAG
    command: |
      --datadir=/home/erigon/.local/share/erigon --chain=dev --private.api.addr=0.0.0.0:9090 --staticpeers=$ENODE --log.dir.path=/logs/node2
</code></pre>
<pre><code class="language-yaml">      - targets:
          - erigon:6060 # If Erigon runned by default docker-compose, then it's available on `erigon` host.
          - erigon:6061
          - erigon:6062
          - 46.149.164.51:6060
          - host.docker.internal:6060 # this is how docker-for-mac allow to access host machine
          - host.docker.internal:6061
          - host.docker.internal:6062
          - 192.168.255.134:6060
          - 192.168.255.134:6061
          - 192.168.255.134:6062
          - 192.168.255.138:6060
          - 192.168.255.138:6061
          - 192.168.255.138:6062
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="web3-wallet"><a class="header" href="#web3-wallet">Web3 Wallet</a></h1>
<p><em>How to configure your web3 wallet to use your Erigon node RPC</em></p>
<p>Whatever network you are running, it's easy to connect your Erigon node to your local web3 wallet.</p>
<p>For Erigon to provide access to wallet functionalities it is necessary to enable RPC by adding the flags</p>
<pre><code class="language-bash">--http.addr="0.0.0.0" --http.api=eth,web3,net,debug,trace,txpool
</code></pre>
<p>For example:</p>
<pre><code class="language-bash">/build/bin/erigon --http.addr="0.0.0.0" --http.api=eth,web3,net,debug,trace,txpool
</code></pre>
<h1 id="metamask"><a class="header" href="#metamask">Metamask</a></h1>
<p>To configure your local Metamask wallet (browser extension):</p>
<ul>
<li>Click on the <strong>network selector button</strong>. This will display a list of networks to which you're already connected</li>
<li>Click <strong>Add network</strong></li>
<li>A new browser tab will open, displaying various fields to fill out. Complete the fields with the proper information, in this example for Ethereum network:
<ul>
<li><strong>Network Name</strong>: <code>Ethereum on E3</code> (or any name of your choice)</li>
<li><strong>Chain ID</strong>: <code>1</code> for chain ID parameter see <a href="fundamentals/networks.html">Supported Networks</a></li>
<li><strong>New RPC URL</strong>: <code>http://127.0.0.1:8545</code></li>
<li><strong>Currency Symbol</strong>: <code>ETH</code></li>
<li><strong>Block Explorer URL</strong>: <code>https://www.etherscan.io</code> (or any explorer of your choice)</li>
</ul>
</li>
</ul>
<p>After performing the above steps, you will be able to see the custom network the next time you access the network selector.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interacting-with-erigon"><a class="header" href="#interacting-with-erigon">Interacting with Erigon</a></h1>
<p>The RPC daemon is a -  component of Erigon, enabling JSON remote procedure calls and providing access to various APIs. It is designed to operate effectively both as an internal or as an external component. For detailed instructions on running it remotely, refer to the documentation <a href="https://github.com/erigontech/erigon/blob/main/cmd/rpcdaemon/README.md#running-remotely">here</a>.</p>
<p>The RPC Daemon supports various API namespaces, which can be enabled or disabled using the --http.api flag. The available namespaces include:</p>
<ul>
<li><a href="interacting-with-erigon/eth.html"><code>eth</code></a>: Standard Ethereum API.</li>
<li><a href="interacting-with-erigon/erigon.html"><code>erigon</code></a>: Erigon-specific extensions.</li>
<li><a href="interacting-with-erigon/web3.html"><code>web3</code></a>: Web3 compatibility API.</li>
<li><a href="interacting-with-erigon/net.html"><code>net</code></a>: Network information API.</li>
<li><a href="interacting-with-erigon/debug.html"><code>debug</code></a>: Debugging and tracing API.</li>
<li><a href="interacting-with-erigon/trace.html"><code>trace</code></a>: Transaction tracing API.</li>
<li><a href="interacting-with-erigon/txpool.html"><code>txpool</code></a>: Transaction pool API.</li>
<li><a href="interacting-with-erigon/admin.html"><code>admin</code></a>: Node administration API</li>
<li><a href="interacting-with-erigon/bor.html"><code>bor</code></a>: Polygon Bor-specific API (when running on Polygon)</li>
<li><a href="interacting-with-erigon/ots.html"><code>ots</code></a>: These methods are specifically tailored for use with Otterscan, an open-source, fast block explorer.</li>
<li><a href="interacting-with-erigon/internal.html"><code>internal</code></a>: Erigon specific API for development and debugging purposes.</li>
<li><a href="interacting-with-erigon/gRPC.html"><code>gRPC</code></a>: API for lower-level data access.</li>
</ul>
<p>Looking at the Reth documentation you provided, I'll rewrite it for Erigon based on the codebase context. The documentation covers RPC transports (HTTP, WebSockets, IPC) and API configuration, which corresponds to Erigon's RPC daemon configuration found in <cite>cmd/rpcdaemon/cli/config.go</cite> and related files.</p>
<h2 id="erigon-rpc-transports"><a class="header" href="#erigon-rpc-transports">Erigon RPC Transports</a></h2>
<p>Erigon supports HTTP, WebSockets, IPC, and gRPC through its RPC daemon.</p>
<h3 id="http"><a class="header" href="#http">HTTP</a></h3>
<p>Using the HTTP transport, clients send a request to the server and immediately get a response back. The connection is closed after the response for a given request is sent.</p>
<p>Because HTTP is unidirectional, subscriptions are not supported.</p>
<p>To start an HTTP server, you can either run Erigon with built-in RPC or use the separate <code>rpcdaemon</code>:</p>
<pre><code class="language-bash"># Built-in RPC (default)
erigon --http

# Or separate RPC daemon
rpcdaemon --http.enabled
</code></pre>
<p>The default port is <code>8545</code>, and the default listen address is localhost. <cite>node/nodecfg/defaults.go:30-31</cite></p>
<p>You can configure the listen address and port using <code>--http.addr</code> and <code>--http.port</code> respectively:</p>
<pre><code class="language-bash">erigon --http --http.addr 127.0.0.1 --http.port 12345
# Or with rpcdaemon
rpcdaemon --http.addr 127.0.0.1 --http.port 12345
</code></pre>
<p>To enable JSON-RPC namespaces on the HTTP server, pass each namespace separated by a comma to <code>--http.api</code>:</p>
<pre><code class="language-bash">erigon --http --http.api eth,net,debug,trace
# Or with rpcdaemon
rpcdaemon --http.api eth,net,debug,trace
</code></pre>
<p>The default APIs enabled are <code>eth</code> and <code>erigon</code>. Available namespaces include: <code>admin</code>, <code>debug</code>, <code>eth</code>, <code>erigon</code>, <code>net</code>, <code>trace</code>, <code>txpool</code>, <code>web3</code>, <code>bor</code> (Polygon only), and <code>internal</code>.</p>
<p>You can also restrict who can access the HTTP server by specifying domains for Cross-Origin requests using <code>--http.corsdomain</code>:</p>
<pre><code class="language-bash">erigon --http --http.corsdomain https://mycoolapp.com
</code></pre>
<p>Alternatively, if you want to allow any domain, you can pass <code>*</code>:</p>
<pre><code class="language-bash">erigon --http --http.corsdomain "*"
</code></pre>
<h3 id="websockets"><a class="header" href="#websockets">WebSockets</a></h3>
<p>WebSockets is a bidirectional transport protocol. Most modern browsers support WebSockets.</p>
<p>A WebSocket connection is maintained until it is explicitly terminated by either the client or the node.</p>
<p>Because WebSockets are bidirectional, nodes can push events to clients, which enables clients to subscribe to specific events, such as new transactions in the transaction pool, and new logs for smart contracts.</p>
<p>The configuration of the WebSocket server follows the same pattern as the HTTP server:</p>
<ul>
<li>Enable it using <code>--ws</code></li>
<li>Configure the server port by passing <code>--ws.port</code> (default <code>8546</code>) <cite>node/nodecfg/defaults.go:34</cite></li>
<li>Configure cross-origin requests using <code>--ws.origins</code> (though this maps to <code>--http.corsdomain</code> in Erigon)</li>
<li>WebSocket APIs inherit from the HTTP API configuration</li>
</ul>
<pre><code class="language-bash">erigon --http --ws --http.api eth,net,debug,trace
</code></pre>
<h3 id="ipc"><a class="header" href="#ipc">IPC</a></h3>
<p>IPC is a simpler transport protocol for use in local environments where the node and the client exist on the same machine.</p>
<p>The IPC transport can be enabled using <code>--socket.enabled</code> and configured with <code>--socket.url</code>:</p>
<pre><code class="language-bash">erigon --socket.enabled --socket.url unix:///var/run/erigon.ipc
</code></pre>
<p>On Linux and macOS, Erigon uses UNIX sockets. On Windows, IPC is provided using named pipes. The socket inherits the namespaces from <code>--http.api</code>.</p>
<h3 id="grpc"><a class="header" href="#grpc">gRPC</a></h3>
<p>Erigon also supports gRPC for high-performance access to blockchain data:</p>
<pre><code class="language-bash">rpcdaemon --grpc --grpc.addr localhost --grpc.port 9090
</code></pre>
<h3 id="https"><a class="header" href="#https">HTTPS</a></h3>
<p>Erigon supports HTTPS and HTTP/2 out of the box:</p>
<pre><code class="language-bash">rpcdaemon --https.enabled --https.cert /path/to/cert.pem --https.key /path/to/key.pem
</code></pre>
<h2 id="interacting-with-the-rpc"><a class="header" href="#interacting-with-the-rpc">Interacting with the RPC</a></h2>
<p>You can easily interact with these APIs just like you would with any Ethereum client.</p>
<p>You can use <code>curl</code>, a programming language with a low-level library, or tools like Foundry to interact with the chain at the exposed HTTP or WebSocket port.</p>
<p>To enable all APIs using an HTTP transport:</p>
<pre><code class="language-bash">erigon --http --http.api "admin,debug,eth,erigon,net,trace,txpool,web3"
</code></pre>
<p>This allows you to then call:</p>
<pre><code class="language-bash">curl -X POST -H "Content-Type: application/json" --data '{"jsonrpc":"2.0","method":"eth_blockNumber","params":[],"id":1}' localhost:8545

# With cast (if using Foundry)
cast block-number
cast rpc admin_nodeInfo  
cast rpc debug_traceTransaction &lt;tx_hash&gt;
cast rpc erigon_forks
</code></pre>
<h2 id="modular-architecture"><a class="header" href="#modular-architecture">Modular Architecture</a></h2>
<p>Erigon supports running components as separate processes. The RPC daemon can run independently from the main Erigon node:</p>
<pre><code class="language-bash"># Start main Erigon node
erigon --http=false --private.api.addr=localhost:9090

# Start separate RPC daemon
rpcdaemon --private.api.addr=localhost:9090 --http.api=eth,erigon,web3,net,debug,trace,txpool
</code></pre>
<p>This modular approach allows for better resource management and scalability.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="eth-rpc-namespace"><a class="header" href="#eth-rpc-namespace"><code>eth</code> RPC Namespace</a></h1>
<p>Standard Ethereum API, which documentation can be found at <a href="https://ethereum.org/en/developers/docs/apis/json-rpc/">https://ethereum.org/en/developers/docs/apis/json-rpc/</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="erigon-rpc-namespace"><a class="header" href="#erigon-rpc-namespace"><code>erigon</code> RPC Namespace</a></h1>
<h2 id="introduction-2"><a class="header" href="#introduction-2">Introduction</a></h2>
<p>Erigon provides several specialized RPC namespaces that extend beyond the standard Ethereum JSON-RPC API. These namespaces offer optimized access to blockchain data and expose Erigon-specific functionality that takes advantage of the node's unique architecture and data structures. The primary Erigon-specific namespace is <strong><code>erigon_</code></strong>  which offer extended blockchain data access methods.</p>
<p>These methods must be explicitly enabled using the <code>--http.api</code> flag when starting the RPC daemon.</p>
<h3 id="namespace-availability"><a class="header" href="#namespace-availability">Namespace Availability</a></h3>
<ul>
<li>The <code>erigon_</code> namespace is enabled by default in the RPC daemon and must be explicitly included in the <code>--http.api</code> flag if customizing enabled namespaces.</li>
</ul>
<h3 id="performance-considerations"><a class="header" href="#performance-considerations">Performance Considerations</a></h3>
<ul>
<li>Erigon-specific methods are optimized for Erigon's architecture and often provide better performance than standard equivalents</li>
<li>Methods like <code>erigon_getHeaderByNumber</code> and <code>erigon_getHeaderByHash</code> can be faster as they skip transaction and uncle data</li>
<li>The <code>erigon_getLatestLogs</code> method includes advanced pagination to handle large result sets efficiently</li>
</ul>
<h3 id="enhanced-features"><a class="header" href="#enhanced-features">Enhanced Features</a></h3>
<ul>
<li><code>erigon_getLatestLogs</code> supports <code>ignoreTopicsOrder</code> for flexible topic matching</li>
<li><code>erigon_getLogs</code> returns enhanced ErigonLog objects with additional metadata like timestamps</li>
<li><code>erigon_getBlockByTimestamp</code> uses binary search for efficient timestamp-based block lookup</li>
</ul>
<p>See more details <a href="https://github.com/erigontech/erigon/blob/main/cmd/rpcdaemon/README.md#rpc-implementation-status">here</a> about implementation status.</p>
<hr />
<h2 id="erigon_forks"><a class="header" href="#erigon_forks"><strong>erigon_forks</strong></a></h2>
<p>Returns the genesis block hash and a sorted list of all fork block numbers for the current chain configuration.</p>
<p><strong>Parameters</strong></p>
<p>None</p>
<p><strong>Example</strong></p>
<pre><code class="language-bash">curl -s --data '{"jsonrpc":"2.0","method":"erigon_forks","params":[],"id":"1"}' -H "Content-Type: application/json" -X POST http://localhost:8545
</code></pre>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">Object</td><td style="text-align: left">Contains genesis hash and fork information</td></tr>
<tr><td style="text-align: left">genesis</td><td style="text-align: left">DATA, 32 BYTES - The genesis block hash</td></tr>
<tr><td style="text-align: left">heightForks</td><td style="text-align: left">ARRAY - Array of block numbers where height-based forks occur</td></tr>
<tr><td style="text-align: left">timeForks</td><td style="text-align: left">ARRAY - Array of timestamps where time-based forks occur</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="erigon_blocknumber"><a class="header" href="#erigon_blocknumber"><strong>erigon_blockNumber</strong></a></h2>
<p>Returns the latest executed block number. Unlike <code>eth_blockNumber</code>, this method can accept a specific block number parameter and returns the latest executed block rather than the fork choice head after the merge.</p>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Parameter</th><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">blockNumber</td><td style="text-align: left">QUANTITY (optional)</td><td style="text-align: left">Block number to query. If omitted, returns latest executed block number</td></tr>
</tbody></table>
</div>
<p><strong>Example</strong></p>
<pre><code class="language-bash">curl -s --data '{"jsonrpc":"2.0","method":"erigon_blockNumber","params":[],"id":"1"}' -H "Content-Type: application/json" -X POST http://localhost:8545
</code></pre>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">QUANTITY</td><td style="text-align: left">The block number as hexadecimal</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="erigon_getheaderbynumber"><a class="header" href="#erigon_getheaderbynumber"><strong>erigon_getHeaderByNumber</strong></a></h2>
<p>Returns a block header by block number, ignoring transaction and uncle data for potentially faster response times.</p>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Parameter</th><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">blockNumber</td><td style="text-align: left">QUANTITY|TAG</td><td style="text-align: left">Block number or "latest", "earliest", "pending"</td></tr>
</tbody></table>
</div>
<p><strong>Example</strong></p>
<pre><code class="language-bash">curl -s --data '{"jsonrpc":"2.0","method":"erigon_getHeaderByNumber","params":["0x1b4"],"id":"1"}' -H "Content-Type: application/json" -X POST http://localhost:8545
</code></pre>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">Object</td><td style="text-align: left">Block header object with all header fields</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="erigon_getheaderbyhash"><a class="header" href="#erigon_getheaderbyhash"><strong>erigon_getHeaderByHash</strong></a></h2>
<p>Returns a block header by block hash, ignoring transaction and uncle data for potentially faster response times.</p>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Parameter</th><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">blockHash</td><td style="text-align: left">DATA, 32 BYTES</td><td style="text-align: left">Hash of the block</td></tr>
</tbody></table>
</div>
<p><strong>Example</strong></p>
<pre><code class="language-bash">curl -s --data '{"jsonrpc":"2.0","method":"erigon_getHeaderByHash","params":["0x1d59ff54b1eb26b013ce3cb5fc9dab3705b415a67127a003c3e61eb445bb8df2"],"id":"1"}' -H "Content-Type: application/json" -X POST http://localhost:8545
</code></pre>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">Object</td><td style="text-align: left">Block header object with all header fields</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="erigon_getblockbytimestamp"><a class="header" href="#erigon_getblockbytimestamp"><strong>erigon_getBlockByTimestamp</strong></a></h2>
<p>Returns a block by timestamp using binary search to find the closest block to the specified timestamp.</p>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Parameter</th><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">timestamp</td><td style="text-align: left">QUANTITY</td><td style="text-align: left">Unix timestamp</td></tr>
<tr><td style="text-align: left">fullTx</td><td style="text-align: left">Boolean</td><td style="text-align: left">If true, include full transaction objects; if false, only transaction hashes</td></tr>
</tbody></table>
</div>
<p><strong>Example</strong></p>
<pre><code class="language-bash">curl -s --data '{"jsonrpc":"2.0","method":"erigon_getBlockByTimestamp","params":["0x5ddf2094", false],"id":"1"}' -H "Content-Type: application/json" -X POST http://localhost:8545
</code></pre>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">Object</td><td style="text-align: left">Block object matching closest to the timestamp</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="erigon_getbalancechangesinblock"><a class="header" href="#erigon_getbalancechangesinblock"><strong>erigon_getBalanceChangesInBlock</strong></a></h2>
<p>Returns all account balance changes that occurred within a specific block.</p>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Parameter</th><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">blockNrOrHash</td><td style="text-align: left">QUANTITY|TAG|HASH</td><td style="text-align: left">Block number, tag, or block hash</td></tr>
</tbody></table>
</div>
<p><strong>Example</strong></p>
<pre><code class="language-bash">curl -s --data '{"jsonrpc":"2.0","method":"erigon_getBalanceChangesInBlock","params":["0x1b4"],"id":"1"}' -H "Content-Type: application/json" -X POST http://localhost:8545
</code></pre>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">Object</td><td style="text-align: left">Mapping of addresses to their new balance values</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="erigon_getlogsbyhash"><a class="header" href="#erigon_getlogsbyhash"><strong>erigon_getLogsByHash</strong></a></h2>
<p>Returns an array of arrays of logs generated by transactions in a block given by block hash.</p>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Parameter</th><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">blockHash</td><td style="text-align: left">DATA, 32 BYTES</td><td style="text-align: left">Hash of the block</td></tr>
</tbody></table>
</div>
<p><strong>Example</strong></p>
<pre><code class="language-bash">curl -s --data '{"jsonrpc":"2.0","method":"erigon_getLogsByHash","params":["0x1d59ff54b1eb26b013ce3cb5fc9dab3705b415a67127a003c3e61eb445bb8df2"],"id":"1"}' -H "Content-Type: application/json" -X POST http://localhost:8545
</code></pre>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">Array</td><td style="text-align: left">Array of arrays of log objects, one array per transaction</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="erigon_getlogs"><a class="header" href="#erigon_getlogs"><strong>erigon_getLogs</strong></a></h2>
<p>Returns an array of logs matching a given filter object with enhanced filtering capabilities.</p>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Parameter</th><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">filter</td><td style="text-align: left">Object</td><td style="text-align: left">Filter criteria including fromBlock, toBlock, address, topics, and blockHash</td></tr>
</tbody></table>
</div>
<p><strong>Example</strong></p>
<pre><code class="language-bash">curl -s --data '{"jsonrpc":"2.0","method":"erigon_getLogs","params":[{"fromBlock":"0x1","toBlock":"0x2","address":"0x8888f1f195afa192cfee860698584c030f4c9db1"}],"id":"1"}' -H "Content-Type: application/json" -X POST http://localhost:8545
</code></pre>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">Array</td><td style="text-align: left">Array of ErigonLog objects with enhanced metadata</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="erigon_getlatestlogs"><a class="header" href="#erigon_getlatestlogs"><strong>erigon_getLatestLogs</strong></a></h2>
<p>Returns the latest logs matching a filter criteria in descending order with advanced pagination and topic matching options.</p>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Parameter</th><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">filter</td><td style="text-align: left">Object</td><td style="text-align: left">Filter criteria object</td></tr>
<tr><td style="text-align: left">logOptions</td><td style="text-align: left">Object</td><td style="text-align: left">Options including logCount, blockCount, and ignoreTopicsOrder</td></tr>
</tbody></table>
</div>
<p><strong>Example</strong></p>
<pre><code class="language-bash">curl -s --data '{"jsonrpc":"2.0","method":"erigon_getLatestLogs","params":[{"address":"0x8888f1f195afa192cfee860698584c030f4c9db1"},{"logCount":100,"ignoreTopicsOrder":true}],"id":"1"}' -H "Content-Type: application/json" -X POST http://localhost:8545
</code></pre>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">Array</td><td style="text-align: left">Array of ErigonLog objects in descending chronological order</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="erigon_getblockreceiptsbyblockhash"><a class="header" href="#erigon_getblockreceiptsbyblockhash"><strong>erigon_getBlockReceiptsByBlockHash</strong></a></h2>
<p>Returns all transaction receipts for a canonical block by block hash.</p>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Parameter</th><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">blockHash</td><td style="text-align: left">DATA, 32 BYTES</td><td style="text-align: left">Hash of the canonical block</td></tr>
</tbody></table>
</div>
<p><strong>Example</strong></p>
<pre><code class="language-bash">curl -s --data '{"jsonrpc":"2.0","method":"erigon_getBlockReceiptsByBlockHash","params":["0x1d59ff54b1eb26b013ce3cb5fc9dab3705b415a67127a003c3e61eb445bb8df2"],"id":"1"}' -H "Content-Type: application/json" -X POST http://localhost:8545
</code></pre>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">Array</td><td style="text-align: left">Array of receipt objects for all transactions in the block</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="erigon_nodeinfo"><a class="header" href="#erigon_nodeinfo"><strong>erigon_nodeInfo</strong></a></h2>
<p>Returns a collection of metadata known about the host node and connected peers.</p>
<p><strong>Parameters</strong></p>
<p>None</p>
<p><strong>Example</strong></p>
<pre><code class="language-bash">curl -s --data '{"jsonrpc":"2.0","method":"erigon_nodeInfo","params":[],"id":"1"}' -H "Content-Type: application/json" -X POST http://localhost:8545
</code></pre>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">Array</td><td style="text-align: left">Array of NodeInfo objects containing peer and node metadata</td></tr>
</tbody></table>
</div>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="web3-rpc-namespace"><a class="header" href="#web3-rpc-namespace"><code>web3</code> RPC Namespace</a></h1>
<h2 id="introduction-3"><a class="header" href="#introduction-3">Introduction</a></h2>
<p>The <code>web3</code> namespace provides utility methods that are part of the standard Ethereum JSON-RPC API. These methods offer basic functionality for client identification and cryptographic operations. In Erigon, the web3 namespace is implemented through the <code>Web3API</code> interface and <code>Web3APIImpl</code> struct.
The web3 namespace is enabled by default in Erigon's RPC daemon and provides essential utility functions that many Ethereum applications rely on for basic operations.</p>
<h3 id="implementation-details"><a class="header" href="#implementation-details">Implementation Details</a></h3>
<ul>
<li>The web3 namespace is implemented in <code>Web3APIImpl</code> which extends <code>BaseAPI</code> and uses the <code>ethBackend</code> for client version information</li>
<li>The <code>web3_sha3</code> method uses Erigon's crypto library implementation of Keccak-256, which is the same hashing algorithm used throughout Ethereum</li>
<li>Both methods are lightweight utility functions that don't require complex blockchain state access</li>
</ul>
<h3 id="usage-considerations"><a class="header" href="#usage-considerations">Usage Considerations</a></h3>
<ul>
<li><code>web3_clientVersion</code> is often used by applications to identify the Ethereum client type and version for compatibility checks</li>
<li><code>web3_sha3</code> provides the same Keccak-256 hashing that's used for Ethereum addresses, transaction hashes, and other cryptographic operations in the protocol</li>
<li>These methods are part of the core Ethereum JSON-RPC specification and are supported by all major Ethereum clients</li>
</ul>
<h3 id="availability"><a class="header" href="#availability">Availability</a></h3>
<ul>
<li>The web3 namespace is enabled by default in Erigon's RPC daemon</li>
<li>No special configuration is required to use these methods</li>
<li>They are available on both HTTP and WebSocket connections</li>
</ul>
<hr />
<h2 id="web3_clientversion"><a class="header" href="#web3_clientversion"><strong>web3_clientVersion</strong></a></h2>
<p>Returns the current client version string, including the node name and version information.</p>
<p><strong>Parameters</strong></p>
<p>None</p>
<p><strong>Example</strong></p>
<pre><code class="language-bash">curl -s --data '{"jsonrpc":"2.0","method":"web3_clientVersion","params":[],"id":"1"}' -H "Content-Type: application/json" -X POST http://localhost:8545
</code></pre>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">STRING</td><td style="text-align: left">The current client version string including node name and version</td></tr>
</tbody></table>
</div>
<p><cite>rpc/jsonrpc/web3_api.go:47-50</cite></p>
<hr />
<h2 id="web3_sha3"><a class="header" href="#web3_sha3"><strong>web3_sha3</strong></a></h2>
<p>Returns Keccak-256 (not the standardized SHA3-256) of the given data. This method is commonly used for hashing arbitrary data using the same algorithm that Ethereum uses internally.</p>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Parameter</th><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">data</td><td style="text-align: left">DATA</td><td style="text-align: left">The data to convert into a SHA3 hash</td></tr>
</tbody></table>
</div>
<p><strong>Example</strong></p>
<pre><code class="language-bash">curl -s --data '{"jsonrpc":"2.0","method":"web3_sha3","params":["0x68656c6c6f20776f726c64"],"id":"1"}' -H "Content-Type: application/json" -X POST http://localhost:8545
</code></pre>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">DATA</td><td style="text-align: left">The SHA3 result of the given input string</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="net-rpc-namespace"><a class="header" href="#net-rpc-namespace"><code>net</code> RPC Namespace</a></h1>
<h2 id="introduction-4"><a class="header" href="#introduction-4">Introduction</a></h2>
<p>The <code>net</code> namespace provides network-related methods that are part of the standard Ethereum JSON-RPC API. These methods offer information about the node's network connectivity, peer count, and network version. In Erigon, the net namespace is implemented through the <code>NetAPI</code> interface and <code>NetAPIImpl</code> struct.</p>
<p>The <code>net</code> namespace is enabled by default in Erigon's RPC daemon and provides essential network information that applications use to understand the node's connectivity status and network configuration.</p>
<h3 id="implementation-details-1"><a class="header" href="#implementation-details-1">Implementation Details</a></h3>
<ul>
<li>The net namespace is implemented in <code>NetAPIImpl</code> which uses the <code>ethBackend</code> to access network information</li>
<li><code>net_listening</code> determines connectivity by attempting to retrieve peer information from the backend</li>
<li><code>net_version</code> and <code>net_peerCount</code> require access to the backend and will return errors in <code>--datadir</code> mode when the backend is unavailable</li>
</ul>
<h3 id="backend-dependency"><a class="header" href="#backend-dependency">Backend Dependency</a></h3>
<ul>
<li>Methods <code>net_version</code> and <code>net_peerCount</code> require the <code>ethBackend</code> to be available</li>
<li>When running in <code>--datadir</code> mode or when the backend cannot be accessed, these methods will return a "not available" error</li>
<li>The <code>net_listening</code> method gracefully handles backend unavailability by returning <code>false</code></li>
</ul>
<h3 id="network-information-usage"><a class="header" href="#network-information-usage">Network Information Usage</a></h3>
<ul>
<li><code>net_version</code> is commonly used by applications to verify they're connected to the correct Ethereum network</li>
<li><code>net_peerCount</code> helps monitor node connectivity and network health</li>
<li><code>net_listening</code> provides a basic connectivity check for the node's network interface</li>
</ul>
<h3 id="availability-and-configuration"><a class="header" href="#availability-and-configuration">Availability and Configuration</a></h3>
<ul>
<li>The net namespace is enabled by default in Erigon's RPC daemon</li>
<li>These methods are available on both HTTP and WebSocket connections</li>
<li>For remote RPC daemon setups, the <code>net</code> namespace must be explicitly enabled for health check functionality</li>
</ul>
<h3 id="documentation-references"><a class="header" href="#documentation-references">Documentation References</a></h3>
<ul>
<li>The current implementation shows some limitations noted in the documentation, such as hardcoded return values in certain scenarios</li>
<li><code>net_peerCount</code> specifically counts only internal sentries, which may not reflect the total peer count in distributed setups</li>
</ul>
<hr />
<h2 id="net_listening"><a class="header" href="#net_listening"><strong>net_listening</strong></a></h2>
<p>Returns <code>true</code> if the client is actively listening for network connections. The method checks if the node can retrieve peer information, indicating that the network interface is up and listening.</p>
<p><strong>Parameters</strong></p>
<p>None</p>
<p><strong>Example</strong></p>
<pre><code class="language-bash">curl -s --data '{"jsonrpc":"2.0","method":"net_listening","params":[],"id":"1"}' -H "Content-Type: application/json" -X POST http://localhost:8545
</code></pre>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">Boolean</td><td style="text-align: left"><code>true</code> when listening, <code>false</code> otherwise</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="net_version"><a class="header" href="#net_version"><strong>net_version</strong></a></h2>
<p>Returns the current network ID as a string. This identifies which Ethereum network the node is connected to (e.g., "1" for Mainnet, "11155111" for Sepolia).</p>
<p><strong>Parameters</strong></p>
<p>None</p>
<p><strong>Example</strong></p>
<pre><code class="language-bash">curl -s --data '{"jsonrpc":"2.0","method":"net_version","params":[],"id":"1"}' -H "Content-Type: application/json" -X POST http://localhost:8545
</code></pre>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">STRING</td><td style="text-align: left">The current network ID (e.g., "1" for Ethereum Mainnet, "11155111" for Sepolia Testnet)</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="net_peercount"><a class="header" href="#net_peercount"><strong>net_peerCount</strong></a></h2>
<p>Returns the number of peers currently connected to the first sentry server. This provides insight into the node's network connectivity and peer relationships.</p>
<p><strong>Parameters</strong></p>
<p>None</p>
<p><strong>Example</strong></p>
<pre><code class="language-bash">curl -s --data '{"jsonrpc":"2.0","method":"net_peerCount","params":[],"id":"1"}' -H "Content-Type: application/json" -X POST http://localhost:8545
</code></pre>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">QUANTITY</td><td style="text-align: left">Number of connected peers as hexadecimal</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="debug-rpc-namespace"><a class="header" href="#debug-rpc-namespace"><code>debug</code> RPC Namespace</a></h1>
<h2 id="introduction-5"><a class="header" href="#introduction-5">Introduction</a></h2>
<p>The <code>debug</code> namespace provides debugging and diagnostic methods for Erigon node operators and developers. These methods offer deep introspection into blockchain state, transaction execution, and node performance. The debug namespace is implemented through the <code>PrivateDebugAPI</code> interface and <code>DebugAPIImpl</code> struct.</p>
<p>The debug namespace must be explicitly enabled using the <code>--http.api</code> flag when starting the RPC daemon. For security reasons, these methods are considered private and should not be exposed on public RPC endpoints.</p>
<h3 id="security-and-access-control"><a class="header" href="#security-and-access-control">Security and Access Control</a></h3>
<ul>
<li>Debug methods are considered private and should not be exposed on public RPC endpoints</li>
<li>These methods can consume significant resources and should be used carefully in production environments</li>
<li>Access should be restricted to trusted operators and developers only</li>
</ul>
<h3 id="performance-considerations-1"><a class="header" href="#performance-considerations-1">Performance Considerations</a></h3>
<ul>
<li>Tracing methods (<code>debug_traceTransaction</code>, <code>debug_traceBlockByHash</code>, etc.) support streaming to handle large results efficiently</li>
<li>The <code>AccountRangeMaxResults</code> constant limits account range queries to 8192 results, or 256 when storage is included</li>
<li>Memory and GC control methods allow fine-tuning of node performance</li>
</ul>
<h3 id="integration-with-erigon-architecture"><a class="header" href="#integration-with-erigon-architecture">Integration with Erigon Architecture</a></h3>
<ul>
<li>Debug methods leverage Erigon's temporal database for historical state access</li>
<li>The implementation uses <code>kv.TemporalRoDB</code> for efficient historical queries</li>
<li>Tracing functionality integrates with Erigon's execution engine and EVM implementation</li>
</ul>
<h3 id="usage-in-development-and-testing"><a class="header" href="#usage-in-development-and-testing">Usage in Development and Testing</a></h3>
<ul>
<li>These methods are essential for debugging transaction execution issues</li>
<li>Storage range methods help analyze contract state changes</li>
<li>Memory management methods assist in performance optimization and resource monitoring</li>
</ul>
<hr />
<h2 id="debug_storagerangeat"><a class="header" href="#debug_storagerangeat"><strong>debug_storageRangeAt</strong></a></h2>
<p>Returns information about a range of storage locations for a given address at a specific block and transaction index.</p>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Parameter</th><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">blockHash</td><td style="text-align: left">DATA, 32 BYTES</td><td style="text-align: left">Hash of block at which to retrieve data</td></tr>
<tr><td style="text-align: left">txIndex</td><td style="text-align: left">QUANTITY</td><td style="text-align: left">Transaction index in the given block</td></tr>
<tr><td style="text-align: left">contractAddress</td><td style="text-align: left">DATA, 20 BYTES</td><td style="text-align: left">Contract address from which to retrieve storage data</td></tr>
<tr><td style="text-align: left">keyStart</td><td style="text-align: left">DATA, 32 BYTES</td><td style="text-align: left">Storage key to start retrieval from</td></tr>
<tr><td style="text-align: left">maxResult</td><td style="text-align: left">QUANTITY</td><td style="text-align: left">The maximum number of storage entries to retrieve</td></tr>
</tbody></table>
</div>
<p><strong>Example</strong></p>
<pre><code class="language-bash">curl -s --data '{"jsonrpc":"2.0","method":"debug_storageRangeAt","params":["0xd3f1853788b02e31067f2c6e65cb0ae56729e23e3c92e2393af9396fa182701d",1,"0xb734c74ff4087493373a27834074f80acbd32827","0x00",2],"id":"1"}' -H "Content-Type: application/json" -X POST http://localhost:8545
</code></pre>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">Object</td><td style="text-align: left">StorageRangeResult object containing storage key-value pairs and nextKey</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="debug_accountrange"><a class="header" href="#debug_accountrange"><strong>debug_accountRange</strong></a></h2>
<p>Returns a range of accounts involved in the given block range with optional filtering and data inclusion controls.</p>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Parameter</th><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">blockNrOrHash</td><td style="text-align: left">QUANTITY|TAG|HASH</td><td style="text-align: left">Block number, tag, or block hash</td></tr>
<tr><td style="text-align: left">start</td><td style="text-align: left">DATA</td><td style="text-align: left">Starting point for account iteration</td></tr>
<tr><td style="text-align: left">maxResults</td><td style="text-align: left">QUANTITY</td><td style="text-align: left">Maximum number of accounts to retrieve</td></tr>
<tr><td style="text-align: left">nocode</td><td style="text-align: left">Boolean</td><td style="text-align: left">If true, exclude contract bytecode from results</td></tr>
<tr><td style="text-align: left">nostorage</td><td style="text-align: left">Boolean</td><td style="text-align: left">If true, exclude account storage from results</td></tr>
<tr><td style="text-align: left">nopreimages</td><td style="text-align: left">Boolean</td><td style="text-align: left">If true, exclude missing preimages from results</td></tr>
</tbody></table>
</div>
<p><strong>Example</strong></p>
<pre><code class="language-bash">curl -s --data '{"jsonrpc":"2.0","method":"debug_accountRange","params":["latest","0x00",100,true,true,true],"id":"1"}' -H "Content-Type: application/json" -X POST http://localhost:8545
</code></pre>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">Object</td><td style="text-align: left">IteratorDump object containing account information and iteration state</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="debug_getmodifiedaccountsbynumber"><a class="header" href="#debug_getmodifiedaccountsbynumber"><strong>debug_getModifiedAccountsByNumber</strong></a></h2>
<p>Returns a list of accounts modified in the given block range specified by block numbers.</p>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Parameter</th><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">startNum</td><td style="text-align: left">QUANTITY|TAG</td><td style="text-align: left">Starting block number or tag</td></tr>
<tr><td style="text-align: left">endNum</td><td style="text-align: left">QUANTITY|TAG</td><td style="text-align: left">Ending block number or tag (optional, defaults to startNum)</td></tr>
</tbody></table>
</div>
<p><strong>Example</strong></p>
<pre><code class="language-bash">curl -s --data '{"jsonrpc":"2.0","method":"debug_getModifiedAccountsByNumber","params":["0x1b4","0x1b5"],"id":"1"}' -H "Content-Type: application/json" -X POST http://localhost:8545
</code></pre>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">Array</td><td style="text-align: left">Array of addresses modified in the given block range</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="debug_getmodifiedaccountsbyhash"><a class="header" href="#debug_getmodifiedaccountsbyhash"><strong>debug_getModifiedAccountsByHash</strong></a></h2>
<p>Returns a list of accounts modified in the given block range specified by block hashes.</p>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Parameter</th><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">startHash</td><td style="text-align: left">DATA, 32 BYTES</td><td style="text-align: left">Starting block hash</td></tr>
<tr><td style="text-align: left">endHash</td><td style="text-align: left">DATA, 32 BYTES</td><td style="text-align: left">Ending block hash (optional, defaults to startHash)</td></tr>
</tbody></table>
</div>
<p><strong>Example</strong></p>
<pre><code class="language-bash">curl -s --data '{"jsonrpc":"2.0","method":"debug_getModifiedAccountsByHash","params":["0x2a1af018e33bcbd5015c96a356117a5251fcccf94a9c7c8f0148e25fdee37aec","0x4e3d3e7eee350df0ee6e94a44471ee2d22cfb174db89bbf8e6c5f6aef7b360c5"],"id":"1"}' -H "Content-Type: application/json" -X POST http://localhost:8545
</code></pre>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">Array</td><td style="text-align: left">Array of addresses modified in the given block range</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="debug_tracetransaction"><a class="header" href="#debug_tracetransaction"><strong>debug_traceTransaction</strong></a></h2>
<p>Returns Geth-style transaction traces for detailed execution analysis of a specific transaction.</p>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Parameter</th><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">hash</td><td style="text-align: left">DATA, 32 BYTES</td><td style="text-align: left">Hash of transaction to trace</td></tr>
<tr><td style="text-align: left">config</td><td style="text-align: left">Object</td><td style="text-align: left">(optional) Tracer configuration options</td></tr>
</tbody></table>
</div>
<p><strong>Example</strong></p>
<pre><code class="language-bash">curl -s --data '{"jsonrpc":"2.0","method":"debug_traceTransaction","params":["0x893c428fed019404f704cf4d9be977ed9ca01050ed93dccdd6c169422155586f"],"id":"1"}' -H "Content-Type: application/json" -X POST http://localhost:8545
</code></pre>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">Object</td><td style="text-align: left">Stack trace array with detailed execution steps</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="debug_traceblockbyhash"><a class="header" href="#debug_traceblockbyhash"><strong>debug_traceBlockByHash</strong></a></h2>
<p>Returns transaction traces for all transactions in a block specified by block hash.</p>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Parameter</th><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">hash</td><td style="text-align: left">DATA, 32 BYTES</td><td style="text-align: left">Hash of the block to trace</td></tr>
<tr><td style="text-align: left">config</td><td style="text-align: left">Object</td><td style="text-align: left">(optional) Tracer configuration options</td></tr>
</tbody></table>
</div>
<p><strong>Example</strong></p>
<pre><code class="language-bash">curl -s --data '{"jsonrpc":"2.0","method":"debug_traceBlockByHash","params":["0x1d59ff54b1eb26b013ce3cb5fc9dab3705b415a67127a003c3e61eb445bb8df2"],"id":"1"}' -H "Content-Type: application/json" -X POST http://localhost:8545
</code></pre>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">Array</td><td style="text-align: left">Array of transaction trace objects for all transactions in the block</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="debug_traceblockbynumber"><a class="header" href="#debug_traceblockbynumber"><strong>debug_traceBlockByNumber</strong></a></h2>
<p>Returns transaction traces for all transactions in a block specified by block number.</p>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Parameter</th><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">number</td><td style="text-align: left">QUANTITY|TAG</td><td style="text-align: left">Block number or "latest", "earliest", "pending"</td></tr>
<tr><td style="text-align: left">config</td><td style="text-align: left">Object</td><td style="text-align: left">(optional) Tracer configuration options</td></tr>
</tbody></table>
</div>
<p><strong>Example</strong></p>
<pre><code class="language-bash">curl -s --data '{"jsonrpc":"2.0","method":"debug_traceBlockByNumber","params":["0x1b4"],"id":"1"}' -H "Content-Type: application/json" -X POST http://localhost:8545
</code></pre>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">Array</td><td style="text-align: left">Array of transaction trace objects for all transactions in the block</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="debug_tracecall"><a class="header" href="#debug_tracecall"><strong>debug_traceCall</strong></a></h2>
<p>Executes a call and returns detailed execution traces without modifying the blockchain state.</p>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Parameter</th><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">call</td><td style="text-align: left">Object</td><td style="text-align: left">Call arguments (similar to eth_call)</td></tr>
<tr><td style="text-align: left">blockNrOrHash</td><td style="text-align: left">QUANTITY|TAG|HASH</td><td style="text-align: left">Block number, tag, or hash for execution context</td></tr>
<tr><td style="text-align: left">config</td><td style="text-align: left">Object</td><td style="text-align: left">(optional) Tracer configuration options</td></tr>
</tbody></table>
</div>
<p><strong>Example</strong></p>
<pre><code class="language-bash">curl -s --data '{"jsonrpc":"2.0","method":"debug_traceCall","params":[{"to":"0xd46e8dd67c5d32be8058bb8eb970870f07244567","data":"0x"},"latest"],"id":"1"}' -H "Content-Type: application/json" -X POST http://localhost:8545
</code></pre>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">Object</td><td style="text-align: left">Execution trace object with detailed call information</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="debug_getrawreceipts"><a class="header" href="#debug_getrawreceipts"><strong>debug_getRawReceipts</strong></a></h2>
<p>Returns the raw receipt data for all transactions in a block.</p>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Parameter</th><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">blockNrOrHash</td><td style="text-align: left">QUANTITY|TAG|HASH</td><td style="text-align: left">Block number, tag, or block hash</td></tr>
</tbody></table>
</div>
<p><strong>Example</strong></p>
<pre><code class="language-bash">curl -s --data '{"jsonrpc":"2.0","method":"debug_getRawReceipts","params":["0x1b4"],"id":"1"}' -H "Content-Type: application/json" -X POST http://localhost:8545
</code></pre>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">Array</td><td style="text-align: left">Array of raw receipt data as hexadecimal bytes</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="debug_memstats"><a class="header" href="#debug_memstats"><strong>debug_memStats</strong></a></h2>
<p>Returns detailed runtime memory statistics for the Erigon process.</p>
<p><strong>Parameters</strong></p>
<p>None</p>
<p><strong>Example</strong></p>
<pre><code class="language-bash">curl -s --data '{"jsonrpc":"2.0","method":"debug_memStats","params":[],"id":"1"}' -H "Content-Type: application/json" -X POST http://localhost:8545
</code></pre>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">Object</td><td style="text-align: left">Runtime memory statistics object with detailed memory usage information</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="debug_gcstats"><a class="header" href="#debug_gcstats"><strong>debug_gcStats</strong></a></h2>
<p>Returns garbage collection statistics for the Erigon process.</p>
<p><strong>Parameters</strong></p>
<p>None</p>
<p><strong>Example</strong></p>
<pre><code class="language-bash">curl -s --data '{"jsonrpc":"2.0","method":"debug_gcStats","params":[],"id":"1"}' -H "Content-Type: application/json" -X POST http://localhost:8545
</code></pre>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">Object</td><td style="text-align: left">Garbage collection statistics object</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="debug_freeosmemory"><a class="header" href="#debug_freeosmemory"><strong>debug_freeOSMemory</strong></a></h2>
<p>Forces a garbage collection to free OS memory.</p>
<p><strong>Parameters</strong></p>
<p>None</p>
<p><strong>Example</strong></p>
<pre><code class="language-bash">curl -s --data '{"jsonrpc":"2.0","method":"debug_freeOSMemory","params":[],"id":"1"}' -H "Content-Type: application/json" -X POST http://localhost:8545
</code></pre>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">null</td><td style="text-align: left">No return value</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="debug_setgcpercent"><a class="header" href="#debug_setgcpercent"><strong>debug_setGCPercent</strong></a></h2>
<p>Sets the garbage collection target percentage and returns the previous setting.</p>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Parameter</th><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">percent</td><td style="text-align: left">QUANTITY</td><td style="text-align: left">GC target percentage (negative value disables GC)</td></tr>
</tbody></table>
</div>
<p><strong>Example</strong></p>
<pre><code class="language-bash">curl -s --data '{"jsonrpc":"2.0","method":"debug_setGCPercent","params":[100],"id":"1"}' -H "Content-Type: application/json" -X POST http://localhost:8545
</code></pre>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">QUANTITY</td><td style="text-align: left">The previous GC percentage setting</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="debug_setmemorylimit"><a class="header" href="#debug_setmemorylimit"><strong>debug_setMemoryLimit</strong></a></h2>
<p>Sets the GOMEMLIMIT for the process and returns the previous limit.</p>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Parameter</th><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">limit</td><td style="text-align: left">QUANTITY</td><td style="text-align: left">Memory limit in bytes</td></tr>
</tbody></table>
</div>
<p><strong>Example</strong></p>
<pre><code class="language-bash">curl -s --data '{"jsonrpc":"2.0","method":"debug_setMemoryLimit","params":[1073741824],"id":"1"}' -H "Content-Type: application/json" -X POST http://localhost:8545
</code></pre>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">QUANTITY</td><td style="text-align: left">The previous memory limit setting</td></tr>
</tbody></table>
</div>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="trace-rpc-namespace"><a class="header" href="#trace-rpc-namespace"><code>trace</code> RPC Namespace</a></h1>
<p>The <code>trace</code> module is for getting a deeper insight into transaction processing.
It includes two sets of calls the transaction trace filtering API and the ad-hoc tracing API.</p>
<p>In order to use the Transaction-Trace Filtering API, Erigon must be fully synced with the argument <code>trace</code> in <code>http.api</code> flag.</p>
<pre><code class="language-bash">./build/bin/erigon --http.api: eth,erigon,trace
</code></pre>
<p>As for the Ad-hoc Tracing API, as long the blocks have not yet been pruned, the RPC calls will work.</p>
<h2 id="the-ad-hoc-tracing-api"><a class="header" href="#the-ad-hoc-tracing-api">The Ad-hoc Tracing API</a></h2>
<p>The ad-hoc tracing API allows you to perform a number of different diagnostics on calls or transactions,
either historical ones from the chain or hypothetical ones not yet mined. The diagnostics include:</p>
<ul>
<li><code>trace</code> <strong>Transaction trace</strong>. An equivalent trace to that in the previous section.</li>
<li><code>vmTrace</code> <strong>Virtual Machine execution trace</strong>. Provides a full trace of the VM's state throughout the execution of the transaction, including for any subcalls.</li>
<li><code>stateDiff</code> <strong>State difference</strong>. Provides information detailing all altered portions of the Ethereum state made due to the execution of the transaction.</li>
</ul>
<p>There are three means of providing a transaction to execute; either providing the same information as when making
a call using <code>eth_call</code> (see <code>trace_call</code>), through providing raw, signed, transaction data as when using
<code>eth_sendRawTransaction</code> (see <code>trace_rawTransaction</code>) or simply a transaction hash for a previously mined
transaction (see <code>trace_replayTransaction</code>). In the latter case, your node must be in archive mode or the
transaction should be within the most recent 1000 blocks.</p>
<h2 id="the-transaction-trace-filtering-api"><a class="header" href="#the-transaction-trace-filtering-api">The Transaction-Trace Filtering API</a></h2>
<p>These APIs allow you to get a full <em>externality</em> trace on any transaction executed throughout the Erigon chain.
Unlike the log filtering API, you are able to search and filter based only upon address information.
Information returned includes the execution of all <code>CREATE</code>s, <code>SUICIDE</code>s and all variants of <code>CALL</code> together
with input data, output data, gas usage, amount transferred and the success status of each individual action.</p>
<h3 id="traceaddress-field"><a class="header" href="#traceaddress-field"><code>traceAddress</code> field</a></h3>
<p>The <code>traceAddress</code> field of all returned traces, gives the exact location in the call trace [index in root,
index in first <code>CALL</code>, index in second <code>CALL</code>, ...].</p>
<p>i.e. if the trace is:</p>
<pre><code>A
  CALLs B
    CALLs G
  CALLs C
    CALLs G
</code></pre>
<p>then it should look something like:</p>
<p><code>[ {A: []}, {B: [0]}, {G: [0, 0]}, {C: [1]}, {G: [1, 0]} ]</code></p>
<h2 id="json-rpc-methods"><a class="header" href="#json-rpc-methods">JSON-RPC methods</a></h2>
<h4 id="ad-hoc-tracing"><a class="header" href="#ad-hoc-tracing">Ad-hoc Tracing</a></h4>
<ul>
<li><a href="interacting-with-erigon/trace.html#trace_call">trace_call</a></li>
<li><a href="interacting-with-erigon/trace.html#trace_callmany">trace_callMany</a></li>
<li><a href="interacting-with-erigon/trace.html#trace_rawtransaction">trace_rawTransaction</a></li>
<li><a href="interacting-with-erigon/trace.html#trace_replayblocktransactions">trace_replayBlockTransactions</a></li>
<li><a href="interacting-with-erigon/trace.html#trace_replaytransaction">trace_replayTransaction</a></li>
</ul>
<h4 id="transaction-trace-filtering"><a class="header" href="#transaction-trace-filtering">Transaction-Trace Filtering</a></h4>
<ul>
<li><a href="interacting-with-erigon/trace.html#trace_block">trace_block</a></li>
<li><a href="interacting-with-erigon/trace.html#trace_filter">trace_filter</a></li>
<li><a href="interacting-with-erigon/trace.html#trace_get">trace_get</a></li>
<li><a href="interacting-with-erigon/trace.html#trace_transaction">trace_transaction</a></li>
</ul>
<h2 id="json-rpc-api-reference"><a class="header" href="#json-rpc-api-reference">JSON-RPC API Reference</a></h2>
<h3 id="trace_call"><a class="header" href="#trace_call">trace_call</a></h3>
<p>Executes the given call and returns a number of possible traces for it.</p>
<h4 id="parameters"><a class="header" href="#parameters">Parameters</a></h4>
<ol start="0">
<li><code>Object</code> - [Transaction object] where <code>from</code> field is optional and <code>nonce</code> field is omitted.</li>
<li><code>Array</code> - Type of trace, one or more of: <code>"vmTrace"</code>, <code>"trace"</code>, <code>"stateDiff"</code>.</li>
<li><code>Quantity</code> or <code>Tag</code> - (optional) Integer of a block number, or the string <code>'earliest'</code>, <code>'latest'</code> or <code>'pending'</code>.</li>
</ol>
<h4 id="returns"><a class="header" href="#returns">Returns</a></h4>
<ul>
<li><code>Array</code> - Block traces</li>
</ul>
<h4 id="example-1"><a class="header" href="#example-1">Example</a></h4>
<p>Request</p>
<pre><code class="language-bash">curl --data '{"method":"trace_call","params":[{ ... },["trace"]],"id":1,"jsonrpc":"2.0"}' -H "Content-Type: application/json" -X POST localhost:8545
</code></pre>
<p>Response</p>
<pre><code class="language-js">{
  "id": 1,
  "jsonrpc": "2.0",
  "result": {
    "output": "0x",
    "stateDiff": null,
    "trace": [{
      "action": { ... },
      "result": {
        "gasUsed": "0x0",
        "output": "0x"
      },
      "subtraces": 0,
      "traceAddress": [],
      "type": "call"
    }],
    "vmTrace": null
  }
}
</code></pre>
<hr />
<h3 id="trace_callmany"><a class="header" href="#trace_callmany">trace_callMany</a></h3>
<p>Performs multiple call traces on top of the same block. i.e. transaction <code>n</code> will be executed on top of a pending block with all <code>n-1</code> transactions applied (traced) first. Allows to trace dependent transactions.</p>
<h4 id="parameters-1"><a class="header" href="#parameters-1">Parameters</a></h4>
<ol start="0">
<li><code>Array</code> - List of trace calls with the type of trace, one or more of: <code>"vmTrace"</code>, <code>"trace"</code>, <code>"stateDiff"</code>.</li>
<li><code>Quantity</code> or <code>Tag</code> - (optional) integer block number, or the string <code>'latest'</code>, <code>'earliest'</code> or <code>'pending'</code>, see the <a href="interacting-with-erigon/trace.html#the-default-block-parameter">default block parameter</a>.</li>
</ol>
<pre><code class="language-js">params: [
  [
    [
      {
        "from": "0x407d73d8a49eeb85d32cf465507dd71d507100c1",
        "to": "0xa94f5374fce5edbc8e2a8697c15331677e6ebf0b",
        "value": "0x186a0"
      },
      ["trace"]
    ],
    [
      {
        "from": "0x407d73d8a49eeb85d32cf465507dd71d507100c1",
        "to": "0xa94f5374fce5edbc8e2a8697c15331677e6ebf0b",
        "value": "0x186a0"
      },
      ["trace"]
    ]
  ],
  "latest"
]
</code></pre>
<h4 id="returns-1"><a class="header" href="#returns-1">Returns</a></h4>
<ul>
<li><code>Array</code> - Array of the given transactions' traces</li>
</ul>
<h4 id="example-2"><a class="header" href="#example-2">Example</a></h4>
<p>Request</p>
<pre><code class="language-bash">curl --data '{"method":"trace_callMany","params":[[[{"from":"0x407d73d8a49eeb85d32cf465507dd71d507100c1","to":"0xa94f5374fce5edbc8e2a8697c15331677e6ebf0b","value":"0x186a0"},["trace"]],[{"from":"0x407d73d8a49eeb85d32cf465507dd71d507100c1","to":"0xa94f5374fce5edbc8e2a8697c15331677e6ebf0b","value":"0x186a0"},["trace"]]],"latest"],"id":1,"jsonrpc":"2.0"}' -H "Content-Type: application/json" -X POST localhost:8545
</code></pre>
<p>Response</p>
<pre><code class="language-js">{
  "id": 1,
  "jsonrpc": "2.0",
  "result": [
    {
      "output": "0x",
      "stateDiff": null,
      "trace": [{
        "action": {
          "callType": "call",
          "from": "0x407d73d8a49eeb85d32cf465507dd71d507100c1",
          "gas": "0x1dcd12f8",
          "input": "0x",
          "to": "0xa94f5374fce5edbc8e2a8697c15331677e6ebf0b",
          "value": "0x186a0"
        },
        "result": {
          "gasUsed": "0x0",
          "output": "0x"
        },
        "subtraces": 0,
        "traceAddress": [],
        "type": "call"
      }],
      "vmTrace": null
    },
    {
      "output": "0x",
      "stateDiff": null,
      "trace": [{
        "action": {
          "callType": "call",
          "from": "0x407d73d8a49eeb85d32cf465507dd71d507100c1",
          "gas": "0x1dcd12f8",
          "input": "0x",
          "to": "0xa94f5374fce5edbc8e2a8697c15331677e6ebf0b",
          "value": "0x186a0"
        },
        "result": {
          "gasUsed": "0x0",
          "output": "0x"
        },
        "subtraces": 0,
        "traceAddress": [],
        "type": "call"
      }],
      "vmTrace": null
    }
  ]
}
</code></pre>
<hr />
<h3 id="trace_rawtransaction"><a class="header" href="#trace_rawtransaction">trace_rawTransaction</a></h3>
<p>Traces a call to <code>eth_sendRawTransaction</code> without making the call, returning the traces</p>
<h4 id="parameters-2"><a class="header" href="#parameters-2">Parameters</a></h4>
<ol start="0">
<li><code>Data</code> - Raw transaction data.</li>
<li><code>Array</code> - Type of trace, one or more of: <code>"vmTrace"</code>, <code>"trace"</code>, <code>"stateDiff"</code>.</li>
</ol>
<pre><code class="language-js">params: [
  "0xd46e8dd67c5d32be8d46e8dd67c5d32be8058bb8eb970870f072445675058bb8eb970870f072445675",
  ["trace"]
]
</code></pre>
<h4 id="returns-2"><a class="header" href="#returns-2">Returns</a></h4>
<ul>
<li><code>Object</code> - Block traces.</li>
</ul>
<h4 id="example-3"><a class="header" href="#example-3">Example</a></h4>
<p>Request</p>
<pre><code class="language-bash">curl --data '{"method":"trace_rawTransaction","params":["0xd46e8dd67c5d32be8d46e8dd67c5d32be8058bb8eb970870f072445675058bb8eb970870f072445675",["trace"]],"id":1,"jsonrpc":"2.0"}' -H "Content-Type: application/json" -X POST localhost:8545
</code></pre>
<p>Response</p>
<pre><code class="language-js">{
  "id": 1,
  "jsonrpc": "2.0",
  "result": {
    "output": "0x",
    "stateDiff": null,
    "trace": [{
      "action": { ... },
      "result": {
        "gasUsed": "0x0",
        "output": "0x"
      },
      "subtraces": 0,
      "traceAddress": [],
      "type": "call"
    }],
    "vmTrace": null
  }
}
</code></pre>
<hr />
<h3 id="trace_replayblocktransactions"><a class="header" href="#trace_replayblocktransactions">trace_replayBlockTransactions</a></h3>
<p>Replays all transactions in a block returning the requested traces for each transaction.</p>
<h4 id="parameters-3"><a class="header" href="#parameters-3">Parameters</a></h4>
<ol start="0">
<li><code>Quantity</code> or <code>Tag</code> - Integer of a block number, or the string <code>'earliest'</code>, <code>'latest'</code> or <code>'pending'</code>.</li>
<li><code>Array</code> - Type of trace, one or more of: <code>"vmTrace"</code>, <code>"trace"</code>, <code>"stateDiff"</code>.</li>
</ol>
<pre><code class="language-js">params: [
  "0x2ed119",
  ["trace"]
]
</code></pre>
<h4 id="returns-3"><a class="header" href="#returns-3">Returns</a></h4>
<ul>
<li><code>Array</code> - Block transactions traces.</li>
</ul>
<h4 id="example-4"><a class="header" href="#example-4">Example</a></h4>
<p>Request</p>
<pre><code class="language-bash">curl --data '{"method":"trace_replayBlockTransactions","params":["0x2ed119",["trace"]],"id":1,"jsonrpc":"2.0"}' -H "Content-Type: application/json" -X POST localhost:8545
</code></pre>
<p>Response</p>
<pre><code class="language-js">{
  "id": 1,
  "jsonrpc": "2.0",
  "result": [
    {
      "output": "0x",
      "stateDiff": null,
      "trace": [{
        "action": { ... },
        "result": {
          "gasUsed": "0x0",
          "output": "0x"
        },
        "subtraces": 0,
        "traceAddress": [],
        "type": "call"
      }],
      "transactionHash": "0x...",
      "vmTrace": null
    },
    { ... }
  ]
}
</code></pre>
<hr />
<h3 id="trace_replaytransaction"><a class="header" href="#trace_replaytransaction">trace_replayTransaction</a></h3>
<p>Replays a transaction, returning the traces.</p>
<h4 id="parameters-4"><a class="header" href="#parameters-4">Parameters</a></h4>
<ol start="0">
<li><code>Hash</code> - Transaction hash.</li>
<li><code>Array</code> - Type of trace, one or more of: <code>"vmTrace"</code>, <code>"trace"</code>, <code>"stateDiff"</code>.</li>
</ol>
<pre><code class="language-js">params: [
  "0x02d4a872e096445e80d05276ee756cefef7f3b376bcec14246469c0cd97dad8f",
  ["trace"]
]
</code></pre>
<h4 id="returns-4"><a class="header" href="#returns-4">Returns</a></h4>
<ul>
<li><code>Object</code> - Block traces.</li>
</ul>
<h4 id="example-5"><a class="header" href="#example-5">Example</a></h4>
<p>Request</p>
<pre><code class="language-bash">curl --data '{"method":"trace_replayTransaction","params":["0x02d4a872e096445e80d05276ee756cefef7f3b376bcec14246469c0cd97dad8f",["trace"]],"id":1,"jsonrpc":"2.0"}' -H "Content-Type: application/json" -X POST localhost:8545
</code></pre>
<p>Response</p>
<pre><code class="language-js">{
  "id": 1,
  "jsonrpc": "2.0",
  "result": {
    "output": "0x",
    "stateDiff": null,
    "trace": [{
      "action": { ... },
      "result": {
        "gasUsed": "0x0",
        "output": "0x"
      },
      "subtraces": 0,
      "traceAddress": [],
      "type": "call"
    }],
    "vmTrace": null
  }
}
</code></pre>
<hr />
<h3 id="trace_block"><a class="header" href="#trace_block">trace_block</a></h3>
<p>Returns traces created at given block.</p>
<h4 id="parameters-5"><a class="header" href="#parameters-5">Parameters</a></h4>
<ol start="0">
<li><code>Quantity</code> or <code>Tag</code> - Integer of a block number, or the string <code>'earliest'</code>, <code>'latest'</code> or <code>'pending'</code>.</li>
</ol>
<pre><code class="language-js">params: [
  "0x2ed119" // 3068185
]
</code></pre>
<h4 id="returns-5"><a class="header" href="#returns-5">Returns</a></h4>
<ul>
<li><code>Array</code> - Block traces.</li>
</ul>
<h4 id="example-6"><a class="header" href="#example-6">Example</a></h4>
<p>Request</p>
<pre><code class="language-bash">curl --data '{"method":"trace_block","params":["0x2ed119"],"id":1,"jsonrpc":"2.0"}' -H "Content-Type: application/json" -X POST localhost:8545
</code></pre>
<p>Response</p>
<pre><code class="language-js">{
  "id": 1,
  "jsonrpc": "2.0",
  "result": [
    {
      "action": {
        "callType": "call",
        "from": "0xaa7b131dc60b80d3cf5e59b5a21a666aa039c951",
        "gas": "0x0",
        "input": "0x",
        "to": "0xd40aba8166a212d6892125f079c33e6f5ca19814",
        "value": "0x4768d7effc3fbe"
      },
      "blockHash": "0x7eb25504e4c202cf3d62fd585d3e238f592c780cca82dacb2ed3cb5b38883add",
      "blockNumber": 3068185,
      "result": {
        "gasUsed": "0x0",
        "output": "0x"
      },
      "subtraces": 0,
      "traceAddress": [],
      "transactionHash": "0x07da28d752aba3b9dd7060005e554719c6205c8a3aea358599fc9b245c52f1f6",
      "transactionPosition": 0,
      "type": "call"
    },
    ...
  ]
}
</code></pre>
<hr />
<h3 id="trace_filter"><a class="header" href="#trace_filter">trace_filter</a></h3>
<p>Returns traces matching given filter</p>
<h4 id="parameters-6"><a class="header" href="#parameters-6">Parameters</a></h4>
<ol start="0">
<li><code>Object</code> - The filter object
<ul>
<li><code>fromBlock</code>:   <code>Quantity</code> or <code>Tag</code> - (optional) From this block.</li>
<li><code>toBlock</code>:   <code>Quantity</code> or <code>Tag</code> - (optional) To this block.</li>
<li><code>fromAddress</code>:   <code>Array</code> - (optional) Sent from these addresses.</li>
<li><code>toAddress</code>:   <code>Address</code> - (optional) Sent to these addresses.</li>
<li><code>after</code>:   <code>Quantity</code> - (optional) The offset trace number</li>
<li><code>count</code>:   <code>Quantity</code> - (optional) Integer number of traces to display in a batch.</li>
</ul>
</li>
</ol>
<pre><code class="language-js">params: [{
  "fromBlock": "0x2ed0c4", // 3068100
  "toBlock": "0x2ed128", // 3068200
  "toAddress": ["0x8bbB73BCB5d553B5A556358d27625323Fd781D37"],
  "after": 1000,
  "count": 100
}]
</code></pre>
<h4 id="returns-6"><a class="header" href="#returns-6">Returns</a></h4>
<ul>
<li><code>Array</code> - Traces matching given filter</li>
</ul>
<h4 id="example-7"><a class="header" href="#example-7">Example</a></h4>
<p>Request</p>
<pre><code class="language-bash">curl --data '{"method":"trace_filter","params":[{"fromBlock":"0x2ed0c4","toBlock":"0x2ed128","toAddress":["0x8bbB73BCB5d553B5A556358d27625323Fd781D37"],"after":1000,"count":100}],"id":1,"jsonrpc":"2.0"}' -H "Content-Type: application/json" -X POST localhost:8545
</code></pre>
<p>Response</p>
<pre><code class="language-js">{
  "id": 1,
  "jsonrpc": "2.0",
  "result": [
    {
      "action": {
        "callType": "call",
        "from": "0x32be343b94f860124dc4fee278fdcbd38c102d88",
        "gas": "0x4c40d",
        "input": "0x",
        "to": "0x8bbb73bcb5d553b5a556358d27625323fd781d37",
        "value": "0x3f0650ec47fd240000"
      },
      "blockHash": "0x86df301bcdd8248d982dbf039f09faf792684e1aeee99d5b58b77d620008b80f",
      "blockNumber": 3068183,
      "result": {
        "gasUsed": "0x0",
        "output": "0x"
      },
      "subtraces": 0,
      "traceAddress": [],
      "transactionHash": "0x3321a7708b1083130bd78da0d62ead9f6683033231617c9d268e2c7e3fa6c104",
      "transactionPosition": 3,
      "type": "call"
    },
    ...
  ]
}
</code></pre>
<hr />
<h3 id="trace_get"><a class="header" href="#trace_get">trace_get</a></h3>
<p>Returns trace at given position.</p>
<h4 id="parameters-7"><a class="header" href="#parameters-7">Parameters</a></h4>
<ol start="0">
<li><code>Hash</code> - Transaction hash.</li>
<li><code>Array</code> - Index positions of the traces.</li>
</ol>
<pre><code class="language-js">params: [
  "0x17104ac9d3312d8c136b7f44d4b8b47852618065ebfa534bd2d3b5ef218ca1f3",
  ["0x0"]
]
</code></pre>
<h4 id="returns-7"><a class="header" href="#returns-7">Returns</a></h4>
<ul>
<li><code>Object</code> - Trace object</li>
</ul>
<h4 id="example-8"><a class="header" href="#example-8">Example</a></h4>
<p>Request</p>
<pre><code class="language-bash">curl --data '{"method":"trace_get","params":["0x17104ac9d3312d8c136b7f44d4b8b47852618065ebfa534bd2d3b5ef218ca1f3",["0x0"]],"id":1,"jsonrpc":"2.0"}' -H "Content-Type: application/json" -X POST localhost:8545
</code></pre>
<p>Response</p>
<pre><code class="language-js">{
  "id": 1,
  "jsonrpc": "2.0",
  "result": {
    "action": {
      "callType": "call",
      "from": "0x1c39ba39e4735cb65978d4db400ddd70a72dc750",
      "gas": "0x13e99",
      "input": "0x16c72721",
      "to": "0x2bd2326c993dfaef84f696526064ff22eba5b362",
      "value": "0x0"
    },
    "blockHash": "0x7eb25504e4c202cf3d62fd585d3e238f592c780cca82dacb2ed3cb5b38883add",
    "blockNumber": 3068185,
    "result": {
      "gasUsed": "0x183",
      "output": "0x0000000000000000000000000000000000000000000000000000000000000001"
    },
    "subtraces": 0,
    "traceAddress": [
      0
    ],
    "transactionHash": "0x17104ac9d3312d8c136b7f44d4b8b47852618065ebfa534bd2d3b5ef218ca1f3",
    "transactionPosition": 2,
    "type": "call"
  }
}
</code></pre>
<hr />
<h3 id="trace_transaction"><a class="header" href="#trace_transaction">trace_transaction</a></h3>
<p>Returns all traces of given transaction</p>
<h4 id="parameters-8"><a class="header" href="#parameters-8">Parameters</a></h4>
<ol start="0">
<li><code>Hash</code> - Transaction hash</li>
</ol>
<pre><code class="language-js">params: ["0x17104ac9d3312d8c136b7f44d4b8b47852618065ebfa534bd2d3b5ef218ca1f3"]
</code></pre>
<h4 id="returns-8"><a class="header" href="#returns-8">Returns</a></h4>
<ul>
<li><code>Array</code> - Traces of given transaction</li>
</ul>
<h4 id="example-9"><a class="header" href="#example-9">Example</a></h4>
<p>Request</p>
<pre><code class="language-bash">curl --data '{"method":"trace_transaction","params":["0x17104ac9d3312d8c136b7f44d4b8b47852618065ebfa534bd2d3b5ef218ca1f3"],"id":1,"jsonrpc":"2.0"}' -H "Content-Type: application/json" -X POST localhost:8545
</code></pre>
<p>Response</p>
<pre><code class="language-js">{
  "id": 1,
  "jsonrpc": "2.0",
  "result": [
    {
      "action": {
        "callType": "call",
        "from": "0x1c39ba39e4735cb65978d4db400ddd70a72dc750",
        "gas": "0x13e99",
        "input": "0x16c72721",
        "to": "0x2bd2326c993dfaef84f696526064ff22eba5b362",
        "value": "0x0"
      },
      "blockHash": "0x7eb25504e4c202cf3d62fd585d3e238f592c780cca82dacb2ed3cb5b38883add",
      "blockNumber": 3068185,
      "result": {
        "gasUsed": "0x183",
        "output": "0x0000000000000000000000000000000000000000000000000000000000000001"
      },
      "subtraces": 0,
      "traceAddress": [
        0
      ],
      "transactionHash": "0x17104ac9d3312d8c136b7f44d4b8b47852618065ebfa534bd2d3b5ef218ca1f3",
      "transactionPosition": 2,
      "type": "call"
    },
    ...
  ]
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="txpool-rpc-namespace"><a class="header" href="#txpool-rpc-namespace"><code>txPool</code> RPC Namespace</a></h1>
<h2 id="introduction-6"><a class="header" href="#introduction-6">Introduction</a></h2>
<p>The <code>txpool</code> namespace provides methods for inspecting and managing the transaction pool (mempool) in Erigon. These methods allow you to view pending, queued, and base fee transactions, providing insight into the current state of unconfirmed transactions. In Erigon, the <code>txpool</code> namespace is implemented through the <code>TxPoolAPI</code> interface and <code>TxPoolAPIImpl</code> struct.</p>
<p>The txpool namespace must be explicitly enabled using the <code>--http.api</code> flag when starting the RPC daemon. These methods are particularly useful for monitoring transaction pool status and debugging transaction submission issues.</p>
<h3 id="transaction-pool-architecture"><a class="header" href="#transaction-pool-architecture">Transaction Pool Architecture</a></h3>
<ul>
<li>Erigon's transaction pool is organized into three sub-pools: pending (executable), baseFee (insufficient base fee), and queued (nonce gaps)</li>
<li>The pool can run either integrated within the main Erigon process or as a separate service for scalability</li>
<li>Transaction pool methods communicate via gRPC with the txpool service when running in external mode</li>
</ul>
<h3 id="implementation-details-2"><a class="header" href="#implementation-details-2">Implementation Details</a></h3>
<ul>
<li>The <code>TxPoolAPIImpl</code> uses a <code>proto_txpool.TxpoolClient</code> to communicate with the transaction pool service</li>
<li>All transactions are decoded from RLP format and converted to <code>ethapi.RPCTransaction</code> objects for JSON-RPC responses</li>
<li>The implementation handles transaction categorization based on the <code>TxnType</code> field from the pool service</li>
</ul>
<h3 id="external-vs-internal-mode"><a class="header" href="#external-vs-internal-mode">External vs Internal Mode</a></h3>
<ul>
<li><strong>Internal Mode</strong>: Transaction pool runs within the main Erigon process (default configuration)</li>
<li><strong>External Mode</strong>: Transaction pool runs as a separate service, requiring explicit configuration with <code>--txpool.api.addr</code>. External mode requires an external sentry service and provides better resource isolation</li>
</ul>
<h3 id="usage-in-development-and-testing-1"><a class="header" href="#usage-in-development-and-testing-1">Usage in Development and Testing</a></h3>
<ul>
<li>These methods are commonly used for monitoring transaction submission and pool state</li>
<li>The <code>txpool_status</code> method provides quick insight into pool health and congestion</li>
<li>Transaction pool content methods help debug why transactions may not be getting mined</li>
</ul>
<h3 id="configuration-and-limits"><a class="header" href="#configuration-and-limits">Configuration and Limits</a></h3>
<ul>
<li>Transaction pool limits can be configured via flags like <code>--txpool.globalslots</code>, <code>--txpool.globalbasefeeslots</code>, and <code>--txpool.globalqueue</code></li>
<li>The pool supports various transaction types including blob transactions with separate limits</li>
<li>Pool configuration is managed through the <code>txpoolcfg.Config</code> structure</li>
</ul>
<h3 id="availability-1"><a class="header" href="#availability-1">Availability</a></h3>
<ul>
<li>The txpool namespace is available when included in the <code>--http.api</code> flag</li>
<li>Methods are marked as "remote" in the documentation, indicating they communicate with external services</li>
<li>All txpool methods are available on both HTTP and WebSocket connections</li>
</ul>
<hr />
<h2 id="txpool_content"><a class="header" href="#txpool_content"><strong>txpool_content</strong></a></h2>
<p>Returns the content of the transaction pool, organized by sender address and categorized into pending, queued, and baseFee sub-pools.</p>
<p><strong>Parameters</strong></p>
<p>None</p>
<p><strong>Example</strong></p>
<pre><code class="language-bash">curl -s --data '{"jsonrpc":"2.0","method":"txpool_content","params":[],"id":"1"}' -H "Content-Type: application/json" -X POST http://localhost:8545
</code></pre>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">Object</td><td style="text-align: left">Transaction pool content organized by sub-pool type</td></tr>
<tr><td style="text-align: left">pending</td><td style="text-align: left">Object</td></tr>
<tr><td style="text-align: left">baseFee</td><td style="text-align: left">Object</td></tr>
<tr><td style="text-align: left">queued</td><td style="text-align: left">Object</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="txpool_contentfrom"><a class="header" href="#txpool_contentfrom"><strong>txpool_contentFrom</strong></a></h2>
<p>Returns the content of the transaction pool for a specific sender address, showing all transactions from that address across all sub-pools.</p>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Parameter</th><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">address</td><td style="text-align: left">DATA, 20 BYTES</td><td style="text-align: left">The sender address to query transactions for</td></tr>
</tbody></table>
</div>
<p><strong>Example</strong></p>
<pre><code class="language-bash">curl -s --data '{"jsonrpc":"2.0","method":"txpool_contentFrom","params":["0xb60e8dd61c5d32be8058bb8eb970870f07233155"],"id":"1"}' -H "Content-Type: application/json" -X POST http://localhost:8545
</code></pre>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">Object</td><td style="text-align: left">Transaction pool content for the specified address</td></tr>
<tr><td style="text-align: left">pending</td><td style="text-align: left">Object</td></tr>
<tr><td style="text-align: left">baseFee</td><td style="text-align: left">Object</td></tr>
<tr><td style="text-align: left">queued</td><td style="text-align: left">Object</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="txpool_status"><a class="header" href="#txpool_status"><strong>txpool_status</strong></a></h2>
<p>Returns the current status of the transaction pool, including the count of transactions in each sub-pool.</p>
<p><strong>Parameters</strong></p>
<p>None</p>
<p><strong>Example</strong></p>
<pre><code class="language-bash">curl -s --data '{"jsonrpc":"2.0","method":"txpool_status","params":[],"id":"1"}' -H "Content-Type: application/json" -X POST http://localhost:8545
</code></pre>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">Object</td><td style="text-align: left">Transaction pool status counts</td></tr>
<tr><td style="text-align: left">pending</td><td style="text-align: left">QUANTITY</td></tr>
<tr><td style="text-align: left">baseFee</td><td style="text-align: left">QUANTITY</td></tr>
<tr><td style="text-align: left">queued</td><td style="text-align: left">QUANTITY</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="admin-rpc-namespace"><a class="header" href="#admin-rpc-namespace"><code>admin</code> RPC Namespace</a></h1>
<h2 id="introduction-7"><a class="header" href="#introduction-7">Introduction</a></h2>
<p>The <code>admin</code> namespace provides administrative methods for managing the Erigon node, including peer management and node information retrieval. These methods are designed for node operators and developers who need to monitor and control various aspects of the Erigon client's operation.</p>
<p>The admin namespace must be explicitly enabled using the <code>--http.api</code> flag when starting the RPC daemon. For security reasons, it's recommended not to include <code>admin</code> in the API list for public RPC endpoints.</p>
<h3 id="security-considerations"><a class="header" href="#security-considerations">Security Considerations</a></h3>
<ul>
<li>The admin namespace provides powerful administrative functions that should not be exposed on public RPC endpoints</li>
<li>When configuring public RPC access, explicitly exclude <code>admin</code> from the <code>--http.api</code> flag to prevent unauthorized access</li>
<li>These methods can affect node connectivity and should only be used by trusted operators</li>
</ul>
<h3 id="usage-in-testing-and-development"><a class="header" href="#usage-in-testing-and-development">Usage in Testing and Development</a></h3>
<ul>
<li>Admin methods are commonly used in automated testing environments for peer management</li>
<li>The docker-compose configuration for automated testing includes the admin namespace in the API list for testing purposes</li>
<li>These methods are essential for setting up test networks and managing peer connections programmatically</li>
</ul>
<h3 id="availability-2"><a class="header" href="#availability-2">Availability</a></h3>
<ul>
<li>Admin methods are available when the <code>admin</code> namespace is included in the <code>--http.api</code> flag</li>
<li>All admin methods are available on both HTTP and WebSocket connections</li>
<li>Some admin methods may require the node to be running with specific network configurations</li>
</ul>
<h3 id="integration-with-p2p-network"><a class="header" href="#integration-with-p2p-network">Integration with P2P Network</a></h3>
<ul>
<li>Admin methods interact directly with Erigon's P2P networking layer</li>
<li>Peer management operations may take time to complete as they involve network operations</li>
<li>The effectiveness of <code>admin_addPeer</code> depends on network connectivity and peer availability</li>
</ul>
<hr />
<h2 id="admin_nodeinfo"><a class="header" href="#admin_nodeinfo"><strong>admin_nodeInfo</strong></a></h2>
<p>Returns information about the running node, including network details, protocols, and node identification.</p>
<p><strong>Parameters</strong></p>
<p>None</p>
<p><strong>Example</strong></p>
<pre><code class="language-bash">curl -s --data '{"jsonrpc":"2.0","method":"admin_nodeInfo","params":[],"id":"1"}' -H "Content-Type: application/json" -X POST http://localhost:8545
</code></pre>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">Object</td><td style="text-align: left">Node information object containing network and protocol details</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="admin_peers"><a class="header" href="#admin_peers"><strong>admin_peers</strong></a></h2>
<p>Returns information about connected peers, including their network addresses, protocols, and connection status.</p>
<p><strong>Parameters</strong></p>
<p>None</p>
<p><strong>Example</strong></p>
<pre><code class="language-bash">curl -s --data '{"jsonrpc":"2.0","method":"admin_peers","params":[],"id":"1"}' -H "Content-Type: application/json" -X POST http://localhost:8545
</code></pre>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">Array</td><td style="text-align: left">Array of peer objects containing connection and protocol information</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="admin_addpeer"><a class="header" href="#admin_addpeer"><strong>admin_addPeer</strong></a></h2>
<p>Attempts to add a new peer to the node's peer list by connecting to the specified enode URL.</p>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Parameter</th><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">enode</td><td style="text-align: left">STRING</td><td style="text-align: left">The enode URL of the peer to add (format: enode://pubkey@ip:port)</td></tr>
</tbody></table>
</div>
<p><strong>Example</strong></p>
<pre><code class="language-bash">curl -s --data '{"jsonrpc":"2.0","method":"admin_addPeer","params":["enode://a979fb575495b8d6db44f750317d0f4622bf4c2aa3365d6af7c284339968eef29b69ad0dce72a4d8db5ebb4968de0e3bec910127f134779fbcb0cb6d3331163c@52.16.188.185:30303"],"id":"1"}' -H "Content-Type: application/json" -X POST http://localhost:8545
</code></pre>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">Boolean</td><td style="text-align: left">True if the peer was successfully added, false otherwise</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="admin_removepeer"><a class="header" href="#admin_removepeer"><strong>admin_removePeer</strong></a></h2>
<p>Removes a peer from the node's peer list by disconnecting from the specified enode URL.</p>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Parameter</th><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">enode</td><td style="text-align: left">STRING</td><td style="text-align: left">The enode URL of the peer to remove (format: enode://pubkey@ip:port)</td></tr>
</tbody></table>
</div>
<p><strong>Example</strong></p>
<pre><code class="language-bash">curl -s --data '{"jsonrpc":"2.0","method":"admin_removePeer","params":["enode://a979fb575495b8d6db44f750317d0f4622bf4c2aa3365d6af7c284339968eef29b69ad0dce72a4d8db5ebb4968de0e3bec910127f134779fbcb0cb6d3331163c@52.16.188.185:30303"],"id":"1"}' -H "Content-Type: application/json" -X POST http://localhost:8545
</code></pre>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">Boolean</td><td style="text-align: left">True if the peer was successfully removed, false otherwise</td></tr>
</tbody></table>
</div>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="bor-rpc-namespace"><a class="header" href="#bor-rpc-namespace"><code>bor</code> RPC Namespace</a></h1>
<h2 id="introduction-8"><a class="header" href="#introduction-8">Introduction</a></h2>
<p>The <code>bor</code> namespace provides Polygon-specific RPC methods that are only available when running Erigon on Polygon networks (Mainnet, Amoy testnet, etc.). These methods expose functionality specific to the Bor consensus engine, including validator information, snapshots, and proposer sequences.</p>
<p>The bor namespace must be explicitly enabled using the <code>--http.api</code> flag when starting the RPC daemon and is only functional when running on Polygon networks with the Bor consensus engine.</p>
<h3 id="network-compatibility"><a class="header" href="#network-compatibility">Network Compatibility</a></h3>
<ul>
<li>The bor namespace is only available when running Erigon on Polygon networks (Mainnet, Amoy testnet, etc.)</li>
<li>These methods will return errors if called on non-Polygon networks or when the Bor consensus engine is not active</li>
<li>The methods require the underlying Bor consensus engine to be properly configured and running</li>
</ul>
<h3 id="consensus-integration"><a class="header" href="#consensus-integration">Consensus Integration</a></h3>
<ul>
<li>All bor methods interact directly with the Bor consensus engine and validator set management</li>
<li>The methods provide access to Polygon's unique consensus features like validator snapshots and proposer sequences</li>
<li>These APIs are essential for applications that need to understand Polygon's validator dynamics and block production</li>
</ul>
<h3 id="usage-in-polygon-ecosystem"><a class="header" href="#usage-in-polygon-ecosystem">Usage in Polygon Ecosystem</a></h3>
<ul>
<li>These methods are commonly used by Polygon validators, delegators, and applications that need validator information</li>
<li>The snapshot and signer methods are particularly useful for understanding the current validator set and their roles</li>
<li>Root hash methods are used for checkpoint verification and cross-chain communication</li>
</ul>
<hr />
<h2 id="bor_getsnapshot"><a class="header" href="#bor_getsnapshot"><strong>bor_getSnapshot</strong></a></h2>
<p>Returns the validator snapshot at a given block number, containing information about the current validator set and their voting power.</p>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Parameter</th><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">number</td><td style="text-align: left">QUANTITY|TAG</td><td style="text-align: left">Block number or "latest", "earliest", "pending"</td></tr>
</tbody></table>
</div>
<p><strong>Example</strong></p>
<pre><code class="language-bash">curl -s --data '{"jsonrpc":"2.0","method":"bor_getSnapshot","params":["latest"],"id":"1"}' -H "Content-Type: application/json" -X POST http://localhost:8545
</code></pre>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">Object</td><td style="text-align: left">Snapshot object containing validator information and voting details</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="bor_getauthor"><a class="header" href="#bor_getauthor"><strong>bor_getAuthor</strong></a></h2>
<p>Returns the author (block proposer) of a block at the given block number or hash.</p>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Parameter</th><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">blockNrOrHash</td><td style="text-align: left">QUANTITY|TAG|HASH</td><td style="text-align: left">Block number, tag, or block hash</td></tr>
</tbody></table>
</div>
<p><strong>Example</strong></p>
<pre><code class="language-bash">curl -s --data '{"jsonrpc":"2.0","method":"bor_getAuthor","params":["0x1b4"],"id":"1"}' -H "Content-Type: application/json" -X POST http://localhost:8545
</code></pre>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">DATA, 20 BYTES</td><td style="text-align: left">The address of the block author/proposer</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="bor_getsnapshotathash"><a class="header" href="#bor_getsnapshotathash"><strong>bor_getSnapshotAtHash</strong></a></h2>
<p>Returns the validator snapshot at a specific block hash.</p>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Parameter</th><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">hash</td><td style="text-align: left">DATA, 32 BYTES</td><td style="text-align: left">Hash of the block</td></tr>
</tbody></table>
</div>
<p><strong>Example</strong></p>
<pre><code class="language-bash">curl -s --data '{"jsonrpc":"2.0","method":"bor_getSnapshotAtHash","params":["0x1d59ff54b1eb26b013ce3cb5fc9dab3705b415a67127a003c3e61eb445bb8df2"],"id":"1"}' -H "Content-Type: application/json" -X POST http://localhost:8545
</code></pre>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">Object</td><td style="text-align: left">Snapshot object containing validator information at the specified block hash</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="bor_getsigners"><a class="header" href="#bor_getsigners"><strong>bor_getSigners</strong></a></h2>
<p>Returns the list of authorized signers (validators) at a given block number.</p>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Parameter</th><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">number</td><td style="text-align: left">QUANTITY|TAG</td><td style="text-align: left">Block number or "latest", "earliest", "pending"</td></tr>
</tbody></table>
</div>
<p><strong>Example</strong></p>
<pre><code class="language-bash">curl -s --data '{"jsonrpc":"2.0","method":"bor_getSigners","params":["latest"],"id":"1"}' -H "Content-Type: application/json" -X POST http://localhost:8545
</code></pre>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">Array</td><td style="text-align: left">Array of validator addresses authorized to sign blocks</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="bor_getsignersathash"><a class="header" href="#bor_getsignersathash"><strong>bor_getSignersAtHash</strong></a></h2>
<p>Returns the list of authorized signers (validators) at a specific block hash.</p>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Parameter</th><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">hash</td><td style="text-align: left">DATA, 32 BYTES</td><td style="text-align: left">Hash of the block</td></tr>
</tbody></table>
</div>
<p><strong>Example</strong></p>
<pre><code class="language-bash">curl -s --data '{"jsonrpc":"2.0","method":"bor_getSignersAtHash","params":["0x1d59ff54b1eb26b013ce3cb5fc9dab3705b415a67127a003c3e61eb445bb8df2"],"id":"1"}' -H "Content-Type: application/json" -X POST http://localhost:8545
</code></pre>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">Array</td><td style="text-align: left">Array of validator addresses authorized to sign blocks at the specified hash</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="bor_getcurrentproposer"><a class="header" href="#bor_getcurrentproposer"><strong>bor_getCurrentProposer</strong></a></h2>
<p>Returns the address of the current block proposer based on the current validator set and proposer selection algorithm.</p>
<p><strong>Parameters</strong></p>
<p>None</p>
<p><strong>Example</strong></p>
<pre><code class="language-bash">curl -s --data '{"jsonrpc":"2.0","method":"bor_getCurrentProposer","params":[],"id":"1"}' -H "Content-Type: application/json" -X POST http://localhost:8545
</code></pre>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">DATA, 20 BYTES</td><td style="text-align: left">The address of the current proposer</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="bor_getcurrentvalidators"><a class="header" href="#bor_getcurrentvalidators"><strong>bor_getCurrentValidators</strong></a></h2>
<p>Returns the current validator set with their details including voting power and other metadata.</p>
<p><strong>Parameters</strong></p>
<p>None</p>
<p><strong>Example</strong></p>
<pre><code class="language-bash">curl -s --data '{"jsonrpc":"2.0","method":"bor_getCurrentValidators","params":[],"id":"1"}' -H "Content-Type: application/json" -X POST http://localhost:8545
</code></pre>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">Array</td><td style="text-align: left">Array of validator objects with their addresses, voting power, and metadata</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="bor_getsnapshotproposersequence"><a class="header" href="#bor_getsnapshotproposersequence"><strong>bor_getSnapshotProposerSequence</strong></a></h2>
<p>Returns the proposer sequence for a given block, showing the order in which validators are expected to propose blocks.</p>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Parameter</th><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">blockNrOrHash</td><td style="text-align: left">QUANTITY|TAG|HASH</td><td style="text-align: left">Block number, tag, or block hash</td></tr>
</tbody></table>
</div>
<p><strong>Example</strong></p>
<pre><code class="language-bash">curl -s --data '{"jsonrpc":"2.0","method":"bor_getSnapshotProposerSequence","params":["latest"],"id":"1"}' -H "Content-Type: application/json" -X POST http://localhost:8545
</code></pre>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">Object</td><td style="text-align: left">BlockSigners object containing the proposer sequence information</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="bor_getroothash"><a class="header" href="#bor_getroothash"><strong>bor_getRootHash</strong></a></h2>
<p>Returns the root hash for a range of blocks, used for checkpoint verification and state synchronization.</p>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Parameter</th><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">start</td><td style="text-align: left">QUANTITY</td><td style="text-align: left">Starting block number</td></tr>
<tr><td style="text-align: left">end</td><td style="text-align: left">QUANTITY</td><td style="text-align: left">Ending block number</td></tr>
</tbody></table>
</div>
<p><strong>Example</strong></p>
<pre><code class="language-bash">curl -s --data '{"jsonrpc":"2.0","method":"bor_getRootHash","params":["0x1", "0x100"],"id":"1"}' -H "Content-Type: application/json" -X POST http://localhost:8545
</code></pre>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">STRING</td><td style="text-align: left">The root hash for the specified block range</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="bor_getvoteonhash"><a class="header" href="#bor_getvoteonhash"><strong>bor_getVoteOnHash</strong></a></h2>
<p>Returns voting information for a specific block hash, used in the Bor consensus mechanism.</p>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Parameter</th><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">hash</td><td style="text-align: left">DATA, 32 BYTES</td><td style="text-align: left">Hash of the block to get voting information for</td></tr>
</tbody></table>
</div>
<p><strong>Example</strong></p>
<pre><code class="language-bash">curl -s --data '{"jsonrpc":"2.0","method":"bor_getVoteOnHash","params":["0x1d59ff54b1eb26b013ce3cb5fc9dab3705b415a67127a003c3e61eb445bb8df2"],"id":"1"}' -H "Content-Type: application/json" -X POST http://localhost:8545
</code></pre>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">Object</td><td style="text-align: left">Voting information object for the specified block hash</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="ots-json-rpc-namespace"><a class="header" href="#ots-json-rpc-namespace"><code>ots</code> JSON RPC namespace</a></h1>
<p>In addition to the standard Geth methods, Erigon includes RPC methods prefixed with <code>ots_</code> for <strong>Otterscan</strong>. These are specific to the Otterscan functionality integrated with Erigon.</p>
<p>See more details at <a href="https://docs.otterscan.io/api-docs/ots-api">https://docs.otterscan.io/api-docs/ots-api</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="internal-rpc-namespace"><a class="header" href="#internal-rpc-namespace"><code>internal</code> RPC Namespace</a></h1>
<p>The <strong><code>internal_</code></strong> methods are for development and debugging utilities and must be explicitly included in the <code>--http.api</code> flag if customizing enabled namespaces.</p>
<h2 id="internal_gettxnuminfo"><a class="header" href="#internal_gettxnuminfo"><strong>internal_getTxNumInfo</strong></a></h2>
<p>Returns transaction number information for development and debugging purposes. This is part of Erigon's internal APIs and may change without notice.</p>
<p><strong>Parameters</strong></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Parameter</th><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">txNum</td><td style="text-align: left">QUANTITY</td><td style="text-align: left">Internal transaction number</td></tr>
</tbody></table>
</div>
<p><strong>Example</strong></p>
<pre><code class="language-bash">curl -s --data '{"jsonrpc":"2.0","method":"internal_getTxNumInfo","params":["0x1"],"id":"1"}' -H "Content-Type: application/json" -X POST http://localhost:8545
</code></pre>
<p><strong>Returns</strong></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">Object</td><td style="text-align: left">Transaction number information</td></tr>
<tr><td style="text-align: left">blockNum</td><td style="text-align: left">QUANTITY</td></tr>
<tr><td style="text-align: left">idx</td><td style="text-align: left">QUANTITY</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="grpc-api-guide"><a class="header" href="#grpc-api-guide"><code>gRPC</code> API Guide</a></h1>
<h2 id="introduction-9"><a class="header" href="#introduction-9">Introduction</a></h2>
<p>Erigon provides gRPC APIs that allow users to access blockchain data and services directly through protocol buffer interfaces. These APIs offer high-performance, strongly-typed access to Erigon's internal services and are particularly useful for applications requiring efficient data access or integration with other gRPC-based systems.</p>
<p>The gRPC server must be explicitly enabled using the <code>--grpc</code> flag when starting the RPC daemon, and can be configured with custom listening addresses, ports, and TLS settings.</p>
<h3 id="performance-considerations-2"><a class="header" href="#performance-considerations-2">Performance Considerations</a></h3>
<ul>
<li>gRPC APIs provide better performance than JSON-RPC for high-throughput applications</li>
<li>Direct database access via KV interface offers the fastest data retrieval</li>
<li>Shared memory access (when running locally) provides optimal performance</li>
</ul>
<h3 id="data-format-and-buckets"><a class="header" href="#data-format-and-buckets">Data Format and Buckets</a></h3>
<p>Database bucket names and their formats are documented in <code>db/kv/tables.go</code>. Understanding these structures is essential for effective use of the KV interface.</p>
<h3 id="network-access"><a class="header" href="#network-access">Network Access</a></h3>
<ul>
<li>gRPC services can be accessed over the network when properly configured</li>
<li>TLS encryption is recommended for production deployments</li>
<li>Rate limiting can be configured via <code>--private.api.ratelimit</code> flag</li>
</ul>
<h3 id="integration-libraries"><a class="header" href="#integration-libraries">Integration Libraries</a></h3>
<p>Erigon provides Go, Rust, and C++ implementations of the RoKV (read-only key-value) interface for easy integration with applications.</p>
<h3 id="availability-3"><a class="header" href="#availability-3">Availability</a></h3>
<ul>
<li>gRPC services are available when enabled with the <code>--grpc</code> flag</li>
<li>Default listening address is configurable via <code>--grpc.addr</code> and <code>--grpc.port</code></li>
<li>Services require the main Erigon node to be running and accessible</li>
</ul>
<p>For more information, visit the <a href="https://github.com/erigontech/interfaces">Erigon Interfaces GitHub repository</a>.</p>
<hr />
<h2 id="kv-key-value-interface"><a class="header" href="#kv-key-value-interface"><strong>KV (Key-Value) Interface</strong></a></h2>
<p>The KV interface provides low-level database access methods for reading blockchain data directly from Erigon's MDBX database.</p>
<p><strong>Interface Definition</strong></p>
<p>The KV interface is defined in the remote protobuf specification and provides methods for:</p>
<ul>
<li>Opening read-only transactions</li>
<li>Reading data by key ranges</li>
<li>Iterating over database buckets</li>
<li>Accessing historical state data</li>
</ul>
<p><strong>Example Usage</strong></p>
<pre><code class="language-bash"># Connect to gRPC endpoint
grpcurl -plaintext localhost:9090 remote.KV/Version
</code></pre>
<p><strong>Available Methods</strong></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Method</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">Version</td><td style="text-align: left">Returns the KV service API version</td></tr>
<tr><td style="text-align: left">Tx</td><td style="text-align: left">Opens a read-only transaction for data access</td></tr>
<tr><td style="text-align: left">StateChanges</td><td style="text-align: left">Streams state changes for a block range</td></tr>
<tr><td style="text-align: left">Snapshots</td><td style="text-align: left">Returns information about available snapshots</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="ethbackend-interface"><a class="header" href="#ethbackend-interface"><strong>ETHBACKEND Interface</strong></a></h2>
<p>The ETHBACKEND interface provides access to Ethereum-specific backend services including block data, transaction information, and network status.</p>
<p><strong>Available Services</strong></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Service</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">Etherbase</td><td style="text-align: left">Returns the coinbase address</td></tr>
<tr><td style="text-align: left">NetVersion</td><td style="text-align: left">Returns the network ID</td></tr>
<tr><td style="text-align: left">NetPeerCount</td><td style="text-align: left">Returns the number of connected peers</td></tr>
<tr><td style="text-align: left">ProtocolVersion</td><td style="text-align: left">Returns the Ethereum protocol version</td></tr>
<tr><td style="text-align: left">ClientVersion</td><td style="text-align: left">Returns the client version string</td></tr>
<tr><td style="text-align: left">Subscribe</td><td style="text-align: left">Subscribes to blockchain events</td></tr>
<tr><td style="text-align: left">NodeInfo</td><td style="text-align: left">Returns node information</td></tr>
<tr><td style="text-align: left">Peers</td><td style="text-align: left">Returns information about connected peers</td></tr>
<tr><td style="text-align: left">AddPeer</td><td style="text-align: left">Adds a peer to the node</td></tr>
<tr><td style="text-align: left">PendingBlock</td><td style="text-align: left">Returns the pending block</td></tr>
<tr><td style="text-align: left">BorEvent</td><td style="text-align: left">Returns Bor-specific events (Polygon networks only)</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="txpool-interface"><a class="header" href="#txpool-interface"><strong>TxPool Interface</strong></a></h2>
<p>The TxPool interface provides access to transaction pool operations and status information.</p>
<p><strong>Available Methods</strong></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Method</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">Version</td><td style="text-align: left">Returns the TxPool service version</td></tr>
<tr><td style="text-align: left">FindUnknownHashes</td><td style="text-align: left">Finds unknown transaction hashes</td></tr>
<tr><td style="text-align: left">GetTransactions</td><td style="text-align: left">Retrieves transactions from the pool</td></tr>
<tr><td style="text-align: left">All</td><td style="text-align: left">Returns all transactions in the pool</td></tr>
<tr><td style="text-align: left">PendingAdd</td><td style="text-align: left">Adds transactions to pending pool</td></tr>
<tr><td style="text-align: left">PendingRemove</td><td style="text-align: left">Removes transactions from pending pool</td></tr>
<tr><td style="text-align: left">OnAdd</td><td style="text-align: left">Subscribes to transaction addition events</td></tr>
<tr><td style="text-align: left">Mining</td><td style="text-align: left">Returns mining-related transaction data</td></tr>
<tr><td style="text-align: left">NonceFromAddress</td><td style="text-align: left">Gets the next nonce for an address</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="downloader-interface"><a class="header" href="#downloader-interface"><strong>Downloader Interface</strong></a></h2>
<p>The Downloader interface provides access to snapshot downloading and torrent management functionality.</p>
<p><strong>Available Methods</strong></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Method</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">Add</td><td style="text-align: left">Adds files to download queue</td></tr>
<tr><td style="text-align: left">Delete</td><td style="text-align: left">Removes files from download queue</td></tr>
<tr><td style="text-align: left">Completed</td><td style="text-align: left">Checks if downloads are completed</td></tr>
<tr><td style="text-align: left">SetLogPrefix</td><td style="text-align: left">Sets logging prefix for downloader</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="polygon-bridge-backend-grpc-api"><a class="header" href="#polygon-bridge-backend-grpc-api">Polygon Bridge Backend gRPC API</a></h2>
<p>These gRPC APIs are specifically designed for Polygon's Bor consensus mechanism and are only active when running Erigon with Polygon network configuration. The services provide essential functionality for bridge event processing and validator management required by the Polygon network architecture.</p>
<h3 id="bridge-backend-methods"><a class="header" href="#bridge-backend-methods">Bridge Backend Methods</a></h3>
<p><strong>Version Method:</strong></p>
<ul>
<li><code>Version()</code> - Returns the service version number.</li>
</ul>
<p><strong>Transaction Lookup:</strong></p>
<ul>
<li><code>BorTxnLookup(BorTxnLookupRequest)</code> - Looks up Bor transaction information by hash.</li>
</ul>
<p><strong>Event Retrieval:</strong></p>
<ul>
<li><code>BorEvents(BorEventsRequest)</code> - Retrieves bridge events for a specific block.</li>
</ul>
<h3 id="bridge-backend-implementation"><a class="header" href="#bridge-backend-implementation">Bridge Backend Implementation</a></h3>
<p>The server implementation is found in <code>polygon/bridge/server.go</code> where the <code>BackendServer</code> struct implements the <code>BridgeBackendServer</code> interface:</p>
<ul>
<li>
<p>The <code>BorTxnLookup</code> method implementation shows how it handles transaction lookups.</p>
</li>
<li>
<p>The <code>BorEvents</code> method retrieves bridge events for a given block.</p>
</li>
</ul>
<h2 id="heimdall-backend-grpc-api"><a class="header" href="#heimdall-backend-grpc-api">Heimdall Backend gRPC API</a></h2>
<p>The Heimdall Backend service provides APIs for validator and consensus-related functionality.</p>
<h3 id="heimdall-backend-methods"><a class="header" href="#heimdall-backend-methods">Heimdall Backend Methods</a></h3>
<p><strong>Version Method:</strong></p>
<ul>
<li><code>Version()</code> - Returns the service version number.</li>
</ul>
<p><strong>Producer Information:</strong></p>
<ul>
<li><code>Producers(BorProducersRequest)</code> - Retrieves validator/producer information for a specific block.</li>
</ul>
<h2 id="service-integration"><a class="header" href="#service-integration">Service Integration</a></h2>
<p>Both services are integrated into the main Ethereum backend when Bor consensus is configured. In the main backend initialization, you can see how these services are set up.</p>
<p>The Bridge and Heimdall services are created with their respective RPC servers.</p>
<hr />
<h2 id="configuration-and-security"><a class="header" href="#configuration-and-security">Configuration and Security</a></h2>
<h3 id="tls-configuration"><a class="header" href="#tls-configuration">TLS Configuration</a></h3>
<p>Erigon supports TLS encryption for gRPC connections using certificate files:</p>
<pre><code class="language-bash">./build/bin/rpcdaemon --grpc --tls.cert=/path/to/cert.pem --tls.key=/path/to/key.pem --tls.cacert=/path/to/ca.pem
</code></pre>
<h3 id="health-checks"><a class="header" href="#health-checks">Health Checks</a></h3>
<p>gRPC health checks can be enabled to monitor service availability:</p>
<pre><code class="language-bash">./build/bin/rpcdaemon --grpc --grpc.healthcheck
</code></pre>
<h3 id="connection-examples"><a class="header" href="#connection-examples">Connection Examples</a></h3>
<p><strong>Go Client Example</strong></p>
<pre><code class="language-go">conn, err := grpc.Dial("localhost:9090", grpc.WithInsecure())
if err != nil {
    log.Fatal(err)
}
defer conn.Close()

client := remote.NewKVClient(conn)
// Use client for database operations
</code></pre>
<p><strong>Direct Database Access</strong></p>
<p>The gRPC interface allows reading Erigon's database while the node is running, sharing the same OS-level PageCache for optimal performance.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="staking"><a class="header" href="#staking">Staking</a></h1>
<p><em>How to propose and validate blocks with Erigon</em></p>
<p>Erigon is a comprehensive execution and consensus layer that also supports staking, aka block production, for Ethereum and Gnosis Chain. Both remote miners and Caplin are supported.</p>
<ul>
<li>
<p>Using a <a href="staking/advanced/bp-ext.html">external consensus client as validator</a>;</p>
</li>
<li>
<p>Using <a href="staking/advanced/bp-caplin.html">Caplin as validator</a>.</p>
</li>
</ul>
<p>Additionally, you can configure Erigon to work with <a href="staking/shutter.html">Shutter Network</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-caplin-as-validator"><a class="header" href="#using-caplin-as-validator">Using Caplin as validator</a></h1>
<p><em>Running Erigon with Caplin as validator</em></p>
<p>Caplin is also suitable for staking. However, it is required to pair it with a validator key manager, such as Lighthouse or Teku, since it doesn't have a native key management system.</p>
<p>This guide explains how to use Erigon with its embedded Caplin consensus layer and Lighthouse as the validator client for staking on Ethereum.</p>
<h2 id="1-start-erigon-with-caplin"><a class="header" href="#1-start-erigon-with-caplin">1. Start Erigon with Caplin</a></h2>
<p>The following command starts Erigon with the embedded Caplin consensus layer with the beacon API on:</p>
<pre><code class="language-bash">erigon \
  --datadir=/data/erigon \
  --http \
  --http.addr=0.0.0.0 \
  --http.port=8545 \
  --http.api=engine,eth,net,web3 \
  --ws \
  --ws.port=8546 \
  --caplin.enable-upnp \
  --caplin.discovery.addr=0.0.0.0 \
  --caplin.discovery.port=4000 \
  --caplin.discovery.tcpport=4001 \
  --beacon.api=beacon,validator,builder,config,debug,events,node,lighthouse 
</code></pre>
<p><strong>Flags Explanation</strong>:</p>
<ul>
<li>Execution Layer (Erigon):
<ul>
<li><code>--http.api=engine,eth,net,web3</code>: enables the necessary APIs for external clients and Caplin.</li>
<li><code>--ws</code>: enables WebSocket-based communication (optional).</li>
</ul>
</li>
<li>Consensus Layer (Caplin):
<ul>
<li><code>--caplin.discovery.addr</code> and <code>--caplin.discovery.port</code>: configures Caplin's gossip and discovery layer.</li>
<li><code>--beacon.api=beacon,validator,builder,config,debug,events,node,lighthouse</code>: enables all possible API endpoints for the validator client.</li>
</ul>
</li>
</ul>
<h2 id="2-set-up-lighthouse-validator-client"><a class="header" href="#2-set-up-lighthouse-validator-client">2. Set Up Lighthouse Validator Client</a></h2>
<h3 id="21-install-lighthouse"><a class="header" href="#21-install-lighthouse">2.1 Install Lighthouse</a></h3>
<p>Install and run Lighthouse by following the official guide at <a href="https://lighthouse-book.sigmaprime.io/installation.html">https://lighthouse-book.sigmaprime.io/installation.html</a> or use Docker:</p>
<pre><code class="language-bash">docker pull sigp/lighthouse:latest
</code></pre>
<h3 id="22-create-lighthouse-validator-key-directory"><a class="header" href="#22-create-lighthouse-validator-key-directory">2.2. Create Lighthouse Validator Key Directory</a></h3>
<pre><code class="language-bash">mkdir -p ~/.lighthouse/validators
</code></pre>
<h3 id="23-run-lighthouse-validator-client"><a class="header" href="#23-run-lighthouse-validator-client">2.3. Run Lighthouse Validator Client</a></h3>
<p>Start the validator client and connect it to the Caplin CL:</p>
<pre><code class="language-bash">lighthouse vc \
  --network mainnet \
  --beacon-nodes http://127.0.0.1:5555 \
  --suggested-fee-recipient=&lt;your_eth_address&gt;
</code></pre>
<p><strong>Flags Explanation</strong>:</p>
<ul>
<li><code>--network mainnet</code>: Specifies the Ethereum mainnet.</li>
<li><code>--beacon-nodes</code>: Points to the Caplin beacon API at <code>http://127.0.0.1:5555</code>.</li>
<li><code>--suggested-fee-recipient</code>: Specifies your Ethereum address for block rewards.</li>
</ul>
<h3 id="24-import-validator-keys"><a class="header" href="#24-import-validator-keys">2.4. Import Validator Keys</a></h3>
<p>If you have existing validator keys, import them:</p>
<pre><code class="language-bash">lighthouse account validator import --directory &lt;path_to_validator_keys&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-an-external-consensus-client-as-validator"><a class="header" href="#using-an-external-consensus-client-as-validator">Using an External Consensus Client as Validator</a></h1>
<p>To use an external Consensus Layer (CL) it is necessary to add to Erigon the flag <code>--externalcl</code>.</p>
<p>Once you have Erigon and a CL client up and running, you can proceed to set up a Validator Client (VC). The VC is responsible for managing your keys and signing valid blocks.</p>
<blockquote>
<p>You can find a couple of example on how to run a Ethereum and Gnosis node using an external CL in the <strong>Help Section</strong>.</p>
</blockquote>
<h2 id="getting-started-with-a-validator-client"><a class="header" href="#getting-started-with-a-validator-client">Getting Started with a Validator Client</a></h2>
<p>To set up a Validator Client (VC), follow the instructions provided in the official documentation, such as:</p>
<p><a href="https://lighthouse-book.sigmaprime.io/mainnet-validator.html">https://lighthouse-book.sigmaprime.io/mainnet-validator.html</a>.</p>
<p>This guide will walk you through the process of setting up a VC, including:</p>
<ul>
<li>Generating and managing your keys</li>
<li>Configuring the Validator Client</li>
<li>Signing valid blocks</li>
</ul>
<p>Make sure to follow the instructions carefully and thoroughly to ensure that your VC is set up correctly. It is always recommended to start staking with a testnet.</p>
<h2 id="example-of-configuration"><a class="header" href="#example-of-configuration">Example of configuration</a></h2>
<p>The following example demonstrates how to configure Erigon to run with an external Consensus Layer:</p>
<pre><code class="language-bash">erigon \
  --externalcl \
  --datadir=/data/erigon \
  --chain=sepolia \
  --authrpc.jwtsecret=/jwt
  --authrpc.addr=0.0.0.0 \
  --http \
  --http.addr=0.0.0.0 \
  --http.port=8545 \
  --http.api=engine,eth,net,web3 \
  --ws \
  --ws.port=8546 \
</code></pre>
<h2 id="flags-explanation-4"><a class="header" href="#flags-explanation-4">Flags explanation:</a></h2>
<ul>
<li><code>--externalcl</code>: Enables the use of an external CL.</li>
<li><code>--datadir=/data/erigon</code>: Defines the directory to be used for databases.</li>
<li><code>--chain=sepolia</code>: Specifies the Sepolia chain.</li>
<li><code>--authrpc.jwtsecret=/jwt</code>: Sets the location of the JWT authentication code in hex encoding. This is used by Erigon (the EL) and the CL (in this case Lighthouse) to authenticate communication.</li>
<li><code>--authrpc.addr=0.0.0.0</code>: Allows the engine API to be accessed from any address.</li>
<li><code>--http.api=engine,eth,net,web3</code>: Enables the necessary APIs for external clients and Caplin.</li>
<li><code>--ws</code>: enables WebSocket-based communication, which is optional.</li>
</ul>
<blockquote>
<p>Note that many pre-merge flags, such as <code>--miner.etherbase</code>, are no longer useful, as block rewards and other validator-related configurations are now controlled by the Consensus Layer (CL).</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="shutter-network"><a class="header" href="#shutter-network">Shutter Network</a></h1>
<h2 id="what-is-shutter-network"><a class="header" href="#what-is-shutter-network">What is Shutter Network?</a></h2>
<p><a href="https://www.shutter.network">Shutter Network</a> is a privacy-focused protocol that provides encrypted transaction pools using threshold encryption. The main objective is to protect users from malicious MEV (Miner Extractable Value) attacks such as front-running and sandwich attacks by encrypting transactions until they are included in a block.</p>
<p>The key advantages of Shutter Network are:</p>
<ul>
<li><strong>Protection against MEV attacks:</strong> By encrypting transactions, the network prevents malicious actors from exploiting transaction ordering.</li>
<li><strong>Threshold encryption:</strong> Transactions are only decrypted when enough key holders (keypers) participate, ensuring security and decentralization.</li>
<li><strong>Support on Gnosis Chain:</strong> Shutter encrypted transaction pools are currently available on <a href="https://docs.gnosischain.com/shutterized-gc/">Gnosis Chain</a>, with plans for Ethereum support.</li>
</ul>
<blockquote>
<p>Shutter Network is now available only for Gnosis Network and Chiado testnet.</p>
</blockquote>
<h3 id="why-use-shutter"><a class="header" href="#why-use-shutter">Why Use Shutter?</a></h3>
<ul>
<li><strong>Access to Extra Transactions:</strong> Shutterized validators can include shielded transactions not available in the public transaction pool, leading to potentially higher block rewards.</li>
<li><strong>User Protection:</strong> Help protect users against MEV attacks, improving the fairness of the chain.</li>
</ul>
<h2 id="how-to-run-erigon-as-a-shutterized-validator"><a class="header" href="#how-to-run-erigon-as-a-shutterized-validator">How to Run Erigon as a Shutterized Validator</a></h2>
<p>To participate in the Shutter encrypted transaction pool as a validator using Erigon, follow these steps:</p>
<ol>
<li>
<p><strong>Set Up Your Validator</strong></p>
<p>Deposit your stake and register your validator on Gnosis Chain reby following the <a href="https://docs.gnosischain.com/node/manual/validator/deposit">Gnosis Chain Validator Setup</a>.</p>
</li>
<li>
<p><strong>Register as a Shutterized Validator</strong></p>
<p>Complete the validator registration for Shutter using the tool provided in the <a href="https://github.com/NethermindEth/shutter-validator-registration">Shutter Validator Registration Guide</a>.</p>
</li>
<li>
<p><strong>Verify Registration</strong></p>
<p>Use the Erigon CLI command to verify that your registration was successful:</p>
<pre><code class="language-bash">erigon shutter-validator-reg-check --chain &lt;CHAIN&gt; --el-url &lt;EL_RPC_URL&gt; --validator-info-file &lt;VALIDATOR_INFO_JSON&gt;
</code></pre>
<ul>
<li><code>--chain</code> valid values are <code>gnosis</code> or <code>chiado</code></li>
<li><code>--el-url</code>, in case you are using Erigon default ports is <code>http://localhost:8545</code></li>
<li><code>&lt;VALIDATOR_INFO_JSON&gt;</code> is the file generated during registration.</li>
</ul>
<p>for example:</p>
<pre><code class="language-bash">erigon shutter-validator-reg-check --chain gnosis --el-url http://localhost:8545 --validator-info-file /path/validatorInfo.json
</code></pre>
</li>
<li>
<p><strong>Run Erigon with Shutter Support</strong></p>
<p>Start Erigon as usual, but add the <code>--shutter</code> flag to enable Shutterized Validator mode:</p>
<pre><code class="language-bash">erigon --shutter [other options...]
</code></pre>
<p>This works with Erigon's internal CL Caplin (enabled by default) or with an external CL client using <code>--externalcl</code>.</p>
</li>
</ol>
<h2 id="shutter-network-default-ports-1"><a class="header" href="#shutter-network-default-ports-1">Shutter Network Default Ports</a></h2>
<p>The default peering port for Shutter is <code>23102</code> (TCP), to change it use <code>--shutter.p2p.listen.port &lt;value&gt;</code>.</p>
<p>Bootstrap nodes are used to help new nodes discover other nodes in the network. By default, the embedded configuration values are used, but these can be overridden with <code>--shutter.p2p.bootstrap.nodes &lt;value&gt;</code>.</p>
<h2 id="reference-documentation"><a class="header" href="#reference-documentation">Reference Documentation</a></h2>
<ul>
<li><a href="https://docs.gnosischain.com/node/manual/validator/deposit">Gnosis Chain Validator Setup</a></li>
<li><a href="https://github.com/NethermindEth/shutter-validator-registration">Shutter Validator Registration</a></li>
<li><a href="https://github.com/gnosischain/specs/tree/master/shutter">Shutter Specs</a></li>
<li><a href="https://explorer.shutter.network/system-overview">System Overview Dashboard</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="monitoring"><a class="header" href="#monitoring">Monitoring</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-a-dashboard"><a class="header" href="#creating-a-dashboard">Creating a dashboard</a></h1>
<p>You can set up monitoring for Erigon using Grafana and Prometheus. Erigon has built-in support for this monitoring stack with pre-configured dashboards and metrics collection. This guide will walk you through setting up a complete monitoring dashboard for Erigon using Prometheus and Grafana, leveraging the built-in monitoring tools provided in the Erigon codebase.</p>
<p>The monitoring setup leverages Erigon's built-in metrics system and provides comprehensive visibility into node performance, storage usage, and network activity. The pre-configured dashboards are actively maintained and include metrics for both execution and consensus layer operations when running with Caplin.</p>
<h2 id="prerequisites-5"><a class="header" href="#prerequisites-5">Prerequisites</a></h2>
<ul>
<li>Docker and Docker Compose installed</li>
<li>Erigon node running</li>
<li>Basic understanding of Prometheus and Grafana</li>
</ul>
<h2 id="step-1-enable-metrics-in-erigon"><a class="header" href="#step-1-enable-metrics-in-erigon">Step 1: Enable Metrics in Erigon</a></h2>
<p>First, you need to enable metrics collection in your Erigon instance by adding the <code>--metrics</code> flag.</p>
<pre><code class="language-bash">./erigon --metrics --datadir=/your/data/dir
</code></pre>
<p>If you need to specify a custom metrics address, use <code>--metrics.addr</code>.</p>
<h2 id="step-2-configure-prometheus-targets"><a class="header" href="#step-2-configure-prometheus-targets">Step 2: Configure Prometheus Targets</a></h2>
<p>Add your Erigon hosts to the Prometheus configuration file:</p>
<ol>
<li>Copy the default configuration: <code>./cmd/prometheus/prometheus.yml</code></li>
<li>Edit the file to include your Erigon instance endpoints</li>
<li>Save the modified configuration file</li>
</ol>
<h2 id="step-3-launch-monitoring-stack"><a class="header" href="#step-3-launch-monitoring-stack">Step 3: Launch Monitoring Stack</a></h2>
<p>Erigon provides a simple Docker Compose setup for the monitoring stack:</p>
<pre><code class="language-bash">docker compose up -d prometheus grafana
</code></pre>
<p>Alternatively, you can use the make target:</p>
<pre><code class="language-bash">make prometheus
</code></pre>
<h2 id="step-4-access-grafana-dashboard"><a class="header" href="#step-4-access-grafana-dashboard">Step 4: Access Grafana Dashboard</a></h2>
<p>Once the containers are running, access Grafana at <a href="http://localhost:3000">localhost:3000</a>.</p>
<p><strong>Default credentials:</strong> <code>admin/admin</code></p>
<h2 id="step-5-pre-configured-dashboards"><a class="header" href="#step-5-pre-configured-dashboards">Step 5: Pre-configured Dashboards</a></h2>
<p>Erigon comes with comprehensive pre-built dashboards that monitor various aspects of the node:</p>
<h3 id="main-dashboard-features"><a class="header" href="#main-dashboard-features">Main Dashboard Features</a></h3>
<p>The <code>erigon_internals.json</code> dashboard includes panels for:</p>
<ul>
<li><strong>Storage Monitoring</strong>: Snapshots, chaindata, and temp directory sizes</li>
<li><strong>Block Processing</strong>: Block importing latency and execution times</li>
<li><strong>Network Activity</strong>: Gossip bandwidth and P2P metrics</li>
<li><strong>State Management</strong>: Domain operations and pruning statistics</li>
</ul>
<h3 id="key-metrics-to-monitor"><a class="header" href="#key-metrics-to-monitor">Key Metrics to Monitor</a></h3>
<ol>
<li><strong>Block Execution Speed</strong> - Measures how long it takes Erigon to execute individual blocks</li>
<li><strong>Storage Growth</strong> - Monitor chaindata and snapshot sizes</li>
<li><strong>Processing Times</strong> - Track validation and execution latencies</li>
</ol>
<h2 id="step-6-environment-configuration"><a class="header" href="#step-6-environment-configuration">Step 6: Environment Configuration</a></h2>
<p>You can customize the setup using environment variables:</p>
<ul>
<li><code>XDG_DATA_HOME</code>: Changes default database folder location</li>
<li><code>ERIGON_PROMETHEUS_CONFIG</code>: Path to custom prometheus.yml file</li>
<li><code>ERIGON_GRAFANA_CONFIG</code>: Path to custom grafana.ini file</li>
</ul>
<p>Example with custom configuration:</p>
<pre><code class="language-bash">ERIGON_PROMETHEUS_CONFIG=/path/to/custom/prometheus.yml docker compose up prometheus grafana
</code></pre>
<h2 id="step-7-adding-custom-hosts"><a class="header" href="#step-7-adding-custom-hosts">Step 7: Adding Custom Hosts</a></h2>
<p>To monitor multiple Erigon instances:</p>
<ol>
<li>Copy <code>./cmd/prometheus/prometheus.yml</code></li>
<li>Add your additional Erigon hosts to the targets</li>
<li>Use the custom config: <code>ERIGON_PROMETHEUS_CONFIG=/new/location/prometheus.yml docker compose up prometheus grafana</code></li>
</ol>
<h2 id="step-8-memory-usage-monitoring"><a class="header" href="#step-8-memory-usage-monitoring">Step 8: Memory Usage Monitoring</a></h2>
<p>The dashboard includes proper memory usage tracking that accounts for OS page cache. This is important because standard tools like <code>htop</code> can be misleading for Erigon memory usage. Erigon's internal database (MDBX) uses <code>MemoryMap</code> where the OS manages all read, write, and cache operations instead of the application. The <code>htop</code> tool shows "App + OS used to hold page cache for given App" in the <code>res</code> column, but this isn't informative because most of that memory is OS page cache that gets automatically freed when needed.</p>
<p>The pre-configured Grafana dashboards include specific memory monitoring panels. The main <code>erigon.json</code> dashboard tracks Go memory statistics including:</p>
<ul>
<li><code>go_memstats_heap_alloc_bytes</code>: Current heap allocation</li>
<li><code>go_memstats_sys_bytes</code>: Total system memory</li>
<li><code>go_memstats_stack_inuse_bytes</code>: Stack memory in use</li>
</ul>
<p>Erigon uses approximately 4GB of RAM during genesis sync and around 1GB during normal operation, while OS page cache can utilize unlimited memory <a href="monitoring/creating-a-dashboard.html#1-8">9</a> . The system is designed so that OS page cache automatically manages memory allocation and can be shared between multiple processes accessing the same database files.</p>
<h2 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h2>
<ul>
<li>Ensure Erigon is running with <code>--metrics</code> flag enabled</li>
<li>Verify Prometheus can reach your Erigon metrics endpoint (default port varies)</li>
<li>Check Docker container logs if services fail to start</li>
<li>Confirm firewall settings allow access to monitoring ports</li>
</ul>
<h2 id="developers-1"><a class="header" href="#developers-1">Developers</a></h2>
<p>For developers wanting to add custom metrics, examples can be found in the codebase, and gRPC metrics are available by searching for <code>grpc_prometheus.Register</code> in the code.</p>
<!--
### Citations

**File:** cmd/prometheus/Readme.md (L1-1)
```markdown
Add flag `--metrics` to Erigon or any other process (add `--metrics.addr` if need).
```

**File:** cmd/prometheus/Readme.md (L3-3)
```markdown
Add hosts to collecting metrics in: `./cmd/prometheus/prometheus.yml`
```

**File:** cmd/prometheus/Readme.md (L5-5)
```markdown
Run Grafana and Prometheus: `docker compose up -d prometheus grafana` or `make prometheus`
```

**File:** cmd/prometheus/Readme.md (L7-7)
```markdown
Go to: [localhost:3000](localhost:3000), admin/admin
```

**File:** cmd/prometheus/Readme.md (L9-13)
```markdown
Env variables:

- `XDG_DATA_HOME` re-defines default prometheus and grafana databases folder.
- `ERIGON_PROMETHEUS_CONFIG` path to custom `prometheus.yml` file. Default is: `./cmd/prometheus/prometheus.yml`
- `ERIGON_GRAFANA_CONFIG` path to custom `grafana.ini file`. Default is: `./cmd/prometheus/grafana.ini`
```

**File:** cmd/prometheus/Readme.md (L15-16)
```markdown
To add custom Erigon host: copy `./cmd/prometheus/prometheus.yml`, modify, pass new location by:
`ERIGON_PROMETHEUS_CONFIG=/new/location/prometheus.yml docker compose up prometheus grafana`
```

**File:** cmd/prometheus/Readme.md (L29-31)
```markdown
See example: `ethdb/object_db.go:dbGetTimer`

```

**File:** cmd/prometheus/dashboards/erigon_internals.json (L1-60)
```json
{
  "__inputs": [
    {
      "name": "DS_GRAFANACLOUD-ERIGONOVHMONITORING-PROM",
      "label": "grafanacloud-erigonovhmonitoring-prom",
      "description": "",
      "type": "datasource",
      "pluginId": "prometheus",
      "pluginName": "Prometheus"
    }
  ],
  "__elements": {},
  "__requires": [
    {
      "type": "panel",
      "id": "barchart",
      "name": "Bar chart",
      "version": ""
    },
    {
      "type": "panel",
      "id": "bargauge",
      "name": "Bar gauge",
      "version": ""
    },
    {
      "type": "panel",
      "id": "gauge",
      "name": "Gauge",
      "version": ""
    },
    {
      "type": "grafana",
      "id": "grafana",
      "name": "Grafana",
      "version": "12.1.0-91295"
    },
    {
      "type": "panel",
      "id": "piechart",
      "name": "Pie chart",
      "version": ""
    },
    {
      "type": "datasource",
      "id": "prometheus",
      "name": "Prometheus",
      "version": "1.0.0"
    },
    {
      "type": "panel",
      "id": "stat",
      "name": "Stat",
      "version": ""
    },
    {
      "type": "panel",
      "id": "timeseries",
      "name": "Time series",
      "version": ""
```

**File:** cmd/prometheus/dashboards/erigon_internals.json (L185-195)
```json
              "expr": "devops_erigon_dirs_size_total{directory=\"/erigon-data/snapshots\", instance=~\"$nodo\"}",
              "legendFormat": "__auto",
              "range": true,
              "refId": "A",
              "datasource": {
                "type": "prometheus",
                "uid": "${DS_GRAFANACLOUD-ERIGONOVHMONITORING-PROM}"
              }
            }
          ],
          "title": "<datadir>/SNAPSHOTS TOTAL SIZE (GB)",
```

**File:** cmd/prometheus/dashboards/erigon_internals.json (L282-292)
```json
              "expr": "devops_erigon_dirs_size_total{directory=\"/erigon-data/chaindata\", instance=~\"$nodo\"}",
              "legendFormat": "__auto",
              "range": true,
              "refId": "A",
              "datasource": {
                "type": "prometheus",
                "uid": "${DS_GRAFANACLOUD-ERIGONOVHMONITORING-PROM}"
              }
            }
          ],
          "title": "<datadir>/CHAINDATA size (GB)",
```

**File:** cmd/prometheus/dashboards/erigon_internals.json (L1867-1877)
```json
              "expr": "block_importing_latency{instance=~\"$instance\"}",
              "legendFormat": "{{label_name}} {{instance}}",
              "range": true,
              "refId": "A",
              "datasource": {
                "type": "prometheus",
                "uid": "${DS_GRAFANACLOUD-ERIGONOVHMONITORING-PROM}"
              }
            }
          ],
          "title": "Block importing latency",
```

**File:** cmd/prometheus/dashboards/erigon_internals.json (L2583-2593)
```json
              "expr": "execution_time{instance=~\"$instance\"}",
              "legendFormat": "{{label_name}} {{instance}}",
              "range": true,
              "refId": "A",
              "datasource": {
                "type": "prometheus",
                "uid": "${DS_GRAFANACLOUD-ERIGONOVHMONITORING-PROM}"
              }
            }
          ],
          "title": "ValidateChain: time spent",
```

**File:** cmd/prometheus/dashboards/erigon_internals.json (L3153-3166)
```json
              "expr": "rate(gossip_topics_seen_beacon_block{instance=~\"$instance\"}[$__rate_interval])/125 > 0  ",
              "fullMetaSearch": false,
              "includeNullMetadata": true,
              "legendFormat": "kb/s {{instance}}",
              "range": true,
              "refId": "A",
              "useBackend": false,
              "datasource": {
                "type": "prometheus",
                "uid": "${DS_GRAFANACLOUD-ERIGONOVHMONITORING-PROM}"
              }
            }
          ],
          "title": "Beacon Block Gossip bandwidth",
```

**File:** cmd/prometheus/dashboards/erigon_internals.json (L4324-4345)
```json
              "expr": "domain_running_files_building{instance=~\"$instance\"}",
              "hide": false,
              "instant": false,
              "legendFormat": "running files building: {{instance}}",
              "range": true,
              "refId": "E"
            },
            {
              "datasource": {
                "type": "prometheus",
                "uid": "${DS_GRAFANACLOUD-ERIGONOVHMONITORING-PROM}"
              },
              "editorMode": "code",
              "expr": "domain_wal_flushes{instance=~\"$instance\"}",
              "hide": false,
              "instant": false,
              "legendFormat": "WAL flushes {{instance}}",
              "range": true,
              "refId": "F"
            }
          ],
          "title": "State: running collate/merge/prune",
```

**File:** cmd/prometheus/dashboards/erigon_internals.json (L5716-5725)
```json
              "expr": "chain_execution_seconds{quantile=\"$quantile\",instance=~\"$instance\"}",
              "format": "time_series",
              "interval": "",
              "intervalFactor": 1,
              "legendFormat": "execution: {{instance}}",
              "range": true,
              "refId": "A"
            }
          ],
          "title": "Block Execution speed ",
```

**File:** README.md (L443-443)
```markdown
`docker compose up prometheus grafana`, [detailed docs](./cmd/prometheus/Readme.md).
```

**File:** README.md (L751-755)
```markdown
`htop` on column `res` shows memory of "App + OS used to hold page cache for given App", but it's not informative,
because if `htop` says that app using 90% of memory you still can run 3 more instances of app on the same machine -
because most of that `90%` is "OS pages cache".
OS automatically frees this cache any time it needs memory. Smaller "page cache size" may not impact performance of
Erigon at all.
```

**File:** README.md (L762-763)
```markdown
- `Prometheus` dashboard shows memory of Go app without OS pages cache (`make prometheus`, open in
  browser `localhost:3000`, credentials `admin/admin`)
```
--><div style="break-before: page; page-break-before: always;"></div><h1 id="understanding-dashboards"><a class="header" href="#understanding-dashboards">Understanding dashboards</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="otterscan"><a class="header" href="#otterscan">Otterscan</a></h1>
<p>Otterscan is an Ethereum block explorer designed to be run locally along with Erigon.</p>
<p>Entirely based on open source code, it is blazing fast and fully private since it works on your local machine. The user interface is intentionally very similar, but with many improvements, to the most popular Ethereum block explorer to make it easy to locate where the information is.
Installation and usage instructions</p>
<p>For the installation and usage follow the official documentation at <a href="https://docs.otterscan.io/">https://docs.otterscan.io/</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="about"><a class="header" href="#about">About</a></h1>
<p>This documentation is open source, contribute at <a href="https://github.com/erigontech/erigon">https://github.com/erigontech/erigon</a>.</p>
<p>This book is built on <a href="https://rust-lang.github.io/mdBook/">mdbook</a> for local use and rendered on Gitbook.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="license"><a class="header" href="#license">License</a></h1>
<p>Copyright 2025 Erigon Technologies AG.</p>
<p>Licensed under the <a href="https://github.com/erigontech/erigon/blob/release/2.60/COPYING.LESSER">LGPL-3.0</a>, <a href="https://github.com/erigontech/erigon/blob/release/2.60/COPYING">GPL-3.0</a>.</p>
<p><em>Permissions of this copyleft license are conditioned on making available complete source code of licensed works and modifications under the same license or the GNU GPLv3. Copyright and license notices must be preserved. Contributors provide an express grant of patent rights. However, a larger work using the licensed work through interfaces provided by the licensed work may be distributed under different terms and without source code for the larger work.</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="disclaimer"><a class="header" href="#disclaimer">Disclaimer</a></h1>
<p>The Erigon team does not take any responsibility for losses or damages occurred through the use of Erigon. While we employ a seasoned in-house security team, we have not subjected our systems to independent third-party security assessments.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="donate"><a class="header" href="#donate">Donate</a></h1>
<p><em>Driving Ethereum progress through community-supported research and development</em></p>
<p>Erigon Technologies AG is a non-profit company dedicated to advancing Ethereum technology for the public good. Our work is funded entirely by grants from blockchain companies and donations from our community.</p>
<p>Your contribution will help us to:</p>
<ul>
<li>Advance the Ethereum protocol for a more secure, efficient, and user-friendly experience</li>
<li>Foster innovation, collaboration, and open-source development</li>
<li>Empower individuals and organizations to harness blockchain technology</li>
</ul>
<p>Every donation brings us closer to a more decentralized, equitable, and connected world.</p>
<p>Support Erigon's mission today and help shape the future of Ethereum by donating to our Gitcoin grant address <a href="https://etherscan.io/address/0x8BFBB529A9E85fDC4b70A4FCdC0D68Bb298B8816">0x8BFBB529A9E85fDC4b70A4FCdC0D68Bb298B8816</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-reach-us"><a class="header" href="#how-to-reach-us">How to reach us</a></h1>
<p>The Erigon Technologies AG office is located in the CV Labs in Zug:</p>
<pre><code>Erigon Technologies AG
Damstrasse 16
6300 Zug
Switzerland
</code></pre>
<p><strong><a href="https://erigon.tech">erigon.tech</a></strong></p>
<h2 id="erigon-discord-server"><a class="header" href="#erigon-discord-server">Erigon Discord Server</a></h2>
<p>The most important discussions take place on the Discord server where also some support is provided. To get an invite, send an email to bloxster [at] proton.me with your name, profession, a short explanation why you want to join the Discord server and how you heard about Erigon.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
