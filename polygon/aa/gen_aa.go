// Code generated by abigen. DO NOT EDIT.
// This file is a generated binding and any manual changes will be lost.

package aa

import (
	"fmt"
	"math/big"
	"reflect"
	"strings"

	ethereum "github.com/erigontech/erigon"
	libcommon "github.com/erigontech/erigon-lib/common"
	"github.com/erigontech/erigon/accounts/abi"
	"github.com/erigontech/erigon/accounts/abi/bind"
	"github.com/erigontech/erigon/core/types"
	"github.com/erigontech/erigon/event"
)

// Reference imports to suppress errors if they are not otherwise used.
var (
	_ = big.NewInt
	_ = strings.NewReader
	_ = ethereum.NotFound
	_ = bind.Bind
	_ = libcommon.Big1
	_ = types.BloomLookup
	_ = event.NewSubscription
	_ = fmt.Errorf
	_ = reflect.ValueOf
)

// AaABI is the input ABI used to generate the binding from.
const AaABI = "[{\"type\":\"function\",\"name\":\"validateTransaction\",\"inputs\":[{\"name\":\"version\",\"type\":\"uint256\"},{\"name\":\"txHash\",\"type\":\"bytes32\"},{\"name\":\"transaction\",\"type\":\"bytes\"}]},{\"type\":\"function\",\"name\":\"validatePaymasterTransaction\",\"inputs\":[{\"name\":\"version\",\"type\":\"uint256\"},{\"name\":\"txHash\",\"type\":\"bytes32\"},{\"name\":\"transaction\",\"type\":\"bytes\"}]},{\"type\":\"function\",\"name\":\"postPaymasterTransaction\",\"inputs\":[{\"name\":\"success\",\"type\":\"bool\"},{\"name\":\"actualGasCost\",\"type\":\"uint256\"},{\"name\":\"context\",\"type\":\"bytes\"}]},{\"type\":\"function\",\"name\":\"acceptAccount\",\"inputs\":[{\"name\":\"validAfter\",\"type\":\"uint256\"},{\"name\":\"validUntil\",\"type\":\"uint256\"}]},{\"type\":\"function\",\"name\":\"acceptPaymaster\",\"inputs\":[{\"name\":\"validAfter\",\"type\":\"uint256\"},{\"name\":\"validUntil\",\"type\":\"uint256\"},{\"name\":\"context\",\"type\":\"bytes\"}]},{\"type\":\"function\",\"name\":\"sigFailAccount\",\"inputs\":[{\"name\":\"validAfter\",\"type\":\"uint256\"},{\"name\":\"validUntil\",\"type\":\"uint256\"}]},{\"type\":\"function\",\"name\":\"sigFailPaymaster\",\"inputs\":[{\"name\":\"validAfter\",\"type\":\"uint256\"},{\"name\":\"validUntil\",\"type\":\"uint256\"},{\"name\":\"context\",\"type\":\"bytes\"}]},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"paymaster\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonceKey\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonceSequence\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"executionStatus\",\"type\":\"uint256\"}],\"name\":\"RIP7560TransactionEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonceKey\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonceSequence\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"revertReason\",\"type\":\"bytes\"}],\"name\":\"RIP7560TransactionRevertReason\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"paymaster\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonceKey\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonceSequence\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"revertReason\",\"type\":\"bytes\"}],\"name\":\"RIP7560TransactionPostOpRevertReason\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"paymaster\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"deployer\",\"type\":\"address\"}],\"name\":\"RIP7560AccountDeployed\",\"type\":\"event\"}]"

// Aa is an auto generated Go binding around an Ethereum contract.
type Aa struct {
	AaCaller     // Read-only binding to the contract
	AaTransactor // Write-only binding to the contract
	AaFilterer   // Log filterer for contract events
}

// AaCaller is an auto generated read-only Go binding around an Ethereum contract.
type AaCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// AaTransactor is an auto generated write-only Go binding around an Ethereum contract.
type AaTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// AaFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type AaFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// AaSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type AaSession struct {
	Contract     *Aa               // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// AaCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type AaCallerSession struct {
	Contract *AaCaller     // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts // Call options to use throughout this session
}

// AaTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type AaTransactorSession struct {
	Contract     *AaTransactor     // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// AaRaw is an auto generated low-level Go binding around an Ethereum contract.
type AaRaw struct {
	Contract *Aa // Generic contract binding to access the raw methods on
}

// AaCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type AaCallerRaw struct {
	Contract *AaCaller // Generic read-only contract binding to access the raw methods on
}

// AaTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type AaTransactorRaw struct {
	Contract *AaTransactor // Generic write-only contract binding to access the raw methods on
}

// NewAa creates a new instance of Aa, bound to a specific deployed contract.
func NewAa(address libcommon.Address, backend bind.ContractBackend) (*Aa, error) {
	contract, err := bindAa(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Aa{AaCaller: AaCaller{contract: contract}, AaTransactor: AaTransactor{contract: contract}, AaFilterer: AaFilterer{contract: contract}}, nil
}

// NewAaCaller creates a new read-only instance of Aa, bound to a specific deployed contract.
func NewAaCaller(address libcommon.Address, caller bind.ContractCaller) (*AaCaller, error) {
	contract, err := bindAa(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &AaCaller{contract: contract}, nil
}

// NewAaTransactor creates a new write-only instance of Aa, bound to a specific deployed contract.
func NewAaTransactor(address libcommon.Address, transactor bind.ContractTransactor) (*AaTransactor, error) {
	contract, err := bindAa(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &AaTransactor{contract: contract}, nil
}

// NewAaFilterer creates a new log filterer instance of Aa, bound to a specific deployed contract.
func NewAaFilterer(address libcommon.Address, filterer bind.ContractFilterer) (*AaFilterer, error) {
	contract, err := bindAa(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &AaFilterer{contract: contract}, nil
}

// bindAa binds a generic wrapper to an already deployed contract.
func bindAa(address libcommon.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(AaABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Aa *AaRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Aa.Contract.AaCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Aa *AaRaw) Transfer(opts *bind.TransactOpts) (types.Transaction, error) {
	return _Aa.Contract.AaTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Aa *AaRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (types.Transaction, error) {
	return _Aa.Contract.AaTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Aa *AaCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Aa.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Aa *AaTransactorRaw) Transfer(opts *bind.TransactOpts) (types.Transaction, error) {
	return _Aa.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Aa *AaTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (types.Transaction, error) {
	return _Aa.Contract.contract.Transact(opts, method, params...)
}

// AcceptAccount is a paid mutator transaction binding the contract method 0x1256ebd1.
//
// Solidity: function acceptAccount(uint256 validAfter, uint256 validUntil) returns()
func (_Aa *AaTransactor) AcceptAccount(opts *bind.TransactOpts, validAfter *big.Int, validUntil *big.Int) (types.Transaction, error) {
	return _Aa.contract.Transact(opts, "acceptAccount", validAfter, validUntil)
}

// AcceptAccount is a paid mutator transaction binding the contract method 0x1256ebd1.
//
// Solidity: function acceptAccount(uint256 validAfter, uint256 validUntil) returns()
func (_Aa *AaSession) AcceptAccount(validAfter *big.Int, validUntil *big.Int) (types.Transaction, error) {
	return _Aa.Contract.AcceptAccount(&_Aa.TransactOpts, validAfter, validUntil)
}

// AcceptAccount is a paid mutator transaction binding the contract method 0x1256ebd1.
//
// Solidity: function acceptAccount(uint256 validAfter, uint256 validUntil) returns()
func (_Aa *AaTransactorSession) AcceptAccount(validAfter *big.Int, validUntil *big.Int) (types.Transaction, error) {
	return _Aa.Contract.AcceptAccount(&_Aa.TransactOpts, validAfter, validUntil)
}

// AcceptPaymaster is a paid mutator transaction binding the contract method 0x03be8439.
//
// Solidity: function acceptPaymaster(uint256 validAfter, uint256 validUntil, bytes context) returns()
func (_Aa *AaTransactor) AcceptPaymaster(opts *bind.TransactOpts, validAfter *big.Int, validUntil *big.Int, context []byte) (types.Transaction, error) {
	return _Aa.contract.Transact(opts, "acceptPaymaster", validAfter, validUntil, context)
}

// AcceptPaymaster is a paid mutator transaction binding the contract method 0x03be8439.
//
// Solidity: function acceptPaymaster(uint256 validAfter, uint256 validUntil, bytes context) returns()
func (_Aa *AaSession) AcceptPaymaster(validAfter *big.Int, validUntil *big.Int, context []byte) (types.Transaction, error) {
	return _Aa.Contract.AcceptPaymaster(&_Aa.TransactOpts, validAfter, validUntil, context)
}

// AcceptPaymaster is a paid mutator transaction binding the contract method 0x03be8439.
//
// Solidity: function acceptPaymaster(uint256 validAfter, uint256 validUntil, bytes context) returns()
func (_Aa *AaTransactorSession) AcceptPaymaster(validAfter *big.Int, validUntil *big.Int, context []byte) (types.Transaction, error) {
	return _Aa.Contract.AcceptPaymaster(&_Aa.TransactOpts, validAfter, validUntil, context)
}

// PostPaymasterTransaction is a paid mutator transaction binding the contract method 0x34a4a77c.
//
// Solidity: function postPaymasterTransaction(bool success, uint256 actualGasCost, bytes context) returns()
func (_Aa *AaTransactor) PostPaymasterTransaction(opts *bind.TransactOpts, success bool, actualGasCost *big.Int, context []byte) (types.Transaction, error) {
	return _Aa.contract.Transact(opts, "postPaymasterTransaction", success, actualGasCost, context)
}

// PostPaymasterTransaction is a paid mutator transaction binding the contract method 0x34a4a77c.
//
// Solidity: function postPaymasterTransaction(bool success, uint256 actualGasCost, bytes context) returns()
func (_Aa *AaSession) PostPaymasterTransaction(success bool, actualGasCost *big.Int, context []byte) (types.Transaction, error) {
	return _Aa.Contract.PostPaymasterTransaction(&_Aa.TransactOpts, success, actualGasCost, context)
}

// PostPaymasterTransaction is a paid mutator transaction binding the contract method 0x34a4a77c.
//
// Solidity: function postPaymasterTransaction(bool success, uint256 actualGasCost, bytes context) returns()
func (_Aa *AaTransactorSession) PostPaymasterTransaction(success bool, actualGasCost *big.Int, context []byte) (types.Transaction, error) {
	return _Aa.Contract.PostPaymasterTransaction(&_Aa.TransactOpts, success, actualGasCost, context)
}

// SigFailAccount is a paid mutator transaction binding the contract method 0x7715fac2.
//
// Solidity: function sigFailAccount(uint256 validAfter, uint256 validUntil) returns()
func (_Aa *AaTransactor) SigFailAccount(opts *bind.TransactOpts, validAfter *big.Int, validUntil *big.Int) (types.Transaction, error) {
	return _Aa.contract.Transact(opts, "sigFailAccount", validAfter, validUntil)
}

// SigFailAccount is a paid mutator transaction binding the contract method 0x7715fac2.
//
// Solidity: function sigFailAccount(uint256 validAfter, uint256 validUntil) returns()
func (_Aa *AaSession) SigFailAccount(validAfter *big.Int, validUntil *big.Int) (types.Transaction, error) {
	return _Aa.Contract.SigFailAccount(&_Aa.TransactOpts, validAfter, validUntil)
}

// SigFailAccount is a paid mutator transaction binding the contract method 0x7715fac2.
//
// Solidity: function sigFailAccount(uint256 validAfter, uint256 validUntil) returns()
func (_Aa *AaTransactorSession) SigFailAccount(validAfter *big.Int, validUntil *big.Int) (types.Transaction, error) {
	return _Aa.Contract.SigFailAccount(&_Aa.TransactOpts, validAfter, validUntil)
}

// SigFailPaymaster is a paid mutator transaction binding the contract method 0x690b9956.
//
// Solidity: function sigFailPaymaster(uint256 validAfter, uint256 validUntil, bytes context) returns()
func (_Aa *AaTransactor) SigFailPaymaster(opts *bind.TransactOpts, validAfter *big.Int, validUntil *big.Int, context []byte) (types.Transaction, error) {
	return _Aa.contract.Transact(opts, "sigFailPaymaster", validAfter, validUntil, context)
}

// SigFailPaymaster is a paid mutator transaction binding the contract method 0x690b9956.
//
// Solidity: function sigFailPaymaster(uint256 validAfter, uint256 validUntil, bytes context) returns()
func (_Aa *AaSession) SigFailPaymaster(validAfter *big.Int, validUntil *big.Int, context []byte) (types.Transaction, error) {
	return _Aa.Contract.SigFailPaymaster(&_Aa.TransactOpts, validAfter, validUntil, context)
}

// SigFailPaymaster is a paid mutator transaction binding the contract method 0x690b9956.
//
// Solidity: function sigFailPaymaster(uint256 validAfter, uint256 validUntil, bytes context) returns()
func (_Aa *AaTransactorSession) SigFailPaymaster(validAfter *big.Int, validUntil *big.Int, context []byte) (types.Transaction, error) {
	return _Aa.Contract.SigFailPaymaster(&_Aa.TransactOpts, validAfter, validUntil, context)
}

// ValidatePaymasterTransaction is a paid mutator transaction binding the contract method 0xe0e6183a.
//
// Solidity: function validatePaymasterTransaction(uint256 version, bytes32 txHash, bytes transaction) returns()
func (_Aa *AaTransactor) ValidatePaymasterTransaction(opts *bind.TransactOpts, version *big.Int, txHash [32]byte, transaction []byte) (types.Transaction, error) {
	return _Aa.contract.Transact(opts, "validatePaymasterTransaction", version, txHash, transaction)
}

// ValidatePaymasterTransaction is a paid mutator transaction binding the contract method 0xe0e6183a.
//
// Solidity: function validatePaymasterTransaction(uint256 version, bytes32 txHash, bytes transaction) returns()
func (_Aa *AaSession) ValidatePaymasterTransaction(version *big.Int, txHash [32]byte, transaction []byte) (types.Transaction, error) {
	return _Aa.Contract.ValidatePaymasterTransaction(&_Aa.TransactOpts, version, txHash, transaction)
}

// ValidatePaymasterTransaction is a paid mutator transaction binding the contract method 0xe0e6183a.
//
// Solidity: function validatePaymasterTransaction(uint256 version, bytes32 txHash, bytes transaction) returns()
func (_Aa *AaTransactorSession) ValidatePaymasterTransaction(version *big.Int, txHash [32]byte, transaction []byte) (types.Transaction, error) {
	return _Aa.Contract.ValidatePaymasterTransaction(&_Aa.TransactOpts, version, txHash, transaction)
}

// ValidateTransaction is a paid mutator transaction binding the contract method 0xbf45c166.
//
// Solidity: function validateTransaction(uint256 version, bytes32 txHash, bytes transaction) returns()
func (_Aa *AaTransactor) ValidateTransaction(opts *bind.TransactOpts, version *big.Int, txHash [32]byte, transaction []byte) (types.Transaction, error) {
	return _Aa.contract.Transact(opts, "validateTransaction", version, txHash, transaction)
}

// ValidateTransaction is a paid mutator transaction binding the contract method 0xbf45c166.
//
// Solidity: function validateTransaction(uint256 version, bytes32 txHash, bytes transaction) returns()
func (_Aa *AaSession) ValidateTransaction(version *big.Int, txHash [32]byte, transaction []byte) (types.Transaction, error) {
	return _Aa.Contract.ValidateTransaction(&_Aa.TransactOpts, version, txHash, transaction)
}

// ValidateTransaction is a paid mutator transaction binding the contract method 0xbf45c166.
//
// Solidity: function validateTransaction(uint256 version, bytes32 txHash, bytes transaction) returns()
func (_Aa *AaTransactorSession) ValidateTransaction(version *big.Int, txHash [32]byte, transaction []byte) (types.Transaction, error) {
	return _Aa.Contract.ValidateTransaction(&_Aa.TransactOpts, version, txHash, transaction)
}

// AaAcceptAccountParams is an auto generated read-only Go binding of transcaction calldata params
type AaAcceptAccountParams struct {
	Param_validAfter *big.Int
	Param_validUntil *big.Int
}

// Parse AcceptAccount method from calldata of a transaction
//
// Solidity: function acceptAccount(uint256 validAfter, uint256 validUntil) returns()
func ParseAaAcceptAccountParams(calldata []byte) (*AaAcceptAccountParams, error) {
	if len(calldata) <= 4 {
		return nil, fmt.Errorf("invalid calldata input")
	}

	_abi, err := abi.JSON(strings.NewReader(AaABI))
	if err != nil {
		return nil, fmt.Errorf("failed to get abi of registry metadata: %w", err)
	}

	out, err := _abi.Methods["acceptAccount"].Inputs.Unpack(calldata[4:])
	if err != nil {
		return nil, fmt.Errorf("failed to unpack acceptAccount params data: %w", err)
	}

	var paramsResult = new(AaAcceptAccountParams)
	value := reflect.ValueOf(paramsResult).Elem()

	if value.NumField() != len(out) {
		return nil, fmt.Errorf("failed to match calldata with param field number")
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)
	out1 := *abi.ConvertType(out[1], new(*big.Int)).(**big.Int)

	return &AaAcceptAccountParams{
		Param_validAfter: out0, Param_validUntil: out1,
	}, nil
}

// AaAcceptPaymasterParams is an auto generated read-only Go binding of transcaction calldata params
type AaAcceptPaymasterParams struct {
	Param_validAfter *big.Int
	Param_validUntil *big.Int
	Param_context    []byte
}

// Parse AcceptPaymaster method from calldata of a transaction
//
// Solidity: function acceptPaymaster(uint256 validAfter, uint256 validUntil, bytes context) returns()
func ParseAaAcceptPaymasterParams(calldata []byte) (*AaAcceptPaymasterParams, error) {
	if len(calldata) <= 4 {
		return nil, fmt.Errorf("invalid calldata input")
	}

	_abi, err := abi.JSON(strings.NewReader(AaABI))
	if err != nil {
		return nil, fmt.Errorf("failed to get abi of registry metadata: %w", err)
	}

	out, err := _abi.Methods["acceptPaymaster"].Inputs.Unpack(calldata[4:])
	if err != nil {
		return nil, fmt.Errorf("failed to unpack acceptPaymaster params data: %w", err)
	}

	var paramsResult = new(AaAcceptPaymasterParams)
	value := reflect.ValueOf(paramsResult).Elem()

	if value.NumField() != len(out) {
		return nil, fmt.Errorf("failed to match calldata with param field number")
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)
	out1 := *abi.ConvertType(out[1], new(*big.Int)).(**big.Int)
	out2 := *abi.ConvertType(out[2], new([]byte)).(*[]byte)

	return &AaAcceptPaymasterParams{
		Param_validAfter: out0, Param_validUntil: out1, Param_context: out2,
	}, nil
}

// AaPostPaymasterTransactionParams is an auto generated read-only Go binding of transcaction calldata params
type AaPostPaymasterTransactionParams struct {
	Param_success       bool
	Param_actualGasCost *big.Int
	Param_context       []byte
}

// Parse PostPaymasterTransaction method from calldata of a transaction
//
// Solidity: function postPaymasterTransaction(bool success, uint256 actualGasCost, bytes context) returns()
func ParseAaPostPaymasterTransactionParams(calldata []byte) (*AaPostPaymasterTransactionParams, error) {
	if len(calldata) <= 4 {
		return nil, fmt.Errorf("invalid calldata input")
	}

	_abi, err := abi.JSON(strings.NewReader(AaABI))
	if err != nil {
		return nil, fmt.Errorf("failed to get abi of registry metadata: %w", err)
	}

	out, err := _abi.Methods["postPaymasterTransaction"].Inputs.Unpack(calldata[4:])
	if err != nil {
		return nil, fmt.Errorf("failed to unpack postPaymasterTransaction params data: %w", err)
	}

	var paramsResult = new(AaPostPaymasterTransactionParams)
	value := reflect.ValueOf(paramsResult).Elem()

	if value.NumField() != len(out) {
		return nil, fmt.Errorf("failed to match calldata with param field number")
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)
	out1 := *abi.ConvertType(out[1], new(*big.Int)).(**big.Int)
	out2 := *abi.ConvertType(out[2], new([]byte)).(*[]byte)

	return &AaPostPaymasterTransactionParams{
		Param_success: out0, Param_actualGasCost: out1, Param_context: out2,
	}, nil
}

// AaSigFailAccountParams is an auto generated read-only Go binding of transcaction calldata params
type AaSigFailAccountParams struct {
	Param_validAfter *big.Int
	Param_validUntil *big.Int
}

// Parse SigFailAccount method from calldata of a transaction
//
// Solidity: function sigFailAccount(uint256 validAfter, uint256 validUntil) returns()
func ParseAaSigFailAccountParams(calldata []byte) (*AaSigFailAccountParams, error) {
	if len(calldata) <= 4 {
		return nil, fmt.Errorf("invalid calldata input")
	}

	_abi, err := abi.JSON(strings.NewReader(AaABI))
	if err != nil {
		return nil, fmt.Errorf("failed to get abi of registry metadata: %w", err)
	}

	out, err := _abi.Methods["sigFailAccount"].Inputs.Unpack(calldata[4:])
	if err != nil {
		return nil, fmt.Errorf("failed to unpack sigFailAccount params data: %w", err)
	}

	var paramsResult = new(AaSigFailAccountParams)
	value := reflect.ValueOf(paramsResult).Elem()

	if value.NumField() != len(out) {
		return nil, fmt.Errorf("failed to match calldata with param field number")
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)
	out1 := *abi.ConvertType(out[1], new(*big.Int)).(**big.Int)

	return &AaSigFailAccountParams{
		Param_validAfter: out0, Param_validUntil: out1,
	}, nil
}

// AaSigFailPaymasterParams is an auto generated read-only Go binding of transcaction calldata params
type AaSigFailPaymasterParams struct {
	Param_validAfter *big.Int
	Param_validUntil *big.Int
	Param_context    []byte
}

// Parse SigFailPaymaster method from calldata of a transaction
//
// Solidity: function sigFailPaymaster(uint256 validAfter, uint256 validUntil, bytes context) returns()
func ParseAaSigFailPaymasterParams(calldata []byte) (*AaSigFailPaymasterParams, error) {
	if len(calldata) <= 4 {
		return nil, fmt.Errorf("invalid calldata input")
	}

	_abi, err := abi.JSON(strings.NewReader(AaABI))
	if err != nil {
		return nil, fmt.Errorf("failed to get abi of registry metadata: %w", err)
	}

	out, err := _abi.Methods["sigFailPaymaster"].Inputs.Unpack(calldata[4:])
	if err != nil {
		return nil, fmt.Errorf("failed to unpack sigFailPaymaster params data: %w", err)
	}

	var paramsResult = new(AaSigFailPaymasterParams)
	value := reflect.ValueOf(paramsResult).Elem()

	if value.NumField() != len(out) {
		return nil, fmt.Errorf("failed to match calldata with param field number")
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)
	out1 := *abi.ConvertType(out[1], new(*big.Int)).(**big.Int)
	out2 := *abi.ConvertType(out[2], new([]byte)).(*[]byte)

	return &AaSigFailPaymasterParams{
		Param_validAfter: out0, Param_validUntil: out1, Param_context: out2,
	}, nil
}

// AaValidatePaymasterTransactionParams is an auto generated read-only Go binding of transcaction calldata params
type AaValidatePaymasterTransactionParams struct {
	Param_version     *big.Int
	Param_txHash      [32]byte
	Param_transaction []byte
}

// Parse ValidatePaymasterTransaction method from calldata of a transaction
//
// Solidity: function validatePaymasterTransaction(uint256 version, bytes32 txHash, bytes transaction) returns()
func ParseAaValidatePaymasterTransactionParams(calldata []byte) (*AaValidatePaymasterTransactionParams, error) {
	if len(calldata) <= 4 {
		return nil, fmt.Errorf("invalid calldata input")
	}

	_abi, err := abi.JSON(strings.NewReader(AaABI))
	if err != nil {
		return nil, fmt.Errorf("failed to get abi of registry metadata: %w", err)
	}

	out, err := _abi.Methods["validatePaymasterTransaction"].Inputs.Unpack(calldata[4:])
	if err != nil {
		return nil, fmt.Errorf("failed to unpack validatePaymasterTransaction params data: %w", err)
	}

	var paramsResult = new(AaValidatePaymasterTransactionParams)
	value := reflect.ValueOf(paramsResult).Elem()

	if value.NumField() != len(out) {
		return nil, fmt.Errorf("failed to match calldata with param field number")
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)
	out1 := *abi.ConvertType(out[1], new([32]byte)).(*[32]byte)
	out2 := *abi.ConvertType(out[2], new([]byte)).(*[]byte)

	return &AaValidatePaymasterTransactionParams{
		Param_version: out0, Param_txHash: out1, Param_transaction: out2,
	}, nil
}

// AaValidateTransactionParams is an auto generated read-only Go binding of transcaction calldata params
type AaValidateTransactionParams struct {
	Param_version     *big.Int
	Param_txHash      [32]byte
	Param_transaction []byte
}

// Parse ValidateTransaction method from calldata of a transaction
//
// Solidity: function validateTransaction(uint256 version, bytes32 txHash, bytes transaction) returns()
func ParseAaValidateTransactionParams(calldata []byte) (*AaValidateTransactionParams, error) {
	if len(calldata) <= 4 {
		return nil, fmt.Errorf("invalid calldata input")
	}

	_abi, err := abi.JSON(strings.NewReader(AaABI))
	if err != nil {
		return nil, fmt.Errorf("failed to get abi of registry metadata: %w", err)
	}

	out, err := _abi.Methods["validateTransaction"].Inputs.Unpack(calldata[4:])
	if err != nil {
		return nil, fmt.Errorf("failed to unpack validateTransaction params data: %w", err)
	}

	var paramsResult = new(AaValidateTransactionParams)
	value := reflect.ValueOf(paramsResult).Elem()

	if value.NumField() != len(out) {
		return nil, fmt.Errorf("failed to match calldata with param field number")
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)
	out1 := *abi.ConvertType(out[1], new([32]byte)).(*[32]byte)
	out2 := *abi.ConvertType(out[2], new([]byte)).(*[]byte)

	return &AaValidateTransactionParams{
		Param_version: out0, Param_txHash: out1, Param_transaction: out2,
	}, nil
}

// AaRIP7560AccountDeployedIterator is returned from FilterRIP7560AccountDeployed and is used to iterate over the raw logs and unpacked data for RIP7560AccountDeployed events raised by the Aa contract.
type AaRIP7560AccountDeployedIterator struct {
	Event *AaRIP7560AccountDeployed // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AaRIP7560AccountDeployedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AaRIP7560AccountDeployed)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AaRIP7560AccountDeployed)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AaRIP7560AccountDeployedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AaRIP7560AccountDeployedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AaRIP7560AccountDeployed represents a RIP7560AccountDeployed event raised by the Aa contract.
type AaRIP7560AccountDeployed struct {
	Sender    libcommon.Address
	Paymaster libcommon.Address
	Deployer  libcommon.Address
	Raw       types.Log // Blockchain specific contextual infos
}

func (_Aa *AaFilterer) RIP7560AccountDeployedEventID() libcommon.Hash {
	return libcommon.HexToHash("0x585ce73b2237756a4582bb105e951716f39495f58685b04aeb997fae4d2f699a")
}

// FilterRIP7560AccountDeployed is a free log retrieval operation binding the contract event 0x585ce73b2237756a4582bb105e951716f39495f58685b04aeb997fae4d2f699a.
//
// Solidity: event RIP7560AccountDeployed(address indexed sender, address indexed paymaster, address indexed deployer)
func (_Aa *AaFilterer) FilterRIP7560AccountDeployed(opts *bind.FilterOpts, sender []libcommon.Address, paymaster []libcommon.Address, deployer []libcommon.Address) (*AaRIP7560AccountDeployedIterator, error) {

	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}
	var paymasterRule []interface{}
	for _, paymasterItem := range paymaster {
		paymasterRule = append(paymasterRule, paymasterItem)
	}
	var deployerRule []interface{}
	for _, deployerItem := range deployer {
		deployerRule = append(deployerRule, deployerItem)
	}

	logs, sub, err := _Aa.contract.FilterLogs(opts, "RIP7560AccountDeployed", senderRule, paymasterRule, deployerRule)
	if err != nil {
		return nil, err
	}
	return &AaRIP7560AccountDeployedIterator{contract: _Aa.contract, event: "RIP7560AccountDeployed", logs: logs, sub: sub}, nil
}

// WatchRIP7560AccountDeployed is a free log subscription operation binding the contract event 0x585ce73b2237756a4582bb105e951716f39495f58685b04aeb997fae4d2f699a.
//
// Solidity: event RIP7560AccountDeployed(address indexed sender, address indexed paymaster, address indexed deployer)
func (_Aa *AaFilterer) WatchRIP7560AccountDeployed(opts *bind.WatchOpts, sink chan<- *AaRIP7560AccountDeployed, sender []libcommon.Address, paymaster []libcommon.Address, deployer []libcommon.Address) (event.Subscription, error) {

	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}
	var paymasterRule []interface{}
	for _, paymasterItem := range paymaster {
		paymasterRule = append(paymasterRule, paymasterItem)
	}
	var deployerRule []interface{}
	for _, deployerItem := range deployer {
		deployerRule = append(deployerRule, deployerItem)
	}

	logs, sub, err := _Aa.contract.WatchLogs(opts, "RIP7560AccountDeployed", senderRule, paymasterRule, deployerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AaRIP7560AccountDeployed)
				if err := _Aa.contract.UnpackLog(event, "RIP7560AccountDeployed", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRIP7560AccountDeployed is a log parse operation binding the contract event 0x585ce73b2237756a4582bb105e951716f39495f58685b04aeb997fae4d2f699a.
//
// Solidity: event RIP7560AccountDeployed(address indexed sender, address indexed paymaster, address indexed deployer)
func (_Aa *AaFilterer) ParseRIP7560AccountDeployed(log types.Log) (*AaRIP7560AccountDeployed, error) {
	event := new(AaRIP7560AccountDeployed)
	if err := _Aa.contract.UnpackLog(event, "RIP7560AccountDeployed", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AaRIP7560TransactionEventIterator is returned from FilterRIP7560TransactionEvent and is used to iterate over the raw logs and unpacked data for RIP7560TransactionEvent events raised by the Aa contract.
type AaRIP7560TransactionEventIterator struct {
	Event *AaRIP7560TransactionEvent // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AaRIP7560TransactionEventIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AaRIP7560TransactionEvent)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AaRIP7560TransactionEvent)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AaRIP7560TransactionEventIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AaRIP7560TransactionEventIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AaRIP7560TransactionEvent represents a RIP7560TransactionEvent event raised by the Aa contract.
type AaRIP7560TransactionEvent struct {
	Sender          libcommon.Address
	Paymaster       libcommon.Address
	NonceKey        *big.Int
	NonceSequence   *big.Int
	ExecutionStatus *big.Int
	Raw             types.Log // Blockchain specific contextual infos
}

func (_Aa *AaFilterer) RIP7560TransactionEventEventID() libcommon.Hash {
	return libcommon.HexToHash("0xed8077bf75e28dafe1cbe4afff46390f2bf136b1fe7264ab2e4ddfc22ae4f845")
}

// FilterRIP7560TransactionEvent is a free log retrieval operation binding the contract event 0xed8077bf75e28dafe1cbe4afff46390f2bf136b1fe7264ab2e4ddfc22ae4f845.
//
// Solidity: event RIP7560TransactionEvent(address indexed sender, address indexed paymaster, uint256 nonceKey, uint256 nonceSequence, uint256 executionStatus)
func (_Aa *AaFilterer) FilterRIP7560TransactionEvent(opts *bind.FilterOpts, sender []libcommon.Address, paymaster []libcommon.Address) (*AaRIP7560TransactionEventIterator, error) {

	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}
	var paymasterRule []interface{}
	for _, paymasterItem := range paymaster {
		paymasterRule = append(paymasterRule, paymasterItem)
	}

	logs, sub, err := _Aa.contract.FilterLogs(opts, "RIP7560TransactionEvent", senderRule, paymasterRule)
	if err != nil {
		return nil, err
	}
	return &AaRIP7560TransactionEventIterator{contract: _Aa.contract, event: "RIP7560TransactionEvent", logs: logs, sub: sub}, nil
}

// WatchRIP7560TransactionEvent is a free log subscription operation binding the contract event 0xed8077bf75e28dafe1cbe4afff46390f2bf136b1fe7264ab2e4ddfc22ae4f845.
//
// Solidity: event RIP7560TransactionEvent(address indexed sender, address indexed paymaster, uint256 nonceKey, uint256 nonceSequence, uint256 executionStatus)
func (_Aa *AaFilterer) WatchRIP7560TransactionEvent(opts *bind.WatchOpts, sink chan<- *AaRIP7560TransactionEvent, sender []libcommon.Address, paymaster []libcommon.Address) (event.Subscription, error) {

	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}
	var paymasterRule []interface{}
	for _, paymasterItem := range paymaster {
		paymasterRule = append(paymasterRule, paymasterItem)
	}

	logs, sub, err := _Aa.contract.WatchLogs(opts, "RIP7560TransactionEvent", senderRule, paymasterRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AaRIP7560TransactionEvent)
				if err := _Aa.contract.UnpackLog(event, "RIP7560TransactionEvent", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRIP7560TransactionEvent is a log parse operation binding the contract event 0xed8077bf75e28dafe1cbe4afff46390f2bf136b1fe7264ab2e4ddfc22ae4f845.
//
// Solidity: event RIP7560TransactionEvent(address indexed sender, address indexed paymaster, uint256 nonceKey, uint256 nonceSequence, uint256 executionStatus)
func (_Aa *AaFilterer) ParseRIP7560TransactionEvent(log types.Log) (*AaRIP7560TransactionEvent, error) {
	event := new(AaRIP7560TransactionEvent)
	if err := _Aa.contract.UnpackLog(event, "RIP7560TransactionEvent", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AaRIP7560TransactionPostOpRevertReasonIterator is returned from FilterRIP7560TransactionPostOpRevertReason and is used to iterate over the raw logs and unpacked data for RIP7560TransactionPostOpRevertReason events raised by the Aa contract.
type AaRIP7560TransactionPostOpRevertReasonIterator struct {
	Event *AaRIP7560TransactionPostOpRevertReason // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AaRIP7560TransactionPostOpRevertReasonIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AaRIP7560TransactionPostOpRevertReason)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AaRIP7560TransactionPostOpRevertReason)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AaRIP7560TransactionPostOpRevertReasonIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AaRIP7560TransactionPostOpRevertReasonIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AaRIP7560TransactionPostOpRevertReason represents a RIP7560TransactionPostOpRevertReason event raised by the Aa contract.
type AaRIP7560TransactionPostOpRevertReason struct {
	Sender        libcommon.Address
	Paymaster     libcommon.Address
	NonceKey      *big.Int
	NonceSequence *big.Int
	RevertReason  []byte
	Raw           types.Log // Blockchain specific contextual infos
}

func (_Aa *AaFilterer) RIP7560TransactionPostOpRevertReasonEventID() libcommon.Hash {
	return libcommon.HexToHash("0xd4e39ce989d2135cd311a82afcfc75406f75fa789607fdc078c8c030793da388")
}

// FilterRIP7560TransactionPostOpRevertReason is a free log retrieval operation binding the contract event 0xd4e39ce989d2135cd311a82afcfc75406f75fa789607fdc078c8c030793da388.
//
// Solidity: event RIP7560TransactionPostOpRevertReason(address indexed sender, address indexed paymaster, uint256 nonceKey, uint256 nonceSequence, bytes revertReason)
func (_Aa *AaFilterer) FilterRIP7560TransactionPostOpRevertReason(opts *bind.FilterOpts, sender []libcommon.Address, paymaster []libcommon.Address) (*AaRIP7560TransactionPostOpRevertReasonIterator, error) {

	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}
	var paymasterRule []interface{}
	for _, paymasterItem := range paymaster {
		paymasterRule = append(paymasterRule, paymasterItem)
	}

	logs, sub, err := _Aa.contract.FilterLogs(opts, "RIP7560TransactionPostOpRevertReason", senderRule, paymasterRule)
	if err != nil {
		return nil, err
	}
	return &AaRIP7560TransactionPostOpRevertReasonIterator{contract: _Aa.contract, event: "RIP7560TransactionPostOpRevertReason", logs: logs, sub: sub}, nil
}

// WatchRIP7560TransactionPostOpRevertReason is a free log subscription operation binding the contract event 0xd4e39ce989d2135cd311a82afcfc75406f75fa789607fdc078c8c030793da388.
//
// Solidity: event RIP7560TransactionPostOpRevertReason(address indexed sender, address indexed paymaster, uint256 nonceKey, uint256 nonceSequence, bytes revertReason)
func (_Aa *AaFilterer) WatchRIP7560TransactionPostOpRevertReason(opts *bind.WatchOpts, sink chan<- *AaRIP7560TransactionPostOpRevertReason, sender []libcommon.Address, paymaster []libcommon.Address) (event.Subscription, error) {

	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}
	var paymasterRule []interface{}
	for _, paymasterItem := range paymaster {
		paymasterRule = append(paymasterRule, paymasterItem)
	}

	logs, sub, err := _Aa.contract.WatchLogs(opts, "RIP7560TransactionPostOpRevertReason", senderRule, paymasterRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AaRIP7560TransactionPostOpRevertReason)
				if err := _Aa.contract.UnpackLog(event, "RIP7560TransactionPostOpRevertReason", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRIP7560TransactionPostOpRevertReason is a log parse operation binding the contract event 0xd4e39ce989d2135cd311a82afcfc75406f75fa789607fdc078c8c030793da388.
//
// Solidity: event RIP7560TransactionPostOpRevertReason(address indexed sender, address indexed paymaster, uint256 nonceKey, uint256 nonceSequence, bytes revertReason)
func (_Aa *AaFilterer) ParseRIP7560TransactionPostOpRevertReason(log types.Log) (*AaRIP7560TransactionPostOpRevertReason, error) {
	event := new(AaRIP7560TransactionPostOpRevertReason)
	if err := _Aa.contract.UnpackLog(event, "RIP7560TransactionPostOpRevertReason", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AaRIP7560TransactionRevertReasonIterator is returned from FilterRIP7560TransactionRevertReason and is used to iterate over the raw logs and unpacked data for RIP7560TransactionRevertReason events raised by the Aa contract.
type AaRIP7560TransactionRevertReasonIterator struct {
	Event *AaRIP7560TransactionRevertReason // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AaRIP7560TransactionRevertReasonIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AaRIP7560TransactionRevertReason)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AaRIP7560TransactionRevertReason)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AaRIP7560TransactionRevertReasonIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AaRIP7560TransactionRevertReasonIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AaRIP7560TransactionRevertReason represents a RIP7560TransactionRevertReason event raised by the Aa contract.
type AaRIP7560TransactionRevertReason struct {
	Sender        libcommon.Address
	NonceKey      *big.Int
	NonceSequence *big.Int
	RevertReason  []byte
	Raw           types.Log // Blockchain specific contextual infos
}

func (_Aa *AaFilterer) RIP7560TransactionRevertReasonEventID() libcommon.Hash {
	return libcommon.HexToHash("0xa6a350478d9445ad9a561825d80fa03201f4b14a370184694a5cf59c78f271b0")
}

// FilterRIP7560TransactionRevertReason is a free log retrieval operation binding the contract event 0xa6a350478d9445ad9a561825d80fa03201f4b14a370184694a5cf59c78f271b0.
//
// Solidity: event RIP7560TransactionRevertReason(address indexed sender, uint256 nonceKey, uint256 nonceSequence, bytes revertReason)
func (_Aa *AaFilterer) FilterRIP7560TransactionRevertReason(opts *bind.FilterOpts, sender []libcommon.Address) (*AaRIP7560TransactionRevertReasonIterator, error) {

	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}

	logs, sub, err := _Aa.contract.FilterLogs(opts, "RIP7560TransactionRevertReason", senderRule)
	if err != nil {
		return nil, err
	}
	return &AaRIP7560TransactionRevertReasonIterator{contract: _Aa.contract, event: "RIP7560TransactionRevertReason", logs: logs, sub: sub}, nil
}

// WatchRIP7560TransactionRevertReason is a free log subscription operation binding the contract event 0xa6a350478d9445ad9a561825d80fa03201f4b14a370184694a5cf59c78f271b0.
//
// Solidity: event RIP7560TransactionRevertReason(address indexed sender, uint256 nonceKey, uint256 nonceSequence, bytes revertReason)
func (_Aa *AaFilterer) WatchRIP7560TransactionRevertReason(opts *bind.WatchOpts, sink chan<- *AaRIP7560TransactionRevertReason, sender []libcommon.Address) (event.Subscription, error) {

	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}

	logs, sub, err := _Aa.contract.WatchLogs(opts, "RIP7560TransactionRevertReason", senderRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AaRIP7560TransactionRevertReason)
				if err := _Aa.contract.UnpackLog(event, "RIP7560TransactionRevertReason", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRIP7560TransactionRevertReason is a log parse operation binding the contract event 0xa6a350478d9445ad9a561825d80fa03201f4b14a370184694a5cf59c78f271b0.
//
// Solidity: event RIP7560TransactionRevertReason(address indexed sender, uint256 nonceKey, uint256 nonceSequence, bytes revertReason)
func (_Aa *AaFilterer) ParseRIP7560TransactionRevertReason(log types.Log) (*AaRIP7560TransactionRevertReason, error) {
	event := new(AaRIP7560TransactionRevertReason)
	if err := _Aa.contract.UnpackLog(event, "RIP7560TransactionRevertReason", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}
