package commitment

import (
	"encoding/binary"
	"math/bits"
	"testing"
	"unsafe"

	"github.com/holiman/uint256"
)

// Standard uint256 SetBytes32
func BenchmarkSetBytes32_Standard(b *testing.B) {
	var u uint256.Int
	data := [32]byte{
		0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,
		0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88,
		0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff, 0x00, 0x11,
		0x99, 0x88, 0x77, 0x66, 0x55, 0x44, 0x33, 0x22,
	}
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		u.SetBytes32(data[:])
	}
}

// Direct field access (not really unsafe, just inlined)
func setBytes32Direct(u *uint256.Int, data []byte) {
	_ = data[31] // bounds check
	u[3] = binary.BigEndian.Uint64(data[0:8])
	u[2] = binary.BigEndian.Uint64(data[8:16])
	u[1] = binary.BigEndian.Uint64(data[16:24])
	u[0] = binary.BigEndian.Uint64(data[24:32])
}

func BenchmarkSetBytes32_Direct(b *testing.B) {
	var u uint256.Int
	data := [32]byte{
		0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,
		0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88,
		0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff, 0x00, 0x11,
		0x99, 0x88, 0x77, 0x66, 0x55, 0x44, 0x33, 0x22,
	}
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		setBytes32Direct(&u, data[:])
	}
}

// True unsafe: cast byte slice to uint64 pointer and use bits.ReverseBytes64
func setBytes32Unsafe(u *uint256.Int, data *[32]byte) {
	p := (*[4]uint64)(unsafe.Pointer(data))
	u[3] = bits.ReverseBytes64(p[0])
	u[2] = bits.ReverseBytes64(p[1])
	u[1] = bits.ReverseBytes64(p[2])
	u[0] = bits.ReverseBytes64(p[3])
}

func BenchmarkSetBytes32_Unsafe(b *testing.B) {
	var u uint256.Int
	data := [32]byte{
		0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,
		0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88,
		0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff, 0x00, 0x11,
		0x99, 0x88, 0x77, 0x66, 0x55, 0x44, 0x33, 0x22,
	}
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		setBytes32Unsafe(&u, &data)
	}
}

// Standard uint256 WriteToSlice (big-endian output)
func BenchmarkWriteToSlice_Standard(b *testing.B) {
	u := uint256.NewInt(0)
	u.SetBytes([]byte{
		0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,
		0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88,
		0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff, 0x00, 0x11,
		0x99, 0x88, 0x77, 0x66, 0x55, 0x44, 0x33, 0x22,
	})
	var buf [32]byte
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		u.WriteToSlice(buf[:])
	}
}

// Direct field access with binary.BigEndian (not really unsafe)
func writeToSliceDirect(u *uint256.Int, buf []byte) {
	_ = buf[31] // bounds check
	binary.BigEndian.PutUint64(buf[0:8], u[3])
	binary.BigEndian.PutUint64(buf[8:16], u[2])
	binary.BigEndian.PutUint64(buf[16:24], u[1])
	binary.BigEndian.PutUint64(buf[24:32], u[0])
}

func BenchmarkWriteToSlice_Direct(b *testing.B) {
	u := uint256.NewInt(0)
	u.SetBytes([]byte{
		0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,
		0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88,
		0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff, 0x00, 0x11,
		0x99, 0x88, 0x77, 0x66, 0x55, 0x44, 0x33, 0x22,
	})
	var buf [32]byte
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		writeToSliceDirect(u, buf[:])
	}
}

// True unsafe: cast to pointer and use bits.ReverseBytes64
func writeToSliceUnsafe(u *uint256.Int, buf *[32]byte) {
	p := (*[4]uint64)(unsafe.Pointer(buf))
	p[0] = bits.ReverseBytes64(u[3])
	p[1] = bits.ReverseBytes64(u[2])
	p[2] = bits.ReverseBytes64(u[1])
	p[3] = bits.ReverseBytes64(u[0])
}

func BenchmarkWriteToSlice_Unsafe(b *testing.B) {
	u := uint256.NewInt(0)
	u.SetBytes([]byte{
		0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,
		0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88,
		0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff, 0x00, 0x11,
		0x99, 0x88, 0x77, 0x66, 0x55, 0x44, 0x33, 0x22,
	})
	var buf [32]byte
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		writeToSliceUnsafe(u, &buf)
	}
}

// Test correctness
func TestWriteToSliceUnsafe(t *testing.T) {
	u := uint256.NewInt(0)
	u.SetBytes([]byte{
		0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,
		0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88,
		0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff, 0x00, 0x11,
		0x99, 0x88, 0x77, 0x66, 0x55, 0x44, 0x33, 0x22,
	})

	var expected, got [32]byte
	u.WriteToSlice(expected[:])
	writeToSliceUnsafe(u, &got)

	if expected != got {
		t.Errorf("writeToSliceUnsafe mismatch:\nexpected: %x\ngot:      %x", expected, got)
	}
}

func TestSetBytes32Unsafe(t *testing.T) {
	data := [32]byte{
		0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,
		0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88,
		0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff, 0x00, 0x11,
		0x99, 0x88, 0x77, 0x66, 0x55, 0x44, 0x33, 0x22,
	}

	var expected, got uint256.Int
	expected.SetBytes32(data[:])
	setBytes32Unsafe(&got, &data)

	if expected != got {
		t.Errorf("setBytes32Unsafe mismatch:\nexpected: %x\ngot:      %x", expected, got)
	}
}
