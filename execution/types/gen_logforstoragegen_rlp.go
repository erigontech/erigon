// Code generated by rlpgen. DO NOT EDIT.

package types

import (
	"fmt"
	"io"

	"github.com/erigontech/erigon/common"
	"github.com/erigontech/erigon/execution/rlp"
)

func (obj *LogForStorageGen) EncodingSize() (size int) {
	size += 20 + 1
	gidx := 0
	gidx = (32 + 1) * len(obj.Topics)
	size += rlp.ListPrefixLen(gidx) + gidx
	size += rlp.StringLen(obj.Data)
	return
}

func (obj *LogForStorageGen) EncodeRLP(w io.Writer) error {
	var b [32]byte
	if err := rlp.EncodeStructSizePrefix(obj.EncodingSize(), w, b[:]); err != nil {
		return err
	}
	b[0] = 128 + 20
	if _, err := w.Write(b[:1]); err != nil {
		return err
	}
	if _, err := w.Write(obj.Address[:]); err != nil {
		return err
	}
	gidx := 0
	gidx = (32 + 1) * len(obj.Topics)
	if err := rlp.EncodeStructSizePrefix(gidx, w, b[:]); err != nil {
		return err
	}
	for i := 0; i < len(obj.Topics); i++ {
		if err := rlp.EncodeString(obj.Topics[i][:], w, b[:]); err != nil {
			return err
		}
	}
	if err := rlp.EncodeString(obj.Data, w, b[:]); err != nil {
		return err
	}
	return nil
}

func (obj *LogForStorageGen) DecodeRLP(s *rlp.Stream) error {
	_, err := s.List()
	if err != nil {
		return err
	}
	if err = s.ReadBytes(obj.Address[:]); err != nil {
		return fmt.Errorf("error decoding field Address, err: %w", err)
	}
	l, err := s.List()
	if err != nil {
		return fmt.Errorf("error decoding field Topics - expected list start, err: %w", err)
	}
	var listLen int
	if l > 0 {
		listLen = int(l / (1 + 32))   // Each hash: 1-byte RLP prefix + 32-byte hash
		preAlloc := min(128, listLen) // Hard limit against DoS
		obj.Topics = make([]common.Hash, 0, preAlloc)
	} else {
		obj.Topics = []common.Hash{}
	}
	if listLen <= 128 {
		// Fast-path: within pre-alloc limit, use pre-allocated buffer
		obj.Topics = obj.Topics[:listLen]
		for i := 0; i < listLen; i++ {
			if err = s.ReadBytes(obj.Topics[i][:]); err != nil {
				return err
			}
		}
	} else if listLen > 128 {
		// Slow-path: exceeded pre-alloc limit, allocate exact size and use direct ReadBytes
		obj.Topics = make([]common.Hash, listLen)
		for i := 0; i < listLen; i++ {
			if err = s.ReadBytes(obj.Topics[i][:]); err != nil {
				return err
			}
		}
	}
	if err = s.ListEnd(); err != nil {
		return fmt.Errorf("error decoding field Topics - fail to close list, err: %w", err)
	}
	if obj.Data, err = s.Bytes(); err != nil {
		return fmt.Errorf("error decoding field Data, err: %w", err)
	}
	if err = s.ListEnd(); err != nil {
		return fmt.Errorf("error closing LogForStorageGen, err: %w", err)
	}
	return nil
}
