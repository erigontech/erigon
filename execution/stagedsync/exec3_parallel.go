package stagedsync

import (
	"context"
	"errors"
	"fmt"
	"maps"
	"math/big"
	"sort"
	"strings"
	"sync"
	"sync/atomic"
	"time"

	"github.com/erigontech/erigon-lib/common"
	"github.com/erigontech/erigon-lib/kv/mdbx"
	"github.com/erigontech/erigon-lib/metrics"
	"github.com/erigontech/erigon/eth/consensuschain"
	chaos_monkey "github.com/erigontech/erigon/tests/chaos-monkey"
	"github.com/holiman/uint256"
	"golang.org/x/sync/errgroup"

	"github.com/erigontech/erigon-db/rawdb"
	"github.com/erigontech/erigon-lib/chain"
	"github.com/erigontech/erigon-lib/common/datadir"
	"github.com/erigontech/erigon-lib/common/dbg"
	"github.com/erigontech/erigon-lib/kv"
	"github.com/erigontech/erigon-lib/log/v3"
	libstate "github.com/erigontech/erigon-lib/state"
	"github.com/erigontech/erigon-lib/types"
	"github.com/erigontech/erigon/core"
	"github.com/erigontech/erigon/core/exec"
	"github.com/erigontech/erigon/core/state"
	"github.com/erigontech/erigon/core/tracing"
	"github.com/erigontech/erigon/core/vm"
	"github.com/erigontech/erigon/execution/consensus"
	"github.com/erigontech/erigon/execution/exec3"
	"github.com/erigontech/erigon/execution/exec3/calltracer"
)

/*
ExecV3 - parallel execution. Has many layers of abstractions - each layer does accumulate
state changes (updates) and can "atomically commit all changes to underlying layer of abstraction"

Layers from top to bottom:
- IntraBlockState - used to exec txs. It does store inside all updates of given txn.
Can understand if txn failed or OutOfGas - then revert all changes.
Each parallel-worker have own IntraBlockState.
IntraBlockState does commit changes to lower-abstraction-level by method `ibs.MakeWriteSet()`

- BufferedWriter - txs which executed by parallel workers can conflict with each-other.
This writer does accumulate updates and then send them to conflict-resolution.
Until conflict-resolution succeed - none of execution updates must pass to lower-abstraction-level.
Object TxTask it's just set of small buffers (readset + writeset) for each transaction.
Write to TxTask happens by code like `txTask.ReadLists = rw.stateReader.ReadSet()`.

- TxTask - objects coming from parallel-workers to conflict-resolution goroutine (ApplyLoop and method ReadsValid).
Flush of data to lower-level-of-abstraction is done by method `agg.ApplyState` (method agg.ApplyHistory exists
only for performance - to reduce time of RwLock on state, but by meaning `ApplyState+ApplyHistory` it's 1 method to
flush changes from TxTask to lower-level-of-abstraction).

- ParallelExecutionState - it's all updates which are stored in RAM - all parallel workers can see this updates.
Execution of txs always done on Valid version of state (no partial-updates of state).
Flush of updates to lower-level-of-abstractions done by method `ParallelExecutionState.Flush`.
On this level-of-abstraction also exists ReaderV3.
IntraBlockState does call ReaderV3, and ReaderV3 call ParallelExecutionState(in-mem-cache) or DB (RoTx).
WAL - also on this level-of-abstraction - agg.ApplyHistory does write updates from TxTask to WAL.
WAL it's like ParallelExecutionState just without reading api (can only write there). WAL flush to disk periodically (doesn't need much RAM).

- RoTx - see everything what committed to DB. Commit is done by rwLoop goroutine.
rwloop does:
  - stop all Workers
  - call ParallelExecutionState.Flush()
  - commit
  - open new RoTx
  - set new RoTx to all Workers
  - start Worker start workers

When rwLoop has nothing to do - it does Prune, or flush of WAL to RwTx (agg.rotate+agg.Flush)
*/

type cbbalance struct {
	blockNum uint64
	addr     string
	balance  string
}

var balances = []cbbalance{
	{22939462, "0xdadB0d80178819F2319190D340ce9A924f783711", "9443099363791387877"},
	{22939463, "0xdadB0d80178819F2319190D340ce9A924f783711", "9443365268998913456"},
	{22939464, "0xdadB0d80178819F2319190D340ce9A924f783711", "9445192095546688615"},
	{22939465, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "14609252839800412472"},
	{22939466, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "14612135888471954697"},
	{22939467, "0xdadB0d80178819F2319190D340ce9A924f783711", "9459543218647029977"},
	{22939468, "0xdadB0d80178819F2319190D340ce9A924f783711", "9456065592129375601"},
	{22939469, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "14627789378989790173"},
	{22939470, "0xdadB0d80178819F2319190D340ce9A924f783711", "9454417291239049275"},
	{22939471, "0xdadB0d80178819F2319190D340ce9A924f783711", "9451421826898882842"},
	{22939472, "0xdadB0d80178819F2319190D340ce9A924f783711", "9470147952302181395"},
	{22939473, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "14627714357147553955"},
	{22939474, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "14663541541028274669"},
	{22939475, "0xdadB0d80178819F2319190D340ce9A924f783711", "9470062879923563560"},
	{22939476, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "14669337176416934987"},
	{22939477, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "14666717154736512495"},
	{22939478, "0xdadB0d80178819F2319190D340ce9A924f783711", "9469857834244035079"},
	{22939479, "0xdadB0d80178819F2319190D340ce9A924f783711", "9514513637130295394"},
	{22939480, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "14724128451209521659"},
	{22939481, "0xdadB0d80178819F2319190D340ce9A924f783711", "9507513635880657325"},
	{22939482, "0xdadB0d80178819F2319190D340ce9A924f783711", "9503606818726676032"},
	{22939483, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "14728108774554953928"},
	{22939484, "0x95222290DD7278Aa3Ddd389Cc1E1d165CC4BAfe5", "8995246446476300036"},
	{22939485, "0xdadB0d80178819F2319190D340ce9A924f783711", "9496606817460107887"},
	{22939486, "0xdadB0d80178819F2319190D340ce9A924f783711", "9497622821319892695"},
	{22939487, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "14737037730236765242"},
	{22939488, "0x1f9090aaE28b8a3dCeaDf281B0F12828e676c326", "1003274362246687195"},
	{22939489, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "14752492745822771392"},
	{22939490, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "14845039730685185992"},
	{22939491, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "14844526466307468528"},
	{22939492, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "14844126460170286551"},
	{22939493, "0xdadB0d80178819F2319190D340ce9A924f783711", "9494395427601335884"},
	{22939494, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "14841737557187972559"},
	{22939495, "0xdadB0d80178819F2319190D340ce9A924f783711", "9489314261288983245"},
	{22939496, "0xdadB0d80178819F2319190D340ce9A924f783711", "9488488678308155495"},
	{22939497, "0x95222290DD7278Aa3Ddd389Cc1E1d165CC4BAfe5", "9068443324868447202"},
	{22939498, "0xdadB0d80178819F2319190D340ce9A924f783711", "9482006104586183465"},
	{22939499, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "14850981220869931382"},
	{22939500, "0xdadB0d80178819F2319190D340ce9A924f783711", "9486378441011594475"},
	{22939501, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "14845462866366520126"},
	{22939502, "0xdadB0d80178819F2319190D340ce9A924f783711", "9490125222927349306"},
	{22939503, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "14857795894381482296"},
	{22939504, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "14858376408018174211"},
	{22939505, "0xdadB0d80178819F2319190D340ce9A924f783711", "9497481952404307929"},
	{22939506, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "14858262688267402485"},
	{22939507, "0xdadB0d80178819F2319190D340ce9A924f783711", "9490512671104095778"},
	{22939508, "0x396343362be2A4dA1cE0C1C210945346fb82Aa49", "7663739428435791529"},
	{22939509, "0xFB74767C1ce1aadA0a0E114441173b57f8C1571b", "40042377667104201"},
	{22939510, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "14900950765378491815"},
	{22939511, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "14899906566593309495"},
	{22939512, "0xdadB0d80178819F2319190D340ce9A924f783711", "9483512670342682526"},
	{22939513, "0xdadB0d80178819F2319190D340ce9A924f783711", "9482999815545351072"},
	{22939514, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "14896179514726831423"},
	{22939515, "0x396343362be2A4dA1cE0C1C210945346fb82Aa49", "7664331062934415401"},
	{22939516, "0xdadB0d80178819F2319190D340ce9A924f783711", "9479566834235390697"},
	{22939517, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "14979574231898472064"},
	{22939518, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "15024316971046051336"},
	{22939519, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "15088860608933910734"},
	{22939520, "0x95222290DD7278Aa3Ddd389Cc1E1d165CC4BAfe5", "9068662679243363523"},
	{22939521, "0xdadB0d80178819F2319190D340ce9A924f783711", "9473981960337965363"},
	{22939522, "0x655fA8459044a0aAAb594CC05577497750c53Dc5", "6686969027671136259"},
	{22939523, "0xdadB0d80178819F2319190D340ce9A924f783711", "9470050884917802281"},
	{22939524, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "15101717279699114762"},
	{22939525, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "15101031021852824495"},
	{22939526, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "15137836739505924325"},
	{22939527, "0x396343362be2A4dA1cE0C1C210945346fb82Aa49", "7656026017586267923"},
	{22939528, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "15137851509198615353"},
	{22939529, "0xdadB0d80178819F2319190D340ce9A924f783711", "9468449001166417905"},
	{22939530, "0xdadB0d80178819F2319190D340ce9A924f783711", "9461851632873508190"},
	{22939531, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "15150884914264910297"},
	{22939532, "0x396343362be2A4dA1cE0C1C210945346fb82Aa49", "7649428783867384637"},
	{22939533, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "15175255019489899606"},
	{22939534, "0x396343362be2A4dA1cE0C1C210945346fb82Aa49", "7639428783867384637"},
	{22939535, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "15192041935257840114"},
	{22939536, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "15201320654825510806"},
	{22939537, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "15214433516188725537"},
	{22939538, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "15257906197357477555"},
	{22939539, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "15643681200419571236"},
	{22939540, "0xdadB0d80178819F2319190D340ce9A924f783711", "9455391339546846114"},
	{22939541, "0x396343362be2A4dA1cE0C1C210945346fb82Aa49", "7628812117200717971"},
	{22939542, "0x758A4A45dd08D826FC3f2436ce3FA263fB1A4F42", "108797226854118646617"},
	{22939543, "0x882E747C5C2E0366d4Fd6F9F95780467C6549732", "996957996282755238623"},
	{22939544, "0x400B6e5929a0656F91b41C19166013Bc784b8485", "1645793783931043985"},
	{22939545, "0xdadB0d80178819F2319190D340ce9A924f783711", "9489312692316527258"},
	{22939546, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "15653195387150851666"},
	{22939547, "0xbd3Afb0bB76683eCb4225F9DBc91f998713C3b01", "1040520327692372776"},
	{22939548, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "15667698063024063472"},
	{22939549, "0x95222290DD7278Aa3Ddd389Cc1E1d165CC4BAfe5", "9210647670149727173"},
	{22939550, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "15673969567609223504"},
	{22939551, "0xdadB0d80178819F2319190D340ce9A924f783711", "9507403318224522709"},
	{22939552, "0x396343362be2A4dA1cE0C1C210945346fb82Aa49", "7617911224343575115"},
	{22939553, "0x396343362be2A4dA1cE0C1C210945346fb82Aa49", "7606935331486432259"},
	{22939554, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "15691021564370696823"},
	{22939555, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "15688999250877114788"},
	{22939556, "0x396343362be2A4dA1cE0C1C210945346fb82Aa49", "7597517359266719302"},
	{22939557, "0xdadB0d80178819F2319190D340ce9A924f783711", "9503603474119007431"},
	{22939558, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "15697772403508456831"},
	{22939559, "0x396343362be2A4dA1cE0C1C210945346fb82Aa49", "7586410784591394628"},
	{22939560, "0xdadB0d80178819F2319190D340ce9A924f783711", "9606322702386667030"},
	{22939561, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "15702625855323461020"},
	{22939562, "0xdadB0d80178819F2319190D340ce9A924f783711", "9603393755855268804"},
	{22939563, "0x388C818CA8B9251b393131C08a736A67ccB19297", "8253969697579648733"},
	{22939564, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "15712221906625455337"},
	{22939565, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "15712279290097136028"},
	{22939566, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "15715872099843806360"},
	{22939567, "0xdadB0d80178819F2319190D340ce9A924f783711", "9670566062163445395"},
	{22939568, "0xdadB0d80178819F2319190D340ce9A924f783711", "9663566060843090115"},
	{22939569, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "15716375294753121188"},
	{22939570, "0xdadB0d80178819F2319190D340ce9A924f783711", "9668982236688715994"},
	{22939571, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "15722938379207824198"},
	{22939572, "0xdadB0d80178819F2319190D340ce9A924f783711", "9662461262268988419"},
	{22939573, "0xdadB0d80178819F2319190D340ce9A924f783711", "9676707859783404697"},
	{22939574, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "15753403226985007237"},
	{22939575, "0x396343362be2A4dA1cE0C1C210945346fb82Aa49", "7575051953532747396"},
	{22939576, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "15836224375715566341"},
	{22939577, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "15846639608449513081"},
	{22939578, "0x396343362be2A4dA1cE0C1C210945346fb82Aa49", "7563651455807433498"},
	{22939579, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "15861048414186261540"},
	{22939580, "0x396343362be2A4dA1cE0C1C210945346fb82Aa49", "7554657035490451016"},
	{22939581, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "15876248392561629850"},
	{22939582, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "15881039380578966377"},
	{22939583, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "15890734235643439286"},
	{22939584, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "15892006589969136751"},
	{22939585, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "15920186938213143850"},
	{22939586, "0x396343362be2A4dA1cE0C1C210945346fb82Aa49", "7556729688355022390"},
	{22939587, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "15918644012960095173"},
	{22939588, "0x396343362be2A4dA1cE0C1C210945346fb82Aa49", "7548310179347591158"},
	{22939589, "0x95222290DD7278Aa3Ddd389Cc1E1d165CC4BAfe5", "9211655463797582116"},
	{22939590, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "15921642929664536822"},
	{22939591, "0x396343362be2A4dA1cE0C1C210945346fb82Aa49", "7546186179921712578"},
	{22939592, "0x95222290DD7278Aa3Ddd389Cc1E1d165CC4BAfe5", "9220110763833339423"},
	{22939593, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "15920255508507089947"},
	{22939594, "0xdadB0d80178819F2319190D340ce9A924f783711", "9672462055276157601"},
	{22939595, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "15975788098978894863"},
	{22939596, "0x396343362be2A4dA1cE0C1C210945346fb82Aa49", "7535543342077642905"},
	{22939597, "0xdadB0d80178819F2319190D340ce9A924f783711", "9676149374257016889"},
	{22939598, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "16035328153657955746"},
	{22939599, "0xdadB0d80178819F2319190D340ce9A924f783711", "9692745487881331546"},
	{22939600, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "16050705756984447074"},
	{22939601, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "16047545783397584607"},
	{22939602, "0x396343362be2A4dA1cE0C1C210945346fb82Aa49", "7527725772147032912"},
	{22939603, "0x95222290DD7278Aa3Ddd389Cc1E1d165CC4BAfe5", "9223447394510392458"},
	{22939604, "0xdadB0d80178819F2319190D340ce9A924f783711", "9706987196191574458"},
	{22939605, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "16050645022804539030"},
	{22939606, "0xdadB0d80178819F2319190D340ce9A924f783711", "9701318833412448255"},
	{22939607, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "16057938371145690385"},
	{22939608, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "16059288195234403936"},
	{22939609, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "16082289636977691354"},
	{22939610, "0xdadB0d80178819F2319190D340ce9A924f783711", "9703709267235897026"},
	{22939611, "0x396343362be2A4dA1cE0C1C210945346fb82Aa49", "7516830930607638359"},
	{22939612, "0xdadB0d80178819F2319190D340ce9A924f783711", "9700428612657372802"},
	{22939613, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "16093909567645425905"},
	{22939614, "0xdadB0d80178819F2319190D340ce9A924f783711", "9702982694454960431"},
	{22939615, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "16261423780926440502"},
	{22939616, "0xdadB0d80178819F2319190D340ce9A924f783711", "9790348669190971076"},
	{22939617, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "16270050477839610053"},
	{22939618, "0xdadB0d80178819F2319190D340ce9A924f783711", "9836051536061657674"},
	{22939619, "0xdadB0d80178819F2319190D340ce9A924f783711", "9835513741949413126"},
	{22939620, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "16282543669268184121"},
	{22939621, "0xdadB0d80178819F2319190D340ce9A924f783711", "9834606130829853669"},
	{22939622, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "16287541879433478512"},
	{22939623, "0xdadB0d80178819F2319190D340ce9A924f783711", "9833565459337684398"},
	{22939624, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "16291671696848954419"},
	{22939625, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "16293445897844443321"},
	{22939626, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "16323181278400885389"},
	{22939627, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "16327422910705198884"},
	{22939628, "0x396343362be2A4dA1cE0C1C210945346fb82Aa49", "7507886908433160438"},
	{22939629, "0x95222290DD7278Aa3Ddd389Cc1E1d165CC4BAfe5", "9222498746157190067"},
	{22939630, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "16349254411498930651"},
	{22939631, "0x396343362be2A4dA1cE0C1C210945346fb82Aa49", "7501140983461198189"},
	{22939632, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "16394164465427903660"},
	{22939633, "0x396343362be2A4dA1cE0C1C210945346fb82Aa49", "7491448485411647124"},
	{22939634, "0x95222290DD7278Aa3Ddd389Cc1E1d165CC4BAfe5", "9266942504474951368"},
	{22939635, "0x1f9090aaE28b8a3dCeaDf281B0F12828e676c326", "756058644602277922"},
	{22939636, "0x7DbfeD5686847113b527DC215DBA4E332DF8cc6c", "2331390919114195320"},
	{22939637, "0xdadB0d80178819F2319190D340ce9A924f783711", "9828157221559121599"},
	{22939638, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "16415675343962865271"},
	{22939639, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "16482175642051675936"},
	{22939640, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "16484254908982326908"},
	{22939641, "0xdadB0d80178819F2319190D340ce9A924f783711", "9833256761383674299"},
	{22939642, "0x396343362be2A4dA1cE0C1C210945346fb82Aa49", "7481949737362096059"},
	{22939643, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "16509928636073307427"},
	{22939644, "0x95222290DD7278Aa3Ddd389Cc1E1d165CC4BAfe5", "9278875393554071905"},
	{22939645, "0xdadB0d80178819F2319190D340ce9A924f783711", "9826256760429384217"},
	{22939646, "0xdadB0d80178819F2319190D340ce9A924f783711", "9820948331700870829"},
	{22939647, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "16525623434234912742"},
	{22939648, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "16559069105519179852"},
	{22939649, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "16612906095233612219"},
	{22939650, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "16631784649327442274"},
	{22939651, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "16642005112564130115"},
	{22939652, "0xdadB0d80178819F2319190D340ce9A924f783711", "9952880208951534606"},
	{22939653, "0x95222290DD7278Aa3Ddd389Cc1E1d165CC4BAfe5", "9296504963628238969"},
	{22939654, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "16644315621969101897"},
	{22939655, "0xdadB0d80178819F2319190D340ce9A924f783711", "9946242676048917208"},
	{22939656, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "16645642304681783154"},
	{22939657, "0xdadB0d80178819F2319190D340ce9A924f783711", "9939242674440906941"},
	{22939658, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "16655625170337369156"},
	{22939659, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "16654677253930765764"},
	{22939660, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "16657723842924178716"},
	{22939661, "0xdadB0d80178819F2319190D340ce9A924f783711", "10012964523488878186"},
	{22939662, "0xdadB0d80178819F2319190D340ce9A924f783711", "10005964522044668534"},
	{22939663, "0x95222290DD7278Aa3Ddd389Cc1E1d165CC4BAfe5", "9307488354605035706"},
	{22939664, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "16652372087526016834"},
	{22939665, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "16662103767703287252"},
	{22939666, "0xdadB0d80178819F2319190D340ce9A924f783711", "9998964521498703949"},
	{22939667, "0x396343362be2A4dA1cE0C1C210945346fb82Aa49", "7473103833089331762"},
	{22939668, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "16705066531821430591"},
	{22939669, "0xdadB0d80178819F2319190D340ce9A924f783711", "10013323192007288570"},
	{22939670, "0xdadB0d80178819F2319190D340ce9A924f783711", "10006323190893267892"},
	{22939671, "0xdadB0d80178819F2319190D340ce9A924f783711", "10377625184642231491"},
	{22939672, "0xdadB0d80178819F2319190D340ce9A924f783711", "10413634678173076091"},
	{22939673, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "16727582898760237245"},
	{22939674, "0x0853C06af6D3876b6F25984AF0C6a2d287eE6cCA", "36116429346800490108"},
	{22939675, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "16747978666924186235"},
	{22939676, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "16742287857216388618"},
	{22939677, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "16750124596662618097"},
	{22939678, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "16763316686714889287"},
	{22939679, "0xdadB0d80178819F2319190D340ce9A924f783711", "10407555745633892921"},
	{22939680, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "16793760127215449853"},
	{22939681, "0xdadB0d80178819F2319190D340ce9A924f783711", "10406302301368881863"},
	{22939682, "0x95222290DD7278Aa3Ddd389Cc1E1d165CC4BAfe5", "9320193154039430864"},
	{22939683, "0x95222290DD7278Aa3Ddd389Cc1E1d165CC4BAfe5", "9551038987866895573"},
	{22939684, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "16794799099425763499"},
	{22939685, "0x6Adb3baB5730852eB53987EA89D8e8f16393C200", "4938002273964508489"},
	{22939686, "0x7A16f522b45e16428FDE444edE95DE7bf272Ad98", "15871502944748468973"},
	{22939687, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "16887076929603273804"},
	{22939688, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "16904052409064859227"},
	{22939689, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "16900659498678392687"},
	{22939690, "0x48319f97E5Da1233c21c48b80097c0FB7a20Ff86", "4415383685647699171"},
	{22939691, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "16901846169585771825"},
	{22939692, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "16916100302290351619"},
	{22939693, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "16915796821639707836"},
	{22939694, "0xdadB0d80178819F2319190D340ce9A924f783711", "10399302300428279789"},
	{22939695, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "16915956801507752562"},
	{22939696, "0x396343362be2A4dA1cE0C1C210945346fb82Aa49", "7467702707252523501"},
	{22939697, "0x95222290DD7278Aa3Ddd389Cc1E1d165CC4BAfe5", "9623573901885253295"},
	{22939698, "0xdadB0d80178819F2319190D340ce9A924f783711", "10399547909821593181"},
	{22939699, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "16960462938187074351"},
	{22939700, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "16977558006764220077"},
	{22939701, "0xdadB0d80178819F2319190D340ce9A924f783711", "10416769970546289495"},
	{22939702, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "17023053610878986982"},
	{22939703, "0x95222290DD7278Aa3Ddd389Cc1E1d165CC4BAfe5", "9673699471747394602"},
	{22939704, "0x388C818CA8B9251b393131C08a736A67ccB19297", "10080848072984221595"},
	{22939705, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "17039526453653444194"},
	{22939706, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "17063854464641840250"},
	{22939707, "0xdadB0d80178819F2319190D340ce9A924f783711", "10410647662366881114"},
	{22939708, "0xdadB0d80178819F2319190D340ce9A924f783711", "10417559897266626426"},
	{22939709, "0xdadB0d80178819F2319190D340ce9A924f783711", "10469113309568615069"},
	{22939710, "0x95222290DD7278Aa3Ddd389Cc1E1d165CC4BAfe5", "9703506484909435808"},
	{22939711, "0xdadB0d80178819F2319190D340ce9A924f783711", "10559799884935587388"},
	{22939712, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "17074928936501295399"},
	{22939713, "0xdadB0d80178819F2319190D340ce9A924f783711", "10552799883754381793"},
	{22939714, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "17115456350673081733"},
	{22939715, "0x95222290DD7278Aa3Ddd389Cc1E1d165CC4BAfe5", "9842256518151949113"},
	{22939716, "0x95222290DD7278Aa3Ddd389Cc1E1d165CC4BAfe5", "9954833124338198266"},
	{22939717, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "17139894534891896028"},
	{22939718, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "17148257960096318716"},
	{22939719, "0xdadB0d80178819F2319190D340ce9A924f783711", "10548928269959638670"},
	{22939720, "0xdadB0d80178819F2319190D340ce9A924f783711", "10618305517465735957"},
	{22939721, "0xdadB0d80178819F2319190D340ce9A924f783711", "10611305517315307573"},
	{22939722, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "17181125650103770168"},
	{22939723, "0xD87f3d6c5624E8B02bE13c2C92f8511B88B94d96", "314898912474808146"},
	{22939724, "0xdadB0d80178819F2319190D340ce9A924f783711", "10617320661971943096"},
	{22939725, "0x396343362be2A4dA1cE0C1C210945346fb82Aa49", "7459691954553122585"},
	{22939726, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "17285210255600800750"},
	{22939727, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "17360219339099195994"},
	{22939728, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "17466682209516402614"},
	{22939729, "0xdadB0d80178819F2319190D340ce9A924f783711", "10610320660924982737"},
	{22939730, "0x95222290DD7278Aa3Ddd389Cc1E1d165CC4BAfe5", "9967240870197491845"},
	{22939731, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "17474293534078320405"},
	{22939732, "0x95222290DD7278Aa3Ddd389Cc1E1d165CC4BAfe5", "9970702063938405958"},
	{22939733, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "17472875194867138332"},
	{22939734, "0x6Adb3baB5730852eB53987EA89D8e8f16393C200", "4978396867156310979"},
	{22939735, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "17477156565988569758"},
	{22939736, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "17500277643254227669"},
	{22939737, "0xdadB0d80178819F2319190D340ce9A924f783711", "10614164178290435300"},
	{22939738, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "17506330938893763580"},
	{22939739, "0x388C818CA8B9251b393131C08a736A67ccB19297", "10925450539933536241"},
	{22939740, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "17696280884175507480"},
	{22939741, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "17901956643236815354"},
	{22939742, "0xdadB0d80178819F2319190D340ce9A924f783711", "10618723406544454813"},
	{22939743, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "17902422204950822313"},
	{22939744, "0x95222290DD7278Aa3Ddd389Cc1E1d165CC4BAfe5", "10083341078137598218"},
	{22939745, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "18145827035924850454"},
	{22939746, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "18141997798001162292"},
	{22939747, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "18145203799497650887"},
	{22939748, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "18176676840687520409"},
	{22939749, "0xdadB0d80178819F2319190D340ce9A924f783711", "10619621205571672075"},
	{22939750, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "18255738624850142098"},
	{22939751, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "18285416743967206982"},
	{22939752, "0xdadB0d80178819F2319190D340ce9A924f783711", "10622939704461275552"},
	{22939753, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "18319124350824421117"},
	{22939754, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "18364686965403632057"},
	{22939755, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "18373424875514342296"},
	{22939756, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "18378601860523496861"},
	{22939757, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "18435767189487477571"},
	{22939758, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "18453059585777699378"},
	{22939759, "0xdadB0d80178819F2319190D340ce9A924f783711", "10623399885789931270"},
	{22939760, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "18474361655445957355"},
	{22939761, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "18475626368150422465"},
	{22939762, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "18478556539593559508"},
	{22939763, "0xdadB0d80178819F2319190D340ce9A924f783711", "10649566813692891256"},
	{22939764, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "18504811260485772333"},
	{22939765, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "18620413227156724087"},
	{22939766, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "18654562350064157871"},
	{22939767, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "18820216512936363615"},
	{22939768, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "18884895172705305295"},
	{22939769, "0xdadB0d80178819F2319190D340ce9A924f783711", "10645045219062738641"},
	{22939770, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "18919795065807753271"},
	{22939771, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "18950106835918826689"},
	{22939772, "0x95222290DD7278Aa3Ddd389Cc1E1d165CC4BAfe5", "10120089841795422509"},
	{22939773, "0x6Adb3baB5730852eB53987EA89D8e8f16393C200", "4945107637514942315"},
	{22939774, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "18970807198777354948"},
	{22939775, "0x396343362be2A4dA1cE0C1C210945346fb82Aa49", "7452166508797090046"},
	{22939776, "0xdadB0d80178819F2319190D340ce9A924f783711", "10640837766069604247"},
	{22939777, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "18994515759932334748"},
	{22939778, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "19016537237454583180"},
	{22939779, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "19040440294291315840"},
	{22939780, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "19052065306452888763"},
	{22939781, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "19067723196608398736"},
	{22939782, "0x95222290DD7278Aa3Ddd389Cc1E1d165CC4BAfe5", "10126805245811080468"},
	{22939783, "0xdadB0d80178819F2319190D340ce9A924f783711", "10640751385719451857"},
	{22939784, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "19082337659164796900"},
	{22939785, "0xdadB0d80178819F2319190D340ce9A924f783711", "10633751384834050684"},
	{22939786, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "19098160115612666438"},
	{22939787, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "19112037978938777015"},
	{22939788, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "19114824938187854850"},
	{22939789, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "19117834613592467317"},
	{22939790, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "19127625653654223168"},
	{22939791, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "19152088277630371204"},
	{22939792, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "19168165954204609557"},
	{22939793, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "19167448644262767913"},
	{22939794, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "19166110207630709065"},
	{22939795, "0xdadB0d80178819F2319190D340ce9A924f783711", "10627036374528236697"},
	{22939796, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "19169394983419937949"},
	{22939797, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "19176430652149257355"},
	{22939798, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "19174350406621584379"},
	{22939799, "0xdadB0d80178819F2319190D340ce9A924f783711", "10649873074576585894"},
	{22939800, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "19200644443698901650"},
	{22939801, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "19199871785712642499"},
	{22939802, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "19268900305008024719"},
	{22939803, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "19327631362697059233"},
	{22939804, "0xdadB0d80178819F2319190D340ce9A924f783711", "10680386130918309310"},
	{22939805, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "19388506576837200097"},
	{22939806, "0x1D3F689dea4105029Ebb8E8F6cad3A6efbf43fD0", "11222272187198356"},
	{22939807, "0xdadB0d80178819F2319190D340ce9A924f783711", "10680992244637438573"},
	{22939808, "0x396343362be2A4dA1cE0C1C210945346fb82Aa49", "7460804478535648193"},
	{22939809, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "19500526056524792243"},
	{22939810, "0xdadB0d80178819F2319190D340ce9A924f783711", "10683109481071375355"},
	{22939811, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "19523798219773543313"},
	{22939812, "0xdadB0d80178819F2319190D340ce9A924f783711", "10724824664987629794"},
	{22939813, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "19549108329622440713"},
	{22939814, "0x396343362be2A4dA1cE0C1C210945346fb82Aa49", "7453566670442083186"},
	{22939815, "0xdadB0d80178819F2319190D340ce9A924f783711", "10720692404361415075"},
	{22939816, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "19553368821566934449"},
	{22939817, "0x95222290DD7278Aa3Ddd389Cc1E1d165CC4BAfe5", "10136309009135572989"},
	{22939818, "0x396343362be2A4dA1cE0C1C210945346fb82Aa49", "7446348862348518179"},
	{22939819, "0xdadB0d80178819F2319190D340ce9A924f783711", "10721785201148559476"},
	{22939820, "0xD87f3d6c5624E8B02bE13c2C92f8511B88B94d96", "316806306147788349"},
	{22939821, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "19665717731340080345"},
	{22939822, "0xdadB0d80178819F2319190D340ce9A924f783711", "10722622974503081918"},
	{22939823, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "19761383094359172024"},
	{22939824, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "19946409249197372452"},
	{22939825, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "19965864397801381449"},
	{22939826, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "20091017841988211360"},
	{22939827, "0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97", "20089563236843765787"}}

type bcb struct {
	addr common.Address
	bal  uint256.Int
}

var blockBalanceMap = map[uint64]bcb{}

func init() {
	for _, bal := range balances {
		big, _ := big.NewInt(0).SetString(bal.balance, 10)
		blockBalanceMap[bal.blockNum] = bcb{
			common.HexToAddress(strings.ToLower(bal.addr[2:])),
			*uint256.MustFromBig(big),
		}
	}
}

type executor interface {
	executeBlocks(ctx context.Context, tx kv.Tx, blockNum uint64, maxBlockNum uint64, readAhead chan uint64, applyResults chan applyResult) error

	wait(ctx context.Context) error
	getHeader(ctx context.Context, hash common.Hash, number uint64) (h *types.Header, err error)

	//these are reset by commit - so need to be read from the executor once its processing
	readState() *state.StateV3Buffered
	domains() *libstate.SharedDomains

	commit(ctx context.Context, execStage *StageState, tx kv.RwTx, asyncTxChan mdbx.TxApplyChan, useExternalTx bool) (kv.RwTx, time.Duration, error)
	resetWorkers(ctx context.Context, rs *state.StateV3Buffered, applyTx kv.Tx) error

	LogExecuted()
	LogCommitted(commitStart time.Time, stepsInDb float64)
	LogComplete(stepsInDb float64)
}

type applyResult interface {
}

type blockResult struct {
	BlockNum    uint64
	BlockTime   uint64
	BlockHash   common.Hash
	StateRoot   common.Hash
	Err         error
	GasUsed     uint64
	BlobGasUsed uint64
	lastTxNum   uint64
	complete    bool
	isPartial   bool
	ApplyCount  int
	TxIO        *state.VersionedIO
	Receipts    types.Receipts
	Stats       map[int]ExecutionStat
	Deps        *state.DAG
	AllDeps     map[int]map[int]bool
}

type txResult struct {
	blockNum     uint64
	blockTime    uint64
	txNum        uint64
	gasUsed      int64
	receipts     []*types.Receipt
	logs         []*types.Log
	traceFroms   map[common.Address]struct{}
	traceTos     map[common.Address]struct{}
	stateUpdates state.StateUpdates
}

type execTask struct {
	exec.Task
	index              int
	shouldDelayFeeCalc bool
}

type execResult struct {
	*exec.TxResult
}

func (result *execResult) finalize(prevReceipt *types.Receipt, engine consensus.Engine, vm *state.VersionMap, stateReader state.StateReader, stateWriter state.StateWriter) (*types.Receipt, error) {
	task, ok := result.Task.(*taskVersion)

	if !ok {
		return nil, fmt.Errorf("unexpected task type: %T", result.Task)
	}

	blockNum := task.Version().BlockNum
	txIndex := task.Version().TxIndex
	txIncarnation := task.Version().Incarnation

	txTrace := dbg.TraceTransactionIO &&
		(dbg.TraceTx(blockNum, txIndex) || dbg.TraceAccount(result.Coinbase) || dbg.TraceAccount(result.ExecutionResult.BurntContractAddress))

	var tracePrefix string
	if txTrace {
		tracePrefix = fmt.Sprintf("%d (%d.%d)", blockNum, txIndex, txIncarnation)
		fmt.Println(tracePrefix, "finalize")
		defer fmt.Println(tracePrefix, "done finalize")
	}

	// we want to force a re-read of the conbiase & burnt contract address
	// if thay where referenced by the tx
	delete(result.TxIn, result.Coinbase)
	delete(result.TxIn, result.ExecutionResult.BurntContractAddress)

	ibs := state.New(state.NewVersionedStateReader(txIndex, result.TxIn, vm, stateReader))
	ibs.SetTrace(task.execTask.Task.(*exec.TxTask).Trace)
	ibs.SetTxContext(blockNum, txIndex)
	ibs.SetVersion(txIncarnation)
	ibs.ApplyVersionedWrites(result.TxOut)
	ibs.SetVersionMap(&state.VersionMap{})

	txTask, ok := task.Task.(*exec.TxTask)

	if !ok {
		return nil, nil
	}

	if task.IsBlockEnd() || txIndex < 0 {
		if txTask.Config.IsByzantium(blockNum) {
			ibs.FinalizeTx(txTask.Config.Rules(blockNum, txTask.BlockTime()), stateWriter)
			if task.IsBlockEnd() {
				coinbase := result.Task.(*taskVersion).Task.(*exec.TxTask).EvmBlockContext.Coinbase
				data, _ := stateReader.ReadAccountData(coinbase)
				if sb, ok := blockBalanceMap[txTask.BlockNumber()]; ok {
					if sb.addr.Cmp(coinbase) != 0 {
						panic(fmt.Sprintf("unexpected coinbase: %s, expecting %s", coinbase, sb.addr))
					}
					if sb.bal.Cmp(&data.Balance) != 0 {
						panic(fmt.Sprintf("unexpected coinbase balance: %d, expecting %d", &data.Balance, &sb.bal))
					}
				}
			}
		}
		return nil, nil
	}

	if task.shouldDelayFeeCalc {
		if txTask.Config.IsLondon(blockNum) {
			ibs.AddBalance(result.ExecutionResult.BurntContractAddress, result.ExecutionResult.FeeBurnt, tracing.BalanceDecreaseGasBuy)
		}

		ibs.AddBalance(result.Coinbase, result.ExecutionResult.FeeTipped, tracing.BalanceIncreaseRewardTransactionFee)

		if engine != nil {
			if postApplyMessageFunc := engine.GetPostApplyMessageFunc(); postApplyMessageFunc != nil {
				execResult := result.ExecutionResult
				coinbase, err := stateReader.ReadAccountData(result.Coinbase) // to generate logs we want the initial balance

				if err != nil {
					return nil, err
				}

				if coinbase != nil {
					if txTrace {
						fmt.Println(blockNum, fmt.Sprintf("(%d.%d)", txIndex, txIncarnation), "CB", fmt.Sprintf("%x", result.Coinbase), fmt.Sprintf("%d", &coinbase.Balance), "nonce", coinbase.Nonce)
					}
					execResult.CoinbaseInitBalance = coinbase.Balance
				}

				message, err := task.TxMessage()
				if err != nil {
					return nil, err
				}

				postApplyMessageFunc(
					ibs,
					message.From(),
					result.Coinbase,
					&execResult,
				)

				// capture postApplyMessageFunc side affects
				result.Logs = append(result.Logs, ibs.GetLogs(txTask.TxIndex, txTask.TxHash(), blockNum, txTask.BlockHash())...)
			}
		}
	}

	if txTrace {
		vm.SetTrace(true)
		fmt.Println(tracePrefix, ibs.VersionedWrites(true))
	}

	// we need to flush the finalized writes to the version map so
	// they are taken into account by subsequent transactions
	vm.FlushVersionedWrites(ibs.VersionedWrites(true), true, tracePrefix)
	vm.SetTrace(false)

	if txTask.Config.IsByzantium(blockNum) {
		ibs.FinalizeTx(txTask.Config.Rules(blockNum, txTask.BlockTime()), stateWriter)
	}

	receipt, err := result.CreateReceipt(prevReceipt)

	if err != nil {
		return nil, err
	}

	if hooks := result.TracingHooks(); hooks != nil && hooks.OnTxEnd != nil {
		hooks.OnTxEnd(receipt, result.Err)
	}

	return receipt, nil
}

type taskVersion struct {
	*execTask
	version    state.Version
	versionMap *state.VersionMap
	profile    bool
	stats      map[int]ExecutionStat
	statsMutex *sync.Mutex
}

func (ev *taskVersion) Trace() bool {
	return ev.Task.(*exec.TxTask).Trace
}

func (ev *taskVersion) Execute(evm *vm.EVM,
	engine consensus.Engine,
	genesis *types.Genesis,
	ibs *state.IntraBlockState,
	stateWriter state.StateWriter,
	chainConfig *chain.Config,
	chainReader consensus.ChainReader,
	dirs datadir.Dirs,
	calcFees bool) (result *exec.TxResult) {

	var start time.Time
	if ev.profile {
		start = time.Now()
	}

	// Don't run post apply message during the state transition it is handled in finalize
	postApplyMessage := evm.Context.PostApplyMessage
	evm.Context.PostApplyMessage = nil
	defer func() { evm.Context.PostApplyMessage = postApplyMessage }()

	result = ev.execTask.Execute(evm, engine, genesis, ibs, stateWriter,
		chainConfig, chainReader, dirs, !ev.shouldDelayFeeCalc)

	if ibs.HadInvalidRead() || result.Err != nil {
		if err, ok := result.Err.(core.ErrExecAbortError); !ok {
			result.Err = core.ErrExecAbortError{DependencyTxIndex: ibs.DepTxIndex(), OriginError: err}
		}
	}

	if result.Err != nil {
		return result
	}

	if ev.profile {
		ev.statsMutex.Lock()
		ev.stats[ev.version.TxIndex] = ExecutionStat{
			TxIdx:       ev.version.TxIndex,
			Incarnation: ev.version.Incarnation,
			Duration:    time.Since(start),
		}
		ev.statsMutex.Unlock()
	}

	return result
}

func (ev *taskVersion) Reset(evm *vm.EVM, ibs *state.IntraBlockState, callTracer *calltracer.CallTracer) error {
	if err := ev.execTask.Reset(evm, ibs, callTracer); err != nil {
		return err
	}
	ibs.SetVersionMap(ev.versionMap)
	ibs.SetVersion(ev.version.Incarnation)
	return nil
}

func (ev *taskVersion) Version() state.Version {
	return ev.version
}

type blockExecMetrics struct {
	BlockCount atomic.Int64
	Duration   blockDuration
}

func newBlockExecMetrics() *blockExecMetrics {
	return &blockExecMetrics{
		Duration: blockDuration{Ema: metrics.NewEma[time.Duration](0, 0.3)},
	}
}

type blockDuration struct {
	atomic.Int64
	Ema *metrics.EMA[time.Duration]
}

func (d *blockDuration) Add(i time.Duration) {
	d.Int64.Add(int64(i))
	d.Ema.Update(i)
}

type txExecutor struct {
	sync.RWMutex
	cfg                      ExecuteBlockCfg
	agg                      *libstate.Aggregator
	rs                       *state.StateV3Buffered
	doms                     *libstate.SharedDomains
	u                        Unwinder
	isMining                 bool
	inMemExec                bool
	applyTx                  kv.Tx
	logger                   log.Logger
	logPrefix                string
	progress                 *Progress
	taskExecMetrics          *exec3.WorkerMetrics
	blockExecMetrics         *blockExecMetrics
	hooks                    *tracing.Hooks
	shouldGenerateChangesets bool

	lastExecutedBlockNum  atomic.Int64
	lastExecutedTxNum     atomic.Int64
	executedGas           atomic.Int64
	lastCommittedBlockNum uint64
	lastCommittedTxNum    uint64
	committedGas          int64

	execLoopGroup *errgroup.Group

	execRequests chan *execRequest
	execCount    atomic.Int64
	abortCount   atomic.Int64
	invalidCount atomic.Int64
	readCount    atomic.Int64
	writeCount   atomic.Int64

	enableChaosMonkey bool
}

func (te *txExecutor) readState() *state.StateV3Buffered {
	return te.rs
}

func (te *txExecutor) domains() *libstate.SharedDomains {
	return te.doms
}

func (te *txExecutor) getHeader(ctx context.Context, hash common.Hash, number uint64) (h *types.Header, err error) {
	if te.applyTx != nil {
		err := te.applyTx.Apply(ctx, func(tx kv.Tx) (err error) {
			h, err = te.cfg.blockReader.Header(ctx, te.applyTx, hash, number)
			return err
		})

		if err != nil {
			return nil, err
		}
	} else {
		if err := te.cfg.db.View(ctx, func(tx kv.Tx) (err error) {
			h, err = te.cfg.blockReader.Header(ctx, tx, hash, number)
			return err
		}); err != nil {
			return nil, err
		}
	}

	return h, nil
}

func (te *txExecutor) onBlockStart(ctx context.Context, blockNum uint64, blockHash common.Hash) {
	defer func() {
		if rec := recover(); rec != nil {
			te.logger.Warn("hook paniced: %s", rec, "stack", dbg.Stack())
		}
	}()

	if te.hooks == nil {
		return
	}

	if blockHash == (common.Hash{}) {
		te.logger.Warn("hooks ignored: zero block hash")
		return
	}

	if blockNum == 0 {
		if te.hooks.OnGenesisBlock != nil {
			var b *types.Block
			if err := te.applyTx.Apply(ctx, func(tx kv.Tx) (err error) {
				b, err = te.cfg.blockReader.BlockByHash(ctx, tx, blockHash)
				return err
			}); err != nil {
				te.logger.Warn("hook: OnGenesisBlock: abandoned", "err", err)
			}
			te.hooks.OnGenesisBlock(b, te.cfg.genesis.Alloc)
		}
	} else {
		if te.hooks.OnBlockStart != nil {
			var b *types.Block
			var td *big.Int
			var finalized *types.Header
			var safe *types.Header

			if err := te.applyTx.Apply(ctx, func(tx kv.Tx) (err error) {
				b, err = te.cfg.blockReader.BlockByHash(ctx, tx, blockHash)
				if err != nil {
					return err
				}
				chainReader := NewChainReaderImpl(te.cfg.chainConfig, te.applyTx, te.cfg.blockReader, te.logger)
				td = chainReader.GetTd(b.ParentHash(), b.NumberU64()-1)
				finalized = chainReader.CurrentFinalizedHeader()
				safe = chainReader.CurrentSafeHeader()
				return nil
			}); err != nil {
				te.logger.Warn("hook: OnBlockStart: abandoned", "err", err)
			}

			te.hooks.OnBlockStart(tracing.BlockEvent{
				Block:     b,
				TD:        td,
				Finalized: finalized,
				Safe:      safe,
			})
		}
	}
}

func (te *txExecutor) executeBlocks(ctx context.Context, tx kv.Tx, blockNum uint64, maxBlockNum uint64, readAhead chan uint64, applyResults chan applyResult) error {
	inputTxNum, _, offsetFromBlockBeginning, err := restoreTxNum(ctx, &te.cfg, tx, te.doms, maxBlockNum)

	if err != nil {
		return err
	}

	if te.execLoopGroup == nil {
		return errors.New("no exec group")
	}

	te.execLoopGroup.Go(func() (err error) {
		defer func() {
			if rec := recover(); rec != nil {
				err = fmt.Errorf("exec blocks panic: %s", rec)
			} else if err != nil && !errors.Is(err, context.Canceled) {
				err = fmt.Errorf("exec blocks error: %w", err)
			} else {
				te.logger.Debug("[" + te.logPrefix + "] exec blocks exit")
			}
		}()

		for ; blockNum <= maxBlockNum; blockNum++ {
			changeset := &libstate.StateChangeSet{}
			if te.shouldGenerateChangesets && blockNum > 0 {
				te.doms.SetChangesetAccumulator(changeset)
			}

			select {
			case readAhead <- blockNum:
			default:
			}

			var b *types.Block
			err := tx.Apply(ctx, func(tx kv.Tx) error {
				b, err = exec3.BlockWithSenders(ctx, te.cfg.db, tx, te.cfg.blockReader, blockNum)
				return err
			})
			if err != nil {
				return err
			}
			if b == nil {
				return fmt.Errorf("nil block %d", blockNum)
			}

			txs := b.Transactions()
			header := b.HeaderNoCopy()
			skipAnalysis := core.SkipAnalysis(te.cfg.chainConfig, blockNum)
			getHashFnMutex := sync.Mutex{}

			blockContext := core.NewEVMBlockContext(header, core.GetHashFn(header, func(hash common.Hash, number uint64) (h *types.Header, err error) {
				getHashFnMutex.Lock()
				defer getHashFnMutex.Unlock()
				err = tx.Apply(ctx, func(tx kv.Tx) (err error) {
					h, err = te.cfg.blockReader.Header(ctx, tx, hash, number)
					return err
				})

				if err != nil {
					return nil, err
				}

				return h, err
			}), te.cfg.engine, te.cfg.author, te.cfg.chainConfig)

			var txTasks []exec.Task

			for txIndex := -1; txIndex <= len(txs); txIndex++ {
				if inputTxNum > 0 && inputTxNum <= te.progress.initialTxNum {
					inputTxNum++
					continue
				}

				// Do not oversend, wait for the result heap to go under certain size
				txTask := &exec.TxTask{
					TxNum:           inputTxNum,
					TxIndex:         txIndex,
					Header:          header,
					Uncles:          b.Uncles(),
					Txs:             txs,
					SkipAnalysis:    skipAnalysis,
					EvmBlockContext: blockContext,
					Withdrawals:     b.Withdrawals(),
					// use history reader instead of state reader to catch up to the tx where we left off
					HistoryExecution: offsetFromBlockBeginning > 0 && txIndex < int(offsetFromBlockBeginning),
					Config:           te.cfg.chainConfig,
					Engine:           te.cfg.engine,
					Trace:            dbg.TraceTx(blockNum, txIndex),
					Hooks:            te.hooks,
				}

				txTasks = append(txTasks, txTask)
				inputTxNum++
			}

			te.execRequests <- &execRequest{
				b.Number().Uint64(), b.Hash(),
				core.NewGasPool(b.GasLimit(), te.cfg.chainConfig.GetMaxBlobGasPerBlock(b.Time())),
				txTasks, applyResults, false,
			}

			mxExecBlocks.Add(1)

			if offsetFromBlockBeginning > 0 {
				// after history execution no offset will be required
				offsetFromBlockBeginning = 0
			}
		}

		return nil
	})

	return nil
}

func (te *txExecutor) commit(ctx context.Context, execStage *StageState, tx kv.RwTx, useExternalTx bool, resetWorkers func(ctx context.Context, rs *state.StateV3Buffered, applyTx kv.Tx) error) (kv.RwTx, time.Duration, error) {
	err := execStage.Update(tx, te.lastCommittedBlockNum)

	if err != nil {
		return nil, 0, err
	}

	_, err = rawdb.IncrementStateVersion(tx)

	if err != nil {
		return nil, 0, fmt.Errorf("writing plain state version: %w", err)
	}

	tx.CollectMetrics()

	var t2 time.Duration

	if !useExternalTx {
		tt := time.Now()
		err = tx.Commit()

		if err != nil {
			return nil, 0, err
		}

		t2 = time.Since(tt)
		tx, err = te.cfg.db.BeginRw(ctx)

		if err != nil {
			return nil, t2, err
		}
	}

	err = resetWorkers(ctx, te.rs, tx)

	if err != nil {
		if !useExternalTx {
			tx.Rollback()
		}

		return nil, t2, err
	}

	if !useExternalTx {
		te.agg.BuildFilesInBackground(te.lastCommittedTxNum)
	}

	te.doms.ClearRam(false)

	return tx, t2, nil
}

type execRequest struct {
	blockNum     uint64
	blockHash    common.Hash
	gasPool      *core.GasPool
	tasks        []exec.Task
	applyResults chan applyResult
	profile      bool
}

type blockExecutor struct {
	sync.Mutex
	blockNum  uint64
	blockHash common.Hash

	tasks   []*execTask
	results []*execResult

	// For a task that runs only after all of its preceding tasks have finished and passed validation,
	// its result will be absolutely valid and therefore its validation could be skipped.
	// This map stores the boolean value indicating whether a task satisfy this condition (absolutely valid).
	skipCheck map[int]bool

	// Execution tasks stores the state of each execution task
	execTasks execStatusList

	// Validate tasks stores the state of each validation task
	validateTasks execStatusList

	// Publish tasks stores the state tasks ready for publication
	publishTasks execStatusList

	// Multi-version map
	versionMap *state.VersionMap

	// Stores the inputs and outputs of the last incarnation of all transactions
	blockIO *state.VersionedIO

	// Tracks the incarnation number of each transaction
	txIncarnations []int

	// A map that stores the estimated dependency of a transaction if it is aborted without any known dependency
	estimateDeps map[int][]int

	// A map that records whether a transaction result has been speculatively validated
	preValidated map[int]bool

	// Time records when the parallel execution starts
	begin time.Time

	// Enable profiling
	profile bool

	// Stats for debugging purposes
	cntExec, cntSpecExec, cntSuccess, cntAbort, cntTotalValidations, cntValidationFail, cntFinalized int

	// cummulative gas for this block
	gasUsed     uint64
	blobGasUsed uint64
	gasPool     *core.GasPool

	execFailed, execAborted []int

	// Stores the execution statistics for the last incarnation of each task
	stats map[int]ExecutionStat

	applyResults chan applyResult

	execStarted time.Time
	result      *blockResult
	applyCount  int
}

func newBlockExec(blockNum uint64, blockHash common.Hash, gasPool *core.GasPool, applyResults chan applyResult, profile bool) *blockExecutor {
	return &blockExecutor{
		blockNum:     blockNum,
		blockHash:    blockHash,
		begin:        time.Now(),
		stats:        map[int]ExecutionStat{},
		skipCheck:    map[int]bool{},
		estimateDeps: map[int][]int{},
		preValidated: map[int]bool{},
		blockIO:      &state.VersionedIO{},
		versionMap:   state.NewVersionMap(),
		profile:      profile,
		applyResults: applyResults,
		gasPool:      gasPool,
	}
}

func (be *blockExecutor) nextResult(ctx context.Context, pe *parallelExecutor, res *exec.TxResult, applyTx kv.Tx) (result *blockResult, err error) {
	task, ok := res.Task.(*taskVersion)

	if !ok {
		return nil, fmt.Errorf("unexpected task type: %T", res.Task)
	}

	tx := task.index
	be.results[tx] = &execResult{res}
	if res.Err != nil {
		if execErr, ok := res.Err.(core.ErrExecAbortError); ok {
			if execErr.OriginError != nil && be.skipCheck[tx] {
				// If the transaction failed when we know it should not fail, this means the transaction itself is
				// bad (e.g. wrong nonce), and we should exit the execution immediately
				return nil, fmt.Errorf("could not apply tx %d:%d [%v]: %w", be.blockNum, res.Version().TxIndex, task.TxHash(), execErr.OriginError)
			}

			if res.Version().Incarnation > len(be.tasks) {
				if execErr.OriginError != nil {
					return nil, fmt.Errorf("could not apply tx %d:%d [%v]: %w: too many incarnations: %d", be.blockNum, res.Version().TxIndex, task.TxHash(), execErr.OriginError, res.Version().Incarnation)
				} else {
					return nil, fmt.Errorf("could not apply tx %d:%d [%v]: too many incarnations: %d", be.blockNum, res.Version().TxIndex, task.TxHash(), res.Version().Incarnation)
				}
			}

			be.blockIO.RecordReads(res.Version().TxIndex, res.TxIn)
			var addedDependencies bool
			if execErr.DependencyTxIndex >= 0 {
				dependency := execErr.DependencyTxIndex + 1

				l := len(be.estimateDeps[tx])
				for l > 0 && be.estimateDeps[tx][l-1] > dependency {
					be.execTasks.removeDependency(be.estimateDeps[tx][l-1])
					be.estimateDeps[tx] = be.estimateDeps[tx][:l-1]
					l--
				}

				addedDependencies = be.execTasks.addDependency(dependency, tx)
				be.execAborted[tx]++

				if dbg.TraceTransactionIO && be.txIncarnations[tx] > 1 {
					fmt.Println(be.blockNum, "ABORT", tx, be.txIncarnations[tx], be.execFailed[tx], be.execAborted[tx], "dep", dependency, "err", execErr.OriginError)
				}
			} else {
				estimate := 0

				if len(be.estimateDeps[tx]) > 0 {
					estimate = be.estimateDeps[tx][len(be.estimateDeps[tx])-1]
				}
				addedDependencies = be.execTasks.addDependency(estimate, tx)
				newEstimate := estimate + (estimate+tx)/2
				if newEstimate >= tx {
					newEstimate = tx - 1
				}
				be.estimateDeps[tx] = append(be.estimateDeps[tx], newEstimate)
				be.execAborted[tx]++

				if dbg.TraceTransactionIO && be.txIncarnations[tx] > 1 {
					fmt.Println(be.blockNum, "ABORT", tx, be.txIncarnations[tx], be.execFailed[tx], be.execAborted[tx], "est dep", estimate, "err", execErr.OriginError)
				}
			}

			be.execTasks.clearInProgress(tx)

			if !addedDependencies {
				be.execTasks.pushPending(tx)
			}
			be.txIncarnations[tx]++
			be.cntAbort++
		} else {
			return nil, fmt.Errorf("unexptected exec error: %w", err)
		}
	} else {
		txIndex := res.Version().TxIndex

		be.blockIO.RecordReads(txIndex, res.TxIn)

		if res.Version().Incarnation == 0 {
			be.blockIO.RecordWrites(txIndex, res.TxOut)
			be.blockIO.RecordAllWrites(txIndex, res.TxOut)
		} else {
			if res.TxOut.HasNewWrite(be.blockIO.AllWriteSet(txIndex)) {
				be.validateTasks.pushPendingSet(be.execTasks.getRevalidationRange(tx + 1))
			}

			prevWrite := be.blockIO.AllWriteSet(txIndex)

			// Remove entries that were previously written but are no longer written

			cmpMap := map[common.Address]map[state.AccountKey]struct{}{}

			for _, w := range res.TxOut {
				keys, ok := cmpMap[w.Address]
				if !ok {
					keys = map[state.AccountKey]struct{}{}
					cmpMap[w.Address] = keys
				}
				keys[state.AccountKey{Path: w.Path, Key: w.Key}] = struct{}{}
			}

			for _, v := range prevWrite {
				if _, ok := cmpMap[v.Address][state.AccountKey{Path: v.Path, Key: v.Key}]; !ok {
					be.versionMap.Delete(v.Address, v.Path, v.Key, txIndex, true)
				}
			}

			be.blockIO.RecordWrites(txIndex, res.TxOut)
			be.blockIO.RecordAllWrites(txIndex, res.TxOut)
		}

		be.validateTasks.pushPending(tx)
		be.execTasks.markComplete(tx)
		be.cntSuccess++

		be.execTasks.removeDependency(tx)
	}

	// do validations ...
	maxComplete := be.execTasks.maxComplete()
	toValidate := make(sort.IntSlice, 0, 2)

	for be.validateTasks.minPending() <= maxComplete && be.validateTasks.minPending() >= 0 {
		toValidate = append(toValidate, be.validateTasks.takeNextPending())
	}

	cntInvalid := 0
	var stateReader state.StateReader
	var stateWriter *state.BufferedWriter

	for i := 0; i < len(toValidate); i++ {
		be.cntTotalValidations++

		tx := toValidate[i]
		txVersion := be.tasks[tx].Task.Version()
		txIncarnation := be.txIncarnations[tx]
		tracePrefix := ""

		var trace bool
		if trace = dbg.TraceTransactionIO && dbg.TraceTx(be.blockNum, txVersion.TxIndex); trace {
			tracePrefix = fmt.Sprintf("%d (%d.%d)", be.blockNum, txVersion.TxIndex, txIncarnation)
			fmt.Println(tracePrefix, "RD", be.blockIO.ReadSet(txVersion.TxIndex).Len(), "WRT", len(be.blockIO.WriteSet(txVersion.TxIndex)))
			be.blockIO.ReadSet(txVersion.TxIndex).Scan(func(vr *state.VersionedRead) bool {
				fmt.Println(tracePrefix, "RD", vr.String())
				return true
			})
			for _, vw := range be.blockIO.WriteSet(txVersion.TxIndex) {
				fmt.Println(tracePrefix, "WRT", vw.String())
			}
		}

		validity := state.ValidateVersion(txVersion.TxIndex, be.blockIO, be.versionMap,
			func(readVersion, writtenVersion state.Version) state.VersionValidity {
				vv := state.VersionValid

				if readVersion != writtenVersion {
					vv = state.VerionInvalid
				} else if writtenVersion.TxIndex == -1 && txVersion.TxIndex > be.validateTasks.maxComplete() {
					vv = state.VerionTooEarly
				}
				if vv != state.VersionValid {
					fmt.Println(be.blockNum, fmt.Sprintf("(%d.%d)", txVersion.TxIndex, txVersion.Incarnation), "ValidateVersion Failed",
						vv, readVersion, writtenVersion, be.validateTasks.maxComplete())
					be.versionMap.SetTrace(true)
				}
				return vv
			})

		be.versionMap.SetTrace(false)

		if validity == state.VerionTooEarly {
			cntInvalid++
			continue
		}

		valid := be.skipCheck[tx] || validity == state.VersionValid

		be.versionMap.SetTrace(trace)
		be.versionMap.FlushVersionedWrites(be.blockIO.WriteSet(txVersion.TxIndex), cntInvalid == 0, tracePrefix)
		be.versionMap.SetTrace(false)

		if valid {
			if cntInvalid == 0 {
				be.validateTasks.markComplete(tx)

				var prevReceipt *types.Receipt
				if txVersion.TxIndex > 0 && tx > 0 {
					prevReceipt = be.results[tx-1].Receipt
				}

				txResult := be.results[tx]

				if err := be.gasPool.SubGas(txResult.ExecutionResult.GasUsed); err != nil {
					return nil, err
				}

				txTask := be.tasks[tx].Task

				if txTask.Tx() != nil {
					blobGasUsed := txTask.Tx().GetBlobGas()
					if err := be.gasPool.SubBlobGas(blobGasUsed); err != nil {
						return nil, err
					}
					be.blobGasUsed += blobGasUsed
				}

				if stateReader == nil {
					stateReader = state.NewBufferedReader(pe.rs, state.NewReaderV3(pe.rs.Domains().AsGetter(applyTx)))
				}

				if stateWriter == nil {
					stateWriter = state.NewBufferedWriter(pe.rs, nil)
				}

				_, err = txResult.finalize(prevReceipt, pe.cfg.engine, be.versionMap, stateReader, stateWriter)

				if err != nil {
					return nil, err
				}

				be.publishTasks.pushPending(tx)
			}
		} else {
			cntInvalid++

			be.cntValidationFail++
			be.execFailed[tx]++

			if dbg.TraceTransactionIO && be.txIncarnations[tx] > 1 {
				fmt.Println(be.blockNum, "FAILED", tx, be.txIncarnations[tx], "failed", be.execFailed[tx], "aborted", be.execAborted[tx])
			}

			// 'create validation tasks for all transactions > tx ...'
			be.validateTasks.pushPendingSet(be.execTasks.getRevalidationRange(tx + 1))
			be.validateTasks.clearInProgress(tx) // clear in progress - pending will be added again once new incarnation executes
			be.execTasks.clearComplete(tx)
			be.execTasks.pushPending(tx)
			be.preValidated[tx] = false
			be.txIncarnations[tx]++
		}
	}

	maxValidated := be.validateTasks.maxComplete()
	be.scheduleExecution(ctx, pe)

	if be.publishTasks.minPending() != -1 {
		toFinalize := make(sort.IntSlice, 0, 2)

		for be.publishTasks.minPending() <= maxValidated && be.publishTasks.minPending() >= 0 {
			toFinalize = append(toFinalize, be.publishTasks.takeNextPending())
		}

		applyResult := txResult{
			blockNum:   be.blockNum,
			traceFroms: map[common.Address]struct{}{},
			traceTos:   map[common.Address]struct{}{},
		}

		for i := 0; i < len(toFinalize); i++ {
			tx := toFinalize[i]
			txTask := be.tasks[tx].Task
			txResult := be.results[tx]

			applyResult.txNum = txTask.Version().TxNum
			if txResult.Receipt != nil {
				applyResult.gasUsed += int64(txResult.Receipt.GasUsed)
				be.gasUsed += txResult.Receipt.GasUsed
				applyResult.receipts = append(applyResult.receipts, txResult.Receipt)
			}

			applyResult.blockTime = txTask.BlockTime()
			applyResult.logs = append(applyResult.logs, txResult.Logs...)
			maps.Copy(applyResult.traceFroms, txResult.TraceFroms)
			maps.Copy(applyResult.traceTos, txResult.TraceTos)
			be.cntFinalized++
			be.publishTasks.markComplete(tx)
		}

		if applyResult.txNum > 0 {
			pe.executedGas.Add(int64(applyResult.gasUsed))
			pe.lastExecutedTxNum.Store(int64(applyResult.txNum))
			if stateWriter != nil {
				applyResult.stateUpdates = stateWriter.WriteSet()

				if applyResult.stateUpdates.BTreeG != nil {
					be.applyCount += applyResult.stateUpdates.UpdateCount()
					if dbg.TraceApply {
						applyResult.stateUpdates.TraceBlockUpdates(applyResult.blockNum, dbg.TraceBlock(applyResult.blockNum))
					}
				}
				stateWriter = nil
			}

			be.applyResults <- &applyResult
		}
	}

	if be.publishTasks.countComplete() == len(be.tasks) && be.execTasks.countComplete() == len(be.tasks) {
		pe.logger.Debug("exec summary", "block", be.blockNum, "tasks", len(be.tasks), "execs", be.cntExec,
			"speculative", be.cntSpecExec, "success", be.cntSuccess, "aborts", be.cntAbort, "validations", be.cntTotalValidations, "failures", be.cntValidationFail,
			"retries", fmt.Sprintf("%.2f%%", float64(be.cntAbort+be.cntValidationFail)/float64(be.cntExec)*100),
			"execs", fmt.Sprintf("%.2f%%", float64(be.cntExec)/float64(len(be.tasks))*100))

		var allDeps map[int]map[int]bool

		var deps state.DAG

		if be.profile {
			allDeps = state.GetDep(be.blockIO)
			deps = state.BuildDAG(be.blockIO, pe.logger)
		}

		isPartial := len(be.tasks) > 0 && be.tasks[0].Version().TxIndex != -1

		txTask := be.tasks[len(be.tasks)-1].Task

		var receipts types.Receipts

		for _, txResult := range be.results {
			if receipt := txResult.Receipt; receipt != nil {
				receipts = append(receipts, receipt)
			}
		}

		be.result = &blockResult{
			be.blockNum,
			txTask.BlockTime(),
			txTask.BlockHash(),
			txTask.BlockRoot(),
			nil,
			be.gasUsed,
			be.blobGasUsed,
			txTask.Version().TxNum,
			true,
			isPartial,
			be.applyCount,
			be.blockIO,
			receipts,
			be.stats,
			&deps,
			allDeps}
		return be.result, nil
	}

	var lastTxNum uint64
	if maxValidated >= 0 {
		lastTxTask := be.tasks[maxValidated].Task
		lastTxNum = lastTxTask.Version().TxNum
	}

	txTask := be.tasks[0].Task

	return &blockResult{
		be.blockNum,
		txTask.BlockTime(),
		txTask.BlockHash(),
		txTask.BlockRoot(),
		nil,
		be.gasUsed,
		be.blobGasUsed,
		lastTxNum,
		false,
		len(be.tasks) > 0 && be.tasks[0].Version().TxIndex != -1,
		be.applyCount,
		be.blockIO,
		nil,
		be.stats,
		nil,
		nil}, nil
}

func (be *blockExecutor) scheduleExecution(ctx context.Context, pe *parallelExecutor) {
	toExecute := make(sort.IntSlice, 0, 2)

	for be.execTasks.minPending() >= 0 {
		toExecute = append(toExecute, be.execTasks.takeNextPending())
	}

	maxValidated := be.validateTasks.maxComplete()
	for i := 0; i < len(toExecute); i++ {
		nextTx := toExecute[i]
		execTask := be.tasks[nextTx]
		if nextTx == maxValidated+1 {
			be.skipCheck[nextTx] = true
		} else {
			txIndex := execTask.Version().TxIndex
			if be.txIncarnations[nextTx] > 0 &&
				(be.execAborted[nextTx] > 0 || be.execFailed[nextTx] > 0 || !be.blockIO.HasReads(txIndex) ||
					state.ValidateVersion(txIndex, be.blockIO, be.versionMap,
						func(_, writtenVersion state.Version) state.VersionValidity {
							if writtenVersion.TxIndex < maxValidated &&
								writtenVersion.Incarnation == be.txIncarnations[writtenVersion.TxIndex+1] {
								return state.VersionValid
							}
							return state.VerionInvalid
						}) != state.VersionValid) {
				be.execTasks.pushPending(nextTx)
				continue
			}
			be.cntSpecExec++
		}

		if dbg.TraceTransactionIO && be.txIncarnations[nextTx] > 1 {
			fmt.Println(be.blockNum, "EXEC", nextTx, be.txIncarnations[nextTx], "maxValidated", maxValidated, be.blockIO.HasReads(nextTx), "failed", be.execFailed[nextTx], "aborted", be.execAborted[nextTx])
		}

		be.cntExec++

		if incarnation := be.txIncarnations[nextTx]; incarnation == 0 {
			pe.in.Add(ctx, &taskVersion{
				execTask:   execTask,
				version:    execTask.Version(),
				versionMap: be.versionMap,
				profile:    be.profile,
				stats:      be.stats,
				statsMutex: &be.Mutex})
		} else {
			version := execTask.Version()
			version.Incarnation = incarnation
			pe.in.ReTry(&taskVersion{
				execTask:   execTask,
				version:    version,
				versionMap: be.versionMap,
				profile:    be.profile,
				stats:      be.stats,
				statsMutex: &be.Mutex})
		}
	}
}

type parallelExecutor struct {
	txExecutor
	execWorkers    []*exec3.Worker
	stopWorkers    func()
	waitWorkers    func()
	in             *exec.QueueWithRetry
	rws            *exec.ResultsQueue
	workerCount    int
	blockExecutors map[uint64]*blockExecutor
}

func (pe *parallelExecutor) LogExecuted() {
	pe.progress.LogExecuted(pe.rs.StateV3, pe)
}

func (pe *parallelExecutor) LogCommitted(commitStart time.Time, stepsInDb float64) {
	pe.progress.LogCommitted(pe.rs.StateV3, pe, commitStart, stepsInDb)
}

func (pe *parallelExecutor) LogComplete(stepsInDb float64) {
	pe.progress.LogComplete(pe.rs.StateV3, pe, stepsInDb)
}

func (pe *parallelExecutor) flushAndCommit(ctx context.Context, execStage *StageState, applyTx kv.RwTx, asyncTxChan mdbx.TxApplyChan, useExternalTx bool) (kv.RwTx, error) {
	flushStart := time.Now()
	var flushTime time.Duration

	if !pe.inMemExec {
		if err := pe.doms.Flush(ctx, applyTx); err != nil {
			return applyTx, err
		}
		flushTime = time.Since(flushStart)
	}

	commitStart := time.Now()
	var t2 time.Duration
	var err error
	if applyTx, t2, err = pe.commit(ctx, execStage, applyTx, asyncTxChan, useExternalTx); err != nil {
		return applyTx, err
	}

	pe.logger.Info("Flushed", "time", time.Since(flushStart), "flush", flushTime, "commit", time.Since(commitStart), "db", t2, "externaltx", useExternalTx)
	return applyTx, nil
}

func (pe *parallelExecutor) commit(ctx context.Context, execStage *StageState, tx kv.RwTx, asyncTxChan mdbx.TxApplyChan, useExternalTx bool) (kv.RwTx, time.Duration, error) {
	pe.pause()
	defer pe.resume()

	for {
		waiter, paused := pe.paused()
		if paused {
			break
		}
		select {
		case request := <-asyncTxChan:
			request.Apply()
		case <-ctx.Done():
			return nil, 0, ctx.Err()
		case <-waiter:
		}
	}

	return pe.txExecutor.commit(ctx, execStage, tx, useExternalTx, pe.resetWorkers)
}

func (pe *parallelExecutor) pause() {
	for _, worker := range pe.execWorkers {
		worker.Pause()
	}
}

func (pe *parallelExecutor) paused() (chan any, bool) {
	for _, worker := range pe.execWorkers {
		if waiter, paused := worker.Paused(); !paused {
			return waiter, false
		}
	}

	return nil, true
}

func (pe *parallelExecutor) resume() {
	for _, worker := range pe.execWorkers {
		worker.Resume()
	}
}

func (pe *parallelExecutor) resetWorkers(ctx context.Context, rs *state.StateV3Buffered, applyTx kv.Tx) error {
	pe.Lock()
	defer pe.Unlock()

	for _, worker := range pe.execWorkers {
		worker.ResetState(rs, nil, nil, state.NewNoopWriter(), nil)
	}

	return nil
}

func (pe *parallelExecutor) execLoop(ctx context.Context) (err error) {
	defer func() {
		pe.Lock()
		applyTx := pe.applyTx
		pe.applyTx = nil
		pe.Unlock()

		if applyTx != nil {
			applyTx.Rollback()
		}
	}()

	defer func() {
		if rec := recover(); rec != nil {
			pe.logger.Warn("["+pe.logPrefix+"] exec loop panic", "rec", rec, "stack", dbg.Stack())
		} else if err != nil && !errors.Is(err, context.Canceled) {
			pe.logger.Warn("["+pe.logPrefix+"] exec loop error", "err", err)
		} else {
			pe.logger.Debug("[" + pe.logPrefix + "] exec loop exit")
		}
	}()

	pe.RLock()
	applyTx := pe.applyTx
	pe.RUnlock()

	for {
		err := func() error {
			pe.Lock()
			defer pe.Unlock()
			if applyTx != pe.applyTx {
				if applyTx != nil {
					applyTx.Rollback()
				}
			}

			if pe.applyTx == nil {
				pe.applyTx, err = pe.cfg.db.BeginRo(ctx)

				if err != nil {
					return err
				}

				applyTx = pe.applyTx
			}
			return nil
		}()

		if err != nil {
			return err
		}

		select {
		case exec := <-pe.execRequests:
			if err := pe.processRequest(ctx, exec); err != nil {
				return err
			}
			continue
		case <-ctx.Done():
			return ctx.Err()
		case nextResult, ok := <-pe.rws.ResultCh():
			if !ok {
				return nil
			}
			closed, err := pe.rws.Drain(ctx, nextResult)
			if err != nil {
				return err
			}
			if closed {
				return nil
			}
		}

		blockResult, err := pe.processResults(ctx, applyTx)

		if err != nil {
			return err
		}

		if blockResult.complete {
			if blockExecutor, ok := pe.blockExecutors[blockResult.BlockNum]; ok {
				pe.lastExecutedBlockNum.Store(int64(blockResult.BlockNum))
				pe.execCount.Add(int64(blockExecutor.cntExec))
				pe.abortCount.Add(int64(blockExecutor.cntAbort))
				pe.invalidCount.Add(int64(blockExecutor.cntValidationFail))
				pe.readCount.Add(blockExecutor.blockIO.ReadCount())
				pe.writeCount.Add(blockExecutor.blockIO.WriteCount())

				blockReceipts := make([]*types.Receipt, 0, len(blockExecutor.results))
				for _, result := range blockExecutor.results {
					if result.Receipt != nil {
						blockReceipts = append(blockReceipts, result.Receipt)
					}
				}

				if blockResult.BlockNum > 0 {
					result := blockExecutor.results[len(blockExecutor.results)-1]

					stateUpdates, err := func() (state.StateUpdates, error) {
						pe.RLock()
						defer pe.RUnlock()

						ibs := state.New(state.NewBufferedReader(pe.rs, state.NewReaderV3(pe.rs.Domains().AsGetter(applyTx))))
						ibs.SetTxContext(result.Version().BlockNum, result.Version().TxIndex)
						ibs.SetVersion(result.Version().Incarnation)

						txTask := result.Task.(*taskVersion).Task.(*exec.TxTask)

						syscall := func(contract common.Address, data []byte) ([]byte, error) {
							ret, err := core.SysCallContract(contract, data, pe.cfg.chainConfig, ibs, txTask.Header, pe.cfg.engine, false, pe.hooks, vm.Config{})
							if err != nil {
								return nil, err
							}
							result.Logs = append(result.Logs, ibs.GetRawLogs(txTask.TxIndex)...)
							return ret, err
						}

						chainReader := consensuschain.NewReader(pe.cfg.chainConfig, applyTx, pe.cfg.blockReader, pe.logger)
						if pe.isMining {
							_, _, err =
								pe.cfg.engine.FinalizeAndAssemble(
									pe.cfg.chainConfig, types.CopyHeader(txTask.Header), ibs, txTask.Txs, txTask.Uncles, blockReceipts,
									txTask.Withdrawals, chainReader, syscall, nil, pe.logger)
						} else {
							_, err =
								pe.cfg.engine.Finalize(
									pe.cfg.chainConfig, types.CopyHeader(txTask.Header), ibs, txTask.Txs, txTask.Uncles, blockReceipts,
									txTask.Withdrawals, chainReader, syscall, false, pe.logger)
						}

						if err != nil {
							return state.StateUpdates{}, fmt.Errorf("can't finalize block: %w", err)
						}

						stateWriter := state.NewBufferedWriter(pe.rs, nil)

						if err = ibs.MakeWriteSet(pe.cfg.chainConfig.Rules(result.BlockNumber(), result.BlockTime()), stateWriter); err != nil {
							return state.StateUpdates{}, err
						}

						return stateWriter.WriteSet(), nil
					}()

					if err != nil {
						return err
					}

					blockResult.ApplyCount += stateUpdates.UpdateCount()
					if dbg.TraceApply && dbg.TraceBlock(blockResult.BlockNum) {
						stateUpdates.TraceBlockUpdates(blockResult.BlockNum, true)
						fmt.Println(blockResult.BlockNum, "apply count", blockResult.ApplyCount)
					}

					blockExecutor.applyResults <- &txResult{
						blockNum:     blockResult.BlockNum,
						txNum:        blockResult.lastTxNum,
						blockTime:    blockResult.BlockTime,
						stateUpdates: stateUpdates,
						logs:         result.Logs,
						traceFroms:   result.TraceFroms,
						traceTos:     result.TraceTos,
					}
				}

				if !blockExecutor.execStarted.IsZero() {
					pe.blockExecMetrics.Duration.Add(time.Since(blockExecutor.execStarted))
					pe.blockExecMetrics.BlockCount.Add(1)
				}
				blockExecutor.applyResults <- blockResult
				delete(pe.blockExecutors, blockResult.BlockNum)
			}

			if blockExecutor, ok := pe.blockExecutors[blockResult.BlockNum+1]; ok {
				pe.onBlockStart(ctx, blockExecutor.blockNum, blockExecutor.blockHash)
				blockExecutor.execStarted = time.Now()
				blockExecutor.scheduleExecution(ctx, pe)
			}
		}
	}
}

func (pe *parallelExecutor) processRequest(ctx context.Context, execRequest *execRequest) (err error) {
	prevSenderTx := map[common.Address]int{}
	var scheduleable *blockExecutor
	var executor *blockExecutor

	for i, txTask := range execRequest.tasks {
		t := &execTask{
			Task:               txTask,
			index:              i,
			shouldDelayFeeCalc: true,
		}

		blockNum := t.Version().BlockNum

		if executor == nil {
			var ok bool
			executor, ok = pe.blockExecutors[blockNum]

			if !ok {
				executor = newBlockExec(blockNum, execRequest.blockHash, execRequest.gasPool, execRequest.applyResults, execRequest.profile)
			}
		}

		executor.tasks = append(executor.tasks, t)
		executor.results = append(executor.results, nil)
		executor.txIncarnations = append(executor.txIncarnations, 0)
		executor.execFailed = append(executor.execFailed, 0)
		executor.execAborted = append(executor.execAborted, 0)

		executor.skipCheck[len(executor.tasks)-1] = false
		executor.estimateDeps[len(executor.tasks)-1] = []int{}

		executor.execTasks.pushPending(i)
		executor.validateTasks.pushPending(i)

		if len(t.Dependencies()) > 0 {
			for _, depTxIndex := range t.Dependencies() {
				executor.execTasks.addDependency(depTxIndex+1, i)
			}
			executor.execTasks.clearPending(i)
		} else {
			sender, err := t.TxSender()
			if err != nil {
				return err
			}
			if sender != nil {
				if tx, ok := prevSenderTx[*sender]; ok {
					executor.execTasks.addDependency(tx, i)
					executor.execTasks.clearPending(i)
				}

				prevSenderTx[*sender] = i
			}
		}

		if t.IsBlockEnd() {
			if len(pe.blockExecutors) == 0 {
				pe.blockExecutors = map[uint64]*blockExecutor{
					blockNum: executor,
				}
				scheduleable = executor
			} else {
				pe.blockExecutors[t.Version().BlockNum] = executor
			}

			executor = nil
		}
	}

	if scheduleable != nil {
		pe.blockExecMetrics.BlockCount.Add(1)
		scheduleable.execStarted = time.Now()
		scheduleable.scheduleExecution(ctx, pe)
	}

	return nil
}

func (pe *parallelExecutor) processResults(ctx context.Context, applyTx kv.Tx) (blockResult *blockResult, err error) {
	rwsIt := pe.rws.Iter()
	for rwsIt.HasNext() && (blockResult == nil || !blockResult.complete) {
		txResult := rwsIt.PopNext()

		if pe.cfg.syncCfg.ChaosMonkey && pe.enableChaosMonkey {
			chaosErr := chaos_monkey.ThrowRandomConsensusError(false, txResult.Version().TxIndex, pe.cfg.badBlockHalt, txResult.Err)
			if chaosErr != nil {
				log.Warn("Monkey in consensus")
				return blockResult, chaosErr
			}
		}

		blockExecutor, ok := pe.blockExecutors[txResult.Version().BlockNum]

		if !ok {
			return nil, fmt.Errorf("unknown block: %d", txResult.Version().BlockNum)
		}

		blockResult, err = blockExecutor.nextResult(ctx, pe, txResult, applyTx)

		if err != nil {
			return blockResult, err
		}
	}

	return blockResult, nil
}

func (pe *parallelExecutor) run(ctx context.Context) (context.Context, context.CancelFunc) {
	pe.execRequests = make(chan *execRequest, 100_000)
	pe.in = exec.NewQueueWithRetry(100_000)

	pe.taskExecMetrics = exec3.NewWorkerMetrics()
	pe.blockExecMetrics = newBlockExecMetrics()

	execLoopCtx, execLoopCtxCancel := context.WithCancel(ctx)
	pe.execLoopGroup, execLoopCtx = errgroup.WithContext(execLoopCtx)

	pe.execWorkers, _, pe.rws, pe.stopWorkers, pe.waitWorkers = exec3.NewWorkersPool(
		execLoopCtx, nil, true, pe.cfg.db, nil, nil, nil, pe.in,
		pe.cfg.blockReader, pe.cfg.chainConfig, pe.cfg.genesis, pe.cfg.engine,
		pe.workerCount+1, pe.taskExecMetrics, pe.cfg.dirs, pe.isMining, pe.logger)

	pe.execLoopGroup.Go(func() error {
		defer pe.rws.Close()
		defer pe.in.Close()
		pe.resetWorkers(execLoopCtx, pe.rs, nil)
		return pe.execLoop(execLoopCtx)
	})

	return execLoopCtx, func() {
		execLoopCtxCancel()
		pe.wait(ctx)
		pe.stopWorkers()
		pe.in.Close()
	}
}

func (pe *parallelExecutor) wait(ctx context.Context) error {
	doneCh := make(chan error)

	go func() {
		if pe.execLoopGroup != nil {
			err := pe.execLoopGroup.Wait()
			if err != nil {
				doneCh <- err
				return
			}
			pe.waitWorkers()
		}
		doneCh <- nil
	}()

	for {
		select {
		case <-ctx.Done():
			return ctx.Err()
		case err := <-doneCh:
			return err
		}
	}
}
