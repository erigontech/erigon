#!/usr/bin/env bash
# Runs a named test group. Usage: run-test-group [--check] [<test-group>]
# With no argument, runs all groups sequentially.
# Environment: GODEBUG, GOTRACEBACK, GOGC, CGO_CFLAGS, SKIP_FLAKY_TESTS, GOFLAGS

set -euo pipefail

ALL_GROUPS="execution-tests eest-frontier-scenarios eest-osaka-clz eest-prague-calldata eest-cancun-blobs execution-other consensus core-rpc other"

run_tests() {
  go test "$@" 2>&1 | "$(dirname "$0")/filter-test-output" | tee -a run.log
}

# packages_for_group emits package specs for the given group
packages_for_group() {
  case "$1" in
    execution-tests)
      go list ./execution/tests/... | grep -v '/eest_'
      ;;
    eest-frontier-scenarios)  echo ./execution/tests/eest_frontier_scenarios/... ;;
    eest-osaka-clz)           echo ./execution/tests/eest_osaka_clz/... ;;
    eest-prague-calldata)     echo ./execution/tests/eest_prague_calldata/... ;;
    eest-cancun-blobs)        echo ./execution/tests/eest_cancun_blobs/... ;;
    execution-other)
      comm -23 \
        <(go list ./execution/... 2>/dev/null | sort) \
        <(go list $(for g in $ALL_GROUPS; do
            case "$g" in execution-tests|eest-*) packages_for_group "$g" ;; esac
          done) 2>/dev/null | sort)
      ;;
    consensus)  echo ./cl/... ;;
    core-rpc)   echo ./db/... ./node/... ./txnprovider/... ./p2p/... ./rpc/... ;;
    other)
      comm -23 \
        <(go list ./... 2>/dev/null | sort) \
        <(go list $(for g in $ALL_GROUPS; do
            [ "$g" = other ] && continue
            packages_for_group "$g"
          done) 2>/dev/null | sort)
      ;;
    *)
      echo "Error: Unknown test-group '$1'" >&2
      return 1
      ;;
  esac
}

# timeout_for_group returns the timeout for the given group
timeout_for_group() {
  case "$1" in
    execution-tests|eest-*|consensus) echo 60m ;;
    *) echo 30m ;;
  esac
}

# No argument: run all groups sequentially
if [ $# -eq 0 ]; then
  for group in $ALL_GROUPS; do
    "$0" "$group"
  done
  exit
fi

# check_partitioning: validate group package files in tmpdir for overlaps/gaps.
# Expects: $tmpdir/group-*.txt (one per group, already sorted), $tmpdir/all_repo_pkgs.txt (sorted).
# Returns 0 if clean, 1 if overlaps or gaps found.
check_partitioning() {
  local tmpdir="$1"
  local ok=true

  sort "$tmpdir"/group-*.txt > "$tmpdir/all_group_pkgs.txt"

  overlaps=$(uniq -d "$tmpdir/all_group_pkgs.txt")
  if [ -n "$overlaps" ]; then
    echo "ERROR: packages appear in multiple groups:" >&2
    echo "$overlaps" | sed 's/^/  /' >&2
    ok=false
  fi

  sort -u "$tmpdir/all_group_pkgs.txt" > "$tmpdir/group_pkgs_dedup.txt"

  missing=$(comm -23 "$tmpdir/all_repo_pkgs.txt" "$tmpdir/group_pkgs_dedup.txt")
  if [ -n "$missing" ]; then
    echo "ERROR: packages not covered by any group:" >&2
    echo "$missing" | sed 's/^/  /' >&2
    ok=false
  fi

  extra=$(comm -13 "$tmpdir/all_repo_pkgs.txt" "$tmpdir/group_pkgs_dedup.txt")
  if [ -n "$extra" ]; then
    echo "WARNING: group packages not found in ./...:" >&2
    echo "$extra" | sed 's/^/  /' >&2
  fi

  $ok
}

# --check: validate group partitioning against the full package list
if [ "${1}" = "--check" ]; then
  echo "Checking test group partitioning..."

  tmpdir=$(mktemp -d)
  trap 'rm -rf "$tmpdir"' EXIT

  for group in $ALL_GROUPS; do
    pkgs=$(go list $(packages_for_group "$group") 2>/dev/null | sort || true)
    echo "$pkgs" | awk 'NF' > "$tmpdir/group-$group.txt"
    count=$(echo "$pkgs" | awk 'NF' | wc -l | tr -d ' ')
    echo "  $group: $count packages"
  done

  go list ./... 2>/dev/null | sort > "$tmpdir/all_repo_pkgs.txt"

  if check_partitioning "$tmpdir"; then
    echo "OK: no overlaps or gaps"
    exit 0
  else
    exit 1
  fi
fi

# --self-test: verify that check_partitioning correctly detects overlaps and passes clean cases
if [ "${1}" = "--self-test" ]; then
  echo "Running self-test for overlap detection..."
  self_test_ok=true

  # Test 1: overlapping groups must fail
  t=$(mktemp -d)
  printf 'pkg/a\npkg/b\n' > "$t/group-x.txt"
  printf 'pkg/b\npkg/c\n' > "$t/group-y.txt"
  printf 'pkg/a\npkg/b\npkg/c\n' > "$t/all_repo_pkgs.txt"
  if check_partitioning "$t" 2>/dev/null; then
    echo "FAIL: overlap test should have failed but passed" >&2
    self_test_ok=false
  else
    echo "PASS: overlap detection works"
  fi
  rm -rf "$t"

  # Test 2: clean partition must pass
  t=$(mktemp -d)
  printf 'pkg/a\n' > "$t/group-x.txt"
  printf 'pkg/b\npkg/c\n' > "$t/group-y.txt"
  printf 'pkg/a\npkg/b\npkg/c\n' > "$t/all_repo_pkgs.txt"
  if check_partitioning "$t" 2>/dev/null; then
    echo "PASS: clean partition check passes"
  else
    echo "FAIL: clean partition should have passed but failed" >&2
    self_test_ok=false
  fi
  rm -rf "$t"

  if $self_test_ok; then
    echo "Self-test OK"
    exit 0
  else
    exit 1
  fi
fi

PKGS=$(packages_for_group "$1")
run_tests -timeout "$(timeout_for_group "$1")" $PKGS
