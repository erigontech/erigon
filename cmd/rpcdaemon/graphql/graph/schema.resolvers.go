package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.24

import (
	"context"
	"fmt"
	"strconv"

	"github.com/ledgerwatch/erigon/cmd/rpcdaemon/graphql/graph/model"
	"github.com/ledgerwatch/erigon/rpc"
)

// SendRawTransaction is the resolver for the sendRawTransaction field.
func (r *mutationResolver) SendRawTransaction(ctx context.Context, data string) (string, error) {
	panic(fmt.Errorf("not implemented: SendRawTransaction - sendRawTransaction"))
}

// Block is the resolver for the block field.
func (r *queryResolver) Block(ctx context.Context, number *int64, hash *string) (*model.Block, error) {
	var blockNumber rpc.BlockNumber

	// If number is not specified (nil), we should deliver "latest" block
	if number == nil {
		blockNumber = rpc.LatestExecutedBlockNumber
	} else {
		if *number < 0 {
			var err error
			return nil, err
		}
		blockNumber = rpc.BlockNumber(*number)
	}

	res, err := r.GraphQLAPI.GetBlockDetails(ctx, blockNumber)
	if err != nil {
		fmt.Println(err)
		return nil, err
	}

	absBlk := res["block"]
	blk := absBlk.(map[string]interface{})

	block := &model.Block{}
	block.Difficulty = *convertDataToStringP(blk, "difficulty")
	block.ExtraData = *convertDataToStringP(blk, "extraData")
	block.GasLimit = int64(*convertDataToInt64P(blk, "gasLimit"))
	block.GasUsed = convertDataToInt64P(blk, "gasUsed")
	block.Hash = *convertDataToStringP(blk, "hash")
	block.Miner = &model.Account{}
	block.Miner.Address = *convertDataToStringP(blk, "miner")
	block.MixHash = *convertDataToStringP(blk, "mixHash")
	block.Nonce = *convertDataToStringP(blk, "nonce")
	block.Number, _ = strconv.ParseInt(*convertDataToStringP(blk, "number"), 10, 64)
	block.Ommers = []*model.Block{}
	block.Parent = &model.Block{}
	block.Parent.Hash = *convertDataToStringP(blk, "parentHash")
	block.ReceiptsRoot = *convertDataToStringP(blk, "receiptsRoot")
	block.StateRoot = *convertDataToStringP(blk, "stateRoot")
	block.Timestamp = int64(*convertDataToIntP(blk, "timestamp"))
	block.TransactionCount = convertDataToIntP(blk, "transactionCount")
	block.TransactionsRoot = *convertDataToStringP(blk, "transactionsRoot")
	block.TotalDifficulty = *convertDataToStringP(blk, "totalDifficulty")

	block.Transactions = []*model.Transaction{}
	absRcp := res["receipts"]
	rcp := absRcp.([]map[string]interface{})
	for _, transReceipt := range rcp {
		trans := &model.Transaction{}
		trans.CumulativeGasUsed = convertDataToInt64P(transReceipt, "cumulativeGasUsed")
		trans.EffectiveGasPrice = convertDataToInt64P(transReceipt, "effectiveGasPrice")
		trans.GasUsed = convertDataToInt64P(transReceipt, "gasUsed")
		trans.Hash = *convertDataToStringP(transReceipt, "transactionHash")
		trans.Index = convertDataToIntP(transReceipt, "transactionIndex")
		trans.Status = convertDataToInt64P(transReceipt, "status")
		trans.Type = convertDataToIntP(transReceipt, "type")
		// convertDataToStringP(transReceipt, "logsBloom")

		trans.From = &model.Account{}
		trans.From.Address = *convertDataToStringP(transReceipt, "from")

		trans.To = &model.Account{}
		trans.To.Address = *convertDataToStringP(transReceipt, "to")

		block.Transactions = append(block.Transactions, trans)
	}

	return block, ctx.Err()
}

// Blocks is the resolver for the blocks field.
func (r *queryResolver) Blocks(ctx context.Context, from *int64, to *int64) ([]*model.Block, error) {
	panic(fmt.Errorf("not implemented: Blocks - blocks"))
}

// Pending is the resolver for the pending field.
func (r *queryResolver) Pending(ctx context.Context) (*model.Pending, error) {
	panic(fmt.Errorf("not implemented: Pending - pending"))
}

// Transaction is the resolver for the transaction field.
func (r *queryResolver) Transaction(ctx context.Context, hash string) (*model.Transaction, error) {
	panic(fmt.Errorf("not implemented: Transaction - transaction"))
}

// Logs is the resolver for the logs field.
func (r *queryResolver) Logs(ctx context.Context, filter model.FilterCriteria) ([]*model.Log, error) {
	panic(fmt.Errorf("not implemented: Logs - logs"))
}

// GasPrice is the resolver for the gasPrice field.
func (r *queryResolver) GasPrice(ctx context.Context) (string, error) {
	panic(fmt.Errorf("not implemented: GasPrice - gasPrice"))
}

// MaxPriorityFeePerGas is the resolver for the maxPriorityFeePerGas field.
func (r *queryResolver) MaxPriorityFeePerGas(ctx context.Context) (string, error) {
	panic(fmt.Errorf("not implemented: MaxPriorityFeePerGas - maxPriorityFeePerGas"))
}

// Syncing is the resolver for the syncing field.
func (r *queryResolver) Syncing(ctx context.Context) (*model.SyncState, error) {
	panic(fmt.Errorf("not implemented: Syncing - syncing"))
}

// ChainID is the resolver for the chainID field.
func (r *queryResolver) ChainID(ctx context.Context) (string, error) {
	panic(fmt.Errorf("not implemented: ChainID - chainID"))
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
