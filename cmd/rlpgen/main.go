// Copyright 2025 The Erigon Authors
// This file is part of Erigon.
//
// Erigon is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Erigon is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with Erigon. If not, see <http://www.gnu.org/licenses/>.

// NOTE: This generator works only on structures, if the type is slice of types (e.g []MyType) it will fail.
//		 And not all the field types currently supported, see `matcher.go`
//		 This will be fixed in the future.

package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/types"
)

const (
	rlpPackagePath = "github.com/erigontech/erigon-lib/rlp"
)

const headerMsg = "// Code generated by rlpgen. DO NOT EDIT.\n\n"

// var (
// 	_imports = map[string]bool{}
// 	pkgSrc   *types.Package
// )

type gen struct {
	named    *types.Named
	imports  map[string]bool
	content  []byte // encoding size, encode rlp and decode rlp logic for each named type
	pkgDir   string
	pkgSrc   string
	filename string // gen_<typename>_rlp.go or could be gen_common_rlp.go if multiple types being encoded in the same package, so gen_common_rlp.go will contain all methods for the types in the single file
}

var gens = map[string][]gen{}

// var gens []gen

func main() {
	var (
		pkgdir   = flag.String("dir", ".", "input package")
		typename = flag.String("type", "", "type to generate methods for")
		// writefile = flag.Bool("wfile", true, "set to false if no need to write to the file")
	)
	flag.Parse()

	_process(pkgdir, typename)
}

func _process(pkgdir *string, typename *string) {
	pkg := loadPkg(pkgdir)
	pkgSrc := pkg[0].Types

	fmt.Println("pkgSrc: ", pkgSrc.Name())
	fmt.Println("typename: ", *typename)

	// 1. search for a struct
	typ, err := findType(pkgSrc.Scope(), *typename)
	if err != nil {
		_exit(err.Error())
	}

	var b1, b2, b3 bytes.Buffer // encodingSize, encodeRLP, decodeRLP buffers

	g := gen{
		named:   typ,
		imports: make(map[string]bool),
		pkgDir:  *pkgdir,
		pkgSrc:  typ.Obj().Pkg().Name(),
	}

	if err := generate(&b1, &b2, &b3, typ, &g); err != nil {
		_exit(err.Error())
	}

	g.content = b1.Bytes()
	g.content = append(g.content, b2.Bytes()...)
	g.content = append(g.content, b3.Bytes()...)

	if _, ok := gens[g.pkgSrc]; !ok {
		gens[g.pkgSrc] = make([]gen, 0)
	}

	gens[g.pkgSrc] = append(gens[g.pkgSrc], g)
}

// Generates rlp encoding and decoding methods for each named type in its package location.
// If the provided type has nested named type in it this results in repeated call to this function,
// sort of recursion
func generate(b1, b2, b3 *bytes.Buffer, typ *types.Named, g *gen) error {
	// TODO(racytech): handle all possible errors

	// if _struct, ok := typ.Underlying().(*types.Struct); ok {
	// 	for i := 0; i < _struct.NumFields(); i++ {

	// 		// strTyp := matchTypeToString(_struct.Field(i).Type(), "")
	// 		// fmt.Println("-+-", strTyp)
	// 		reflect.TypeOf(uint64(0))
	// 		a, ok := _struct.Field(i).Type().(*types.Named)
	// 		if ok {
	// 			fmt.Println(a)
	// 		} else {
	// 			fmt.Println(a)
	// 		}
	// 		// handleType(, nil, 0, false)

	// 		// matchStrTypeToFunc(strTyp)(b1, b2, b3, _struct.Field(i).Type(), _struct.Field(i).Name())
	// 		// handleType(g, _struct.Field(i).Type(), nil, 0, false)
	// 	}
	// }

	handleType(typ.Obj().Type(), nil, 0, false, g)

	return nil
}

type op struct {
	f func(b1, b2, b3 *bytes.Buffer, fieldType types.Type, fieldName string)
}

func handleType(t types.Type, caller types.Type, depth int, ptr bool, g *gen) {
	// g.named.Underlying().(type)
	switch e := t.(type) {
	case *types.Pointer:
		if caller != nil {
			switch caller.(type) {
			case *types.Pointer:
				panic("double pointer")
			}
			fmt.Printf("caller: %v -> ", caller.String())
		}
		fmt.Println("*types.Pointer", depth)
		// check if double pointer, fail if depth > 0 and ptr == true

		// if t is Pointer type pass to the next level
		handleType(e.Elem(), t, depth+1, true, g)
	case *types.Named:
		if caller != nil {
			fmt.Printf("caller: %v -> ", caller.String())
		}
		fmt.Println("*types.Named", depth)
		// if t is user named type,
		// check if big.Int or uint256.Int -> check if pointer -> encode/decode accordingly -> return
		// check if rlp generated for this type -> if yes remove the file
		// else pass to the next level
		handleType(e.Underlying(), t, depth+1, false, g)
		// if underlying is a struct
		// 		check if rlp generated for this type -> if yes call RLP encode/decode methods on it, return
	case *types.Basic:
		if caller != nil {
			fmt.Printf("caller: %v -> ", caller.String())
		}
		fmt.Println("*types.Basic", depth)
		// check if caller Named (e.g type MyInt int) -> TODO
		// check if caller Slice or Array
		//		if t is byte slice or byte array -> encode -> return
		// check if caller Pointer -> encode -> return
		//
		// or if caller is nil -> call rlp encoding function on basic types, bool, uint, int etc.
		// return
	case *types.Slice:
		if caller != nil {
			fmt.Printf("caller: %v -> ", caller.String())
		}
		fmt.Println("*types.Slice", depth)
		// check if it's simple byteslice
		//		if yes call RLP encode/decode methods on it, return
		// check if it's slice of named types. e.g []common.Hash -> [][32]byte, or type MyStruct struct {a, b, c}
		// 				^TODO think about this case^
		//
		handleType(e.Elem(), t, depth+1, false, g)
	case *types.Array:
		if caller != nil {
			fmt.Printf("caller: %v -> ", caller.String())
		}
		fmt.Println("*types.Array", depth)
		// check if it's simple bytearray
		//		if yes call RLP encode/decode methods on it, return
		// check if it's slice of named types. e.g [10]common.Hash -> [10][32]byte, or type MyStruct struct {a, b, c}
		// 				^TODO think about this case^
		//
		handleType(e.Elem(), t, depth+1, false, g)
	case *types.Struct:
		// if caller != nil {
		// 	fmt.Printf("caller: %v -> ", caller.String())
		// }
		fmt.Println("*types.Struct", depth)
		// check if nested struct
		// 		if yes check if rlp previously generated for this type -> if yes remove the file
		// 		try generating rlp for this structure, e.g as follows:
		// 		generate(t) -> if successful
		//			add encoding/decoding logic of this struct to the buffers
		//			return

		// else -> top level call
		for i := 0; i < e.NumFields(); i++ {
			// this should panic and fail generating everything in case of error
			handleType(e.Field(i).Type(), t, depth+1, false, g)
		}
	default:
		panic("unhandled")
	}
}

// func addEncodeLogic(b1, b2, b3 *bytes.Buffer, g *gen) error {

// 	if _struct, ok := g.named.Underlying().(*types.Struct); ok {
// 		for i := 0; i < _struct.NumFields(); i++ {

// 			// strTyp := matchTypeToString(_struct.Field(i).Type(), "")
// 			// // fmt.Println("-+-", strTyp)

// 			// matchStrTypeToFunc(strTyp)(b1, b2, b3, _struct.Field(i).Type(), _struct.Field(i).Name())
// 			// handleType(g, _struct.Field(i).Type(), nil, 0, false)
// 		}
// 	}
// 	// else {

// 	// 	// TODO(racytech): see handleType
// 	// }

// 	return nil
// }

// // var b1, b2, b3 bytes.Buffer

// g := gen{
// 	named:    typ,
// 	imports:  make(map[string]bool),
// 	pkgDir:   getPkgDir(typ.Obj().Pkg().Path()),
// 	pkgSrc:   typ.Obj().Pkg().Name(),
// 	filename: typename,
// }

// fmt.Println(g.pkgDir)

// // 1. start EncodingSize method on a struct
// fmt.Fprintf(b1, "func (obj *%s) EncodingSize() (size int) {\n", typename)

// // 2. start EncodeRLP
// fmt.Fprintf(b2, "func (obj *%s) EncodeRLP(w io.Writer) error {\n", typename)
// fmt.Fprint(b2, "    var b [32]byte\n")
// fmt.Fprint(b2, "    if err := rlp.EncodeStructSizePrefix(obj.EncodingSize(), w, b[:]); err != nil {\n")
// fmt.Fprint(b2, "        return err\n")
// fmt.Fprint(b2, "    }\n")

// // 3. start DecodeRLP
// fmt.Fprintf(b3, "func (obj *%s) DecodeRLP(s *rlp.Stream) error {\n", typename)
// fmt.Fprint(b3, "    _, err := s.List()\n")
// fmt.Fprint(b3, "    if err != nil {\n")
// fmt.Fprint(b3, "        return err\n")
// fmt.Fprint(b3, "    }\n")

// // 4. add encoding/decoding logic
// // if err := addEncodeLogic(&b1, &b2, &b3, &g); err != nil {
// // 	return err
// // }

// // handleType(g, nil, 0, false)

// // 5. end EncodingSize method
// fmt.Fprintf(b1, "    return\n}\n\n")

// // 6. end EcnodeRLP
// fmt.Fprintf(b2, "    return nil\n}\n\n")

// // 7. end DecodeRLP
// fmt.Fprintf(b3, "    if err = s.ListEnd(); err != nil {\n")
// fmt.Fprintf(b3, "        return fmt.Errorf(\"error closing %s, err: %%w\", err)\n", typename)
// fmt.Fprintf(b3, "    }\n")
// fmt.Fprintf(b3, "    return nil\n}\n\n")

// result := b1.Bytes()
// result = append(result, b2.Bytes()...)
// result = append(result, b3.Bytes()...)
// g.content = result

// gens = append(gens, g)
