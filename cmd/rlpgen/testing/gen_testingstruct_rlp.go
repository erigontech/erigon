// Code generated by rlpgen. DO NOT EDIT.

package testing

import (
	"fmt"
	"io"
	"math/big"

	"github.com/holiman/uint256"

	"github.com/erigontech/erigon-lib/common"
	"github.com/erigontech/erigon/execution/rlp"
	"github.com/erigontech/erigon/execution/types"
)

func (obj *TestingStruct) EncodingSize() (size int) {
	size += rlp.IntLenExcludingHead(uint64(obj.a)) + 1
	if obj.aa != nil {
		size += rlp.IntLenExcludingHead(uint64(*obj.aa)) + 1
	}
	size += rlp.BigIntLenExcludingHead(&obj.b) + 1
	size += 1
	if obj.bb != nil {
		size += rlp.BigIntLenExcludingHead(obj.bb)
	}
	size += rlp.Uint256LenExcludingHead(&obj.c) + 1
	size += rlp.Uint256LenExcludingHead(obj.cc) + 1
	size += 8 + 1
	size += 1
	if obj.dd != nil {
		size += 8
	}
	size += 20 + 1
	size += 1
	if obj.ee != nil {
		size += 20
	}
	size += 32 + 1
	size += 1
	if obj.ff != nil {
		size += 32
	}
	size += 259
	size += 1
	if obj.gg != nil {
		size += 258
	}
	size += rlp.StringLen(obj.h)
	if obj.hh != nil {
		size += rlp.StringLen(*obj.hh)
	} else {
		size += 1
	}
	size += rlp.ByteSliceSliceSize(obj.i)
	gidx := 0
	gidx = (8 + 1) * len(obj.j)
	size += rlp.ListPrefixLen(gidx) + gidx
	gidx = 0
	for i := 0; i < len(obj.jj); i++ {
		if obj.jj[i] != nil {
			gidx += 8 + 1
		} else {
			gidx += 1
		}
	}
	size += rlp.ListPrefixLen(gidx) + gidx
	gidx = 0
	gidx = (20 + 1) * len(obj.k)
	size += rlp.ListPrefixLen(gidx) + gidx
	gidx = 0
	for i := 0; i < len(obj.kk); i++ {
		if obj.kk[i] != nil {
			gidx += 20 + 1
		} else {
			gidx += 1
		}
	}
	size += rlp.ListPrefixLen(gidx) + gidx
	gidx = 0
	gidx = (32 + 1) * len(obj.l)
	size += rlp.ListPrefixLen(gidx) + gidx
	gidx = 0
	for i := 0; i < len(obj.ll); i++ {
		if obj.ll[i] != nil {
			gidx += 32 + 1
		} else {
			gidx += 1
		}
	}
	size += rlp.ListPrefixLen(gidx) + gidx
	size += 10 + rlp.ListPrefixLen(10)
	if obj.mm != nil {
		size += 245
	}
	size += rlp.ListPrefixLen(245)
	return
}

func (obj *TestingStruct) EncodeRLP(w io.Writer) error {
	var b [32]byte
	if err := rlp.EncodeStructSizePrefix(obj.EncodingSize(), w, b[:]); err != nil {
		return err
	}
	if err := rlp.EncodeInt(uint64(obj.a), w, b[:]); err != nil {
		return err
	}
	if obj.aa != nil {
		if err := rlp.EncodeInt(uint64(*obj.aa), w, b[:]); err != nil {
			return err
		}
	}
	if err := rlp.EncodeBigInt(&obj.b, w, b[:]); err != nil {
		return err
	}
	if err := rlp.EncodeBigInt(obj.bb, w, b[:]); err != nil {
		return err
	}
	if err := rlp.EncodeUint256(&obj.c, w, b[:]); err != nil {
		return err
	}
	if err := rlp.EncodeUint256(obj.cc, w, b[:]); err != nil {
		return err
	}
	b[0] = 128 + 8
	if _, err := w.Write(b[:1]); err != nil {
		return err
	}
	if _, err := w.Write(obj.d[:]); err != nil {
		return err
	}
	if obj.dd != nil {
		b[0] = 128 + 8
	} else {
		b[0] = 128
	}
	if _, err := w.Write(b[:1]); err != nil {
		return err
	}
	if obj.dd != nil {
		if _, err := w.Write(obj.dd[:]); err != nil {
			return err
		}
	}
	b[0] = 128 + 20
	if _, err := w.Write(b[:1]); err != nil {
		return err
	}
	if _, err := w.Write(obj.e[:]); err != nil {
		return err
	}
	if obj.ee != nil {
		b[0] = 128 + 20
	} else {
		b[0] = 128
	}
	if _, err := w.Write(b[:1]); err != nil {
		return err
	}
	if obj.ee != nil {
		if _, err := w.Write(obj.ee[:]); err != nil {
			return err
		}
	}
	b[0] = 128 + 32
	if _, err := w.Write(b[:1]); err != nil {
		return err
	}
	if _, err := w.Write(obj.f[:]); err != nil {
		return err
	}
	if obj.ff != nil {
		b[0] = 128 + 32
	} else {
		b[0] = 128
	}
	if _, err := w.Write(b[:1]); err != nil {
		return err
	}
	if obj.ff != nil {
		if _, err := w.Write(obj.ff[:]); err != nil {
			return err
		}
	}
	b[0] = 183 + 2
	b[1] = 1
	b[2] = 0
	if _, err := w.Write(b[:3]); err != nil {
		return err
	}
	if _, err := w.Write(obj.g[:]); err != nil {
		return err
	}
	if obj.gg != nil {
		b[0] = 183 + 2
		b[1] = 1
		b[2] = 0
	} else {
		b[0] = 128
	}
	if obj.gg != nil {
		if _, err := w.Write(b[:3]); err != nil {
			return err
		}
		if _, err := w.Write(obj.gg[:]); err != nil {
			return err
		}
	} else {
		if _, err := w.Write(b[:1]); err != nil {
			return err
		}
	}
	if err := rlp.EncodeString(obj.h, w, b[:]); err != nil {
		return err
	}
	if obj.hh != nil {
		if err := rlp.EncodeString(*obj.hh, w, b[:]); err != nil {
			return err
		}
	} else {
		if err := rlp.EncodeString([]byte{}, w, b[:]); err != nil {
			return err
		}
	}
	if err := rlp.EncodeByteSliceSlice(obj.i, w, b[:]); err != nil {
		return err
	}
	gidx := 0
	gidx = (8 + 1) * len(obj.j)
	if err := rlp.EncodeStructSizePrefix(gidx, w, b[:]); err != nil {
		return err
	}
	for i := 0; i < len(obj.j); i++ {
		if err := rlp.EncodeString(obj.j[i][:], w, b[:]); err != nil {
			return err
		}
	}
	gidx = 0
	for i := 0; i < len(obj.jj); i++ {
		if obj.jj[i] != nil {
			gidx += 8 + 1
		} else {
			gidx += 1
		}
	}
	if err := rlp.EncodeStructSizePrefix(gidx, w, b[:]); err != nil {
		return err
	}
	for i := 0; i < len(obj.jj); i++ {
		if obj.jj[i] != nil {
			if err := rlp.EncodeString(obj.jj[i][:], w, b[:]); err != nil {
				return err
			}
		} else {
			if err := rlp.EncodeString([]byte{}, w, b[:]); err != nil {
				return err
			}
		}
	}
	gidx = 0
	gidx = (20 + 1) * len(obj.k)
	if err := rlp.EncodeStructSizePrefix(gidx, w, b[:]); err != nil {
		return err
	}
	for i := 0; i < len(obj.k); i++ {
		if err := rlp.EncodeString(obj.k[i][:], w, b[:]); err != nil {
			return err
		}
	}
	gidx = 0
	for i := 0; i < len(obj.kk); i++ {
		if obj.kk[i] != nil {
			gidx += 20 + 1
		} else {
			gidx += 1
		}
	}
	if err := rlp.EncodeStructSizePrefix(gidx, w, b[:]); err != nil {
		return err
	}
	for i := 0; i < len(obj.kk); i++ {
		if obj.kk[i] != nil {
			if err := rlp.EncodeString(obj.kk[i][:], w, b[:]); err != nil {
				return err
			}
		} else {
			if err := rlp.EncodeString([]byte{}, w, b[:]); err != nil {
				return err
			}
		}
	}
	gidx = 0
	gidx = (32 + 1) * len(obj.l)
	if err := rlp.EncodeStructSizePrefix(gidx, w, b[:]); err != nil {
		return err
	}
	for i := 0; i < len(obj.l); i++ {
		if err := rlp.EncodeString(obj.l[i][:], w, b[:]); err != nil {
			return err
		}
	}
	gidx = 0
	for i := 0; i < len(obj.ll); i++ {
		if obj.ll[i] != nil {
			gidx += 32 + 1
		} else {
			gidx += 1
		}
	}
	if err := rlp.EncodeStructSizePrefix(gidx, w, b[:]); err != nil {
		return err
	}
	for i := 0; i < len(obj.ll); i++ {
		if obj.ll[i] != nil {
			if err := rlp.EncodeString(obj.ll[i][:], w, b[:]); err != nil {
				return err
			}
		} else {
			if err := rlp.EncodeString([]byte{}, w, b[:]); err != nil {
				return err
			}
		}
	}
	if err := rlp.EncodeString(obj.m[:], w, b[:]); err != nil {
		return err
	}
	if obj.mm != nil {
		if err := rlp.EncodeString(obj.mm[:], w, b[:]); err != nil {
			return err
		}
	} else {
		if err := rlp.EncodeString([]byte{}, w, b[:]); err != nil {
			return err
		}
	}
	return nil
}

func (obj *TestingStruct) DecodeRLP(s *rlp.Stream) error {
	_, err := s.List()
	if err != nil {
		return err
	}
	if obj.a, err = s.Uint(); err != nil {
		return fmt.Errorf("error decoding field a, err: %w", err)
	}
	if n, err := s.Uint(); err != nil {
		return fmt.Errorf("error decoding field aa, err: %w", err)
	} else {
		i := n
		obj.aa = &i
	}
	var b []byte
	if b, err = s.Uint256Bytes(); err != nil {
		return fmt.Errorf("error decoding field b, err: %w", err)
	}
	obj.b = *(new(big.Int).SetBytes(b))
	if b, err = s.Uint256Bytes(); err != nil {
		return fmt.Errorf("error decoding field bb, err: %w", err)
	}
	obj.bb = new(big.Int).SetBytes(b)
	if b, err = s.Uint256Bytes(); err != nil {
		return fmt.Errorf("error decoding field c, err: %w", err)
	}
	obj.c = *(new(uint256.Int).SetBytes(b))
	if b, err = s.Uint256Bytes(); err != nil {
		return fmt.Errorf("error decoding field cc, err: %w", err)
	}
	obj.cc = new(uint256.Int).SetBytes(b)
	if b, err = s.Bytes(); err != nil {
		return fmt.Errorf("error decoding field d, err: %w", err)
	}
	if len(b) > 0 && len(b) != 8 {
		return fmt.Errorf("error decoded length mismatch, expected: 8, got: %d", len(b))
	}
	copy(obj.d[:], b)
	if b, err = s.Bytes(); err != nil {
		return fmt.Errorf("error decoding field dd, err: %w", err)
	}
	if len(b) > 0 && len(b) != 8 {
		return fmt.Errorf("error decoded length mismatch, expected: 8, got: %d", len(b))
	}
	obj.dd = &types.BlockNonce{}
	copy((*obj.dd)[:], b)
	if b, err = s.Bytes(); err != nil {
		return fmt.Errorf("error decoding field e, err: %w", err)
	}
	if len(b) > 0 && len(b) != 20 {
		return fmt.Errorf("error decoded length mismatch, expected: 20, got: %d", len(b))
	}
	copy(obj.e[:], b)
	if b, err = s.Bytes(); err != nil {
		return fmt.Errorf("error decoding field ee, err: %w", err)
	}
	if len(b) > 0 && len(b) != 20 {
		return fmt.Errorf("error decoded length mismatch, expected: 20, got: %d", len(b))
	}
	obj.ee = &common.Address{}
	copy((*obj.ee)[:], b)
	if b, err = s.Bytes(); err != nil {
		return fmt.Errorf("error decoding field f, err: %w", err)
	}
	if len(b) > 0 && len(b) != 32 {
		return fmt.Errorf("error decoded length mismatch, expected: 32, got: %d", len(b))
	}
	copy(obj.f[:], b)
	if b, err = s.Bytes(); err != nil {
		return fmt.Errorf("error decoding field ff, err: %w", err)
	}
	if len(b) > 0 && len(b) != 32 {
		return fmt.Errorf("error decoded length mismatch, expected: 32, got: %d", len(b))
	}
	obj.ff = &common.Hash{}
	copy((*obj.ff)[:], b)
	if b, err = s.Bytes(); err != nil {
		return fmt.Errorf("error decoding field g, err: %w", err)
	}
	if len(b) > 0 && len(b) != 256 {
		return fmt.Errorf("error decoded length mismatch, expected: 256, got: %d", len(b))
	}
	copy(obj.g[:], b)
	if b, err = s.Bytes(); err != nil {
		return fmt.Errorf("error decoding field gg, err: %w", err)
	}
	if len(b) > 0 && len(b) != 256 {
		return fmt.Errorf("error decoded length mismatch, expected: 256, got: %d", len(b))
	}
	obj.gg = &types.Bloom{}
	copy((*obj.gg)[:], b)
	if obj.h, err = s.Bytes(); err != nil {
		return fmt.Errorf("error decoding field h, err: %w", err)
	}
	if b, err = s.Bytes(); err != nil {
		return fmt.Errorf("error decoding field hh, err: %w", err)
	}
	obj.hh = &[]byte{}
	*obj.hh = append(*obj.hh, b...)
	_, err = s.List()
	if err != nil {
		return fmt.Errorf("error decoding field i - expected list start, err: %w", err)
	}
	obj.i = [][]byte{}
	for b, err = s.Bytes(); err == nil; b, err = s.Bytes() {
		obj.i = append(obj.i, b)
	}
	if err = s.ListEnd(); err != nil {
		return fmt.Errorf("error decoding field i - fail to close list, err: %w", err)
	}
	_, err = s.List()
	if err != nil {
		return fmt.Errorf("error decoding field j - expected list start, err: %w", err)
	}
	obj.j = []types.BlockNonce{}
	for b, err = s.Bytes(); err == nil; b, err = s.Bytes() {
		if len(b) > 0 && len(b) != 8 {
			return fmt.Errorf("error decoded length mismatch, expected: 8, got: %d", len(b))
		}
		var s types.BlockNonce
		copy(s[:], b)
		obj.j = append(obj.j, s)
	}
	if err = s.ListEnd(); err != nil {
		return fmt.Errorf("error decoding field j - fail to close list, err: %w", err)
	}
	_, err = s.List()
	if err != nil {
		return fmt.Errorf("error decoding field jj - expected list start, err: %w", err)
	}
	obj.jj = []*types.BlockNonce{}
	for b, err = s.Bytes(); err == nil; b, err = s.Bytes() {
		var s types.BlockNonce
		if len(b) > 0 && len(b) != 8 {
			return fmt.Errorf("error decoded length mismatch, expected: 8, got: %d", len(b))
		} else if len(b) == 8 {
			copy(s[:], b)
			obj.jj = append(obj.jj, &s)
		} else if len(b) == 0 {
			obj.jj = append(obj.jj, nil)
		} else {
			return fmt.Errorf("error decoded length mismatch, expected: 8, got: %d", len(b))
		}
	}
	if err = s.ListEnd(); err != nil {
		return fmt.Errorf("error decoding field jj - fail to close list, err: %w", err)
	}
	_, err = s.List()
	if err != nil {
		return fmt.Errorf("error decoding field k - expected list start, err: %w", err)
	}
	obj.k = []common.Address{}
	for b, err = s.Bytes(); err == nil; b, err = s.Bytes() {
		if len(b) > 0 && len(b) != 20 {
			return fmt.Errorf("error decoded length mismatch, expected: 20, got: %d", len(b))
		}
		var s common.Address
		copy(s[:], b)
		obj.k = append(obj.k, s)
	}
	if err = s.ListEnd(); err != nil {
		return fmt.Errorf("error decoding field k - fail to close list, err: %w", err)
	}
	_, err = s.List()
	if err != nil {
		return fmt.Errorf("error decoding field kk - expected list start, err: %w", err)
	}
	obj.kk = []*common.Address{}
	for b, err = s.Bytes(); err == nil; b, err = s.Bytes() {
		var s common.Address
		if len(b) > 0 && len(b) != 20 {
			return fmt.Errorf("error decoded length mismatch, expected: 20, got: %d", len(b))
		} else if len(b) == 20 {
			copy(s[:], b)
			obj.kk = append(obj.kk, &s)
		} else if len(b) == 0 {
			obj.kk = append(obj.kk, nil)
		} else {
			return fmt.Errorf("error decoded length mismatch, expected: 20, got: %d", len(b))
		}
	}
	if err = s.ListEnd(); err != nil {
		return fmt.Errorf("error decoding field kk - fail to close list, err: %w", err)
	}
	_, err = s.List()
	if err != nil {
		return fmt.Errorf("error decoding field l - expected list start, err: %w", err)
	}
	obj.l = []common.Hash{}
	for b, err = s.Bytes(); err == nil; b, err = s.Bytes() {
		if len(b) > 0 && len(b) != 32 {
			return fmt.Errorf("error decoded length mismatch, expected: 32, got: %d", len(b))
		}
		var s common.Hash
		copy(s[:], b)
		obj.l = append(obj.l, s)
	}
	if err = s.ListEnd(); err != nil {
		return fmt.Errorf("error decoding field l - fail to close list, err: %w", err)
	}
	_, err = s.List()
	if err != nil {
		return fmt.Errorf("error decoding field ll - expected list start, err: %w", err)
	}
	obj.ll = []*common.Hash{}
	for b, err = s.Bytes(); err == nil; b, err = s.Bytes() {
		var s common.Hash
		if len(b) > 0 && len(b) != 32 {
			return fmt.Errorf("error decoded length mismatch, expected: 32, got: %d", len(b))
		} else if len(b) == 32 {
			copy(s[:], b)
			obj.ll = append(obj.ll, &s)
		} else if len(b) == 0 {
			obj.ll = append(obj.ll, nil)
		} else {
			return fmt.Errorf("error decoded length mismatch, expected: 32, got: %d", len(b))
		}
	}
	if err = s.ListEnd(); err != nil {
		return fmt.Errorf("error decoding field ll - fail to close list, err: %w", err)
	}
	if b, err = s.Bytes(); err != nil {
		return err
	}
	copy(obj.m[:], b)
	if b, err = s.Bytes(); err != nil {
		return err
	}
	if len(b) > 0 {
		obj.mm = &[245]byte{}
		copy((*obj.mm)[:], b)
	}
	if err = s.ListEnd(); err != nil {
		return fmt.Errorf("error closing TestingStruct, err: %w", err)
	}
	return nil
}
