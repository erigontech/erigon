// Code generated by fastssz. DO NOT EDIT.
// Hash: 28b1e62415deafa7584ed23ba96be99fb2b0d9d454524470355c38c4dea80f7f
// Version: 0.1.2
package cltypes

import (
	ssz "github.com/ferranbt/fastssz"
)

// MarshalSSZ ssz marshals the Eth1Data object
func (e *Eth1Data) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(e)
}

// MarshalSSZTo ssz marshals the Eth1Data object to a target array
func (e *Eth1Data) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'Root'
	dst = append(dst, e.Root[:]...)

	// Field (1) 'DepositCount'
	dst = ssz.MarshalUint64(dst, e.DepositCount)

	// Field (2) 'BlockHash'
	dst = append(dst, e.BlockHash[:]...)

	return
}

// UnmarshalSSZ ssz unmarshals the Eth1Data object
func (e *Eth1Data) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size != 72 {
		return ssz.ErrSize
	}

	// Field (0) 'Root'
	copy(e.Root[:], buf[0:32])

	// Field (1) 'DepositCount'
	e.DepositCount = ssz.UnmarshallUint64(buf[32:40])

	// Field (2) 'BlockHash'
	copy(e.BlockHash[:], buf[40:72])

	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the Eth1Data object
func (e *Eth1Data) SizeSSZ() (size int) {
	size = 72
	return
}

// HashTreeRoot ssz hashes the Eth1Data object
func (e *Eth1Data) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(e)
}

// HashTreeRootWith ssz hashes the Eth1Data object with a hasher
func (e *Eth1Data) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Root'
	hh.PutBytes(e.Root[:])

	// Field (1) 'DepositCount'
	hh.PutUint64(e.DepositCount)

	// Field (2) 'BlockHash'
	hh.PutBytes(e.BlockHash[:])

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the Eth1Data object
func (e *Eth1Data) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(e)
}

// MarshalSSZ ssz marshals the AttestationData object
func (a *AttestationData) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(a)
}

// MarshalSSZTo ssz marshals the AttestationData object to a target array
func (a *AttestationData) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'Slot'
	dst = ssz.MarshalUint64(dst, a.Slot)

	// Field (1) 'Index'
	dst = ssz.MarshalUint64(dst, a.Index)

	// Field (2) 'BeaconBlockHash'
	dst = append(dst, a.BeaconBlockHash[:]...)

	return
}

// UnmarshalSSZ ssz unmarshals the AttestationData object
func (a *AttestationData) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size != 48 {
		return ssz.ErrSize
	}

	// Field (0) 'Slot'
	a.Slot = ssz.UnmarshallUint64(buf[0:8])

	// Field (1) 'Index'
	a.Index = ssz.UnmarshallUint64(buf[8:16])

	// Field (2) 'BeaconBlockHash'
	copy(a.BeaconBlockHash[:], buf[16:48])

	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the AttestationData object
func (a *AttestationData) SizeSSZ() (size int) {
	size = 48
	return
}

// HashTreeRoot ssz hashes the AttestationData object
func (a *AttestationData) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(a)
}

// HashTreeRootWith ssz hashes the AttestationData object with a hasher
func (a *AttestationData) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Slot'
	hh.PutUint64(a.Slot)

	// Field (1) 'Index'
	hh.PutUint64(a.Index)

	// Field (2) 'BeaconBlockHash'
	hh.PutBytes(a.BeaconBlockHash[:])

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the AttestationData object
func (a *AttestationData) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(a)
}

// MarshalSSZ ssz marshals the BeaconBlockHeader object
func (b *BeaconBlockHeader) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(b)
}

// MarshalSSZTo ssz marshals the BeaconBlockHeader object to a target array
func (b *BeaconBlockHeader) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'Slot'
	dst = ssz.MarshalUint64(dst, b.Slot)

	// Field (1) 'ProposerIndex'
	dst = ssz.MarshalUint64(dst, b.ProposerIndex)

	// Field (2) 'ParentRoot'
	dst = append(dst, b.ParentRoot[:]...)

	// Field (3) 'Root'
	dst = append(dst, b.Root[:]...)

	// Field (4) 'BodyRoot'
	dst = append(dst, b.BodyRoot[:]...)

	return
}

// UnmarshalSSZ ssz unmarshals the BeaconBlockHeader object
func (b *BeaconBlockHeader) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size != 112 {
		return ssz.ErrSize
	}

	// Field (0) 'Slot'
	b.Slot = ssz.UnmarshallUint64(buf[0:8])

	// Field (1) 'ProposerIndex'
	b.ProposerIndex = ssz.UnmarshallUint64(buf[8:16])

	// Field (2) 'ParentRoot'
	copy(b.ParentRoot[:], buf[16:48])

	// Field (3) 'Root'
	copy(b.Root[:], buf[48:80])

	// Field (4) 'BodyRoot'
	copy(b.BodyRoot[:], buf[80:112])

	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the BeaconBlockHeader object
func (b *BeaconBlockHeader) SizeSSZ() (size int) {
	size = 112
	return
}

// HashTreeRoot ssz hashes the BeaconBlockHeader object
func (b *BeaconBlockHeader) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(b)
}

// HashTreeRootWith ssz hashes the BeaconBlockHeader object with a hasher
func (b *BeaconBlockHeader) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Slot'
	hh.PutUint64(b.Slot)

	// Field (1) 'ProposerIndex'
	hh.PutUint64(b.ProposerIndex)

	// Field (2) 'ParentRoot'
	hh.PutBytes(b.ParentRoot[:])

	// Field (3) 'Root'
	hh.PutBytes(b.Root[:])

	// Field (4) 'BodyRoot'
	hh.PutBytes(b.BodyRoot[:])

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the BeaconBlockHeader object
func (b *BeaconBlockHeader) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(b)
}

// MarshalSSZ ssz marshals the SignedBeaconBlockHeader object
func (s *SignedBeaconBlockHeader) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(s)
}

// MarshalSSZTo ssz marshals the SignedBeaconBlockHeader object to a target array
func (s *SignedBeaconBlockHeader) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'Header'
	if s.Header == nil {
		s.Header = new(BeaconBlockHeader)
	}
	if dst, err = s.Header.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (1) 'Signature'
	dst = append(dst, s.Signature[:]...)

	return
}

// UnmarshalSSZ ssz unmarshals the SignedBeaconBlockHeader object
func (s *SignedBeaconBlockHeader) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size != 208 {
		return ssz.ErrSize
	}

	// Field (0) 'Header'
	if s.Header == nil {
		s.Header = new(BeaconBlockHeader)
	}
	if err = s.Header.UnmarshalSSZ(buf[0:112]); err != nil {
		return err
	}

	// Field (1) 'Signature'
	copy(s.Signature[:], buf[112:208])

	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the SignedBeaconBlockHeader object
func (s *SignedBeaconBlockHeader) SizeSSZ() (size int) {
	size = 208
	return
}

// HashTreeRoot ssz hashes the SignedBeaconBlockHeader object
func (s *SignedBeaconBlockHeader) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(s)
}

// HashTreeRootWith ssz hashes the SignedBeaconBlockHeader object with a hasher
func (s *SignedBeaconBlockHeader) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Header'
	if s.Header == nil {
		s.Header = new(BeaconBlockHeader)
	}
	if err = s.Header.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (1) 'Signature'
	hh.PutBytes(s.Signature[:])

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the SignedBeaconBlockHeader object
func (s *SignedBeaconBlockHeader) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(s)
}

// MarshalSSZ ssz marshals the Slashing object
func (s *Slashing) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(s)
}

// MarshalSSZTo ssz marshals the Slashing object to a target array
func (s *Slashing) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'Header1'
	if s.Header1 == nil {
		s.Header1 = new(SignedBeaconBlockHeader)
	}
	if dst, err = s.Header1.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (1) 'Header2'
	if s.Header2 == nil {
		s.Header2 = new(SignedBeaconBlockHeader)
	}
	if dst, err = s.Header2.MarshalSSZTo(dst); err != nil {
		return
	}

	return
}

// UnmarshalSSZ ssz unmarshals the Slashing object
func (s *Slashing) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size != 416 {
		return ssz.ErrSize
	}

	// Field (0) 'Header1'
	if s.Header1 == nil {
		s.Header1 = new(SignedBeaconBlockHeader)
	}
	if err = s.Header1.UnmarshalSSZ(buf[0:208]); err != nil {
		return err
	}

	// Field (1) 'Header2'
	if s.Header2 == nil {
		s.Header2 = new(SignedBeaconBlockHeader)
	}
	if err = s.Header2.UnmarshalSSZ(buf[208:416]); err != nil {
		return err
	}

	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the Slashing object
func (s *Slashing) SizeSSZ() (size int) {
	size = 416
	return
}

// HashTreeRoot ssz hashes the Slashing object
func (s *Slashing) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(s)
}

// HashTreeRootWith ssz hashes the Slashing object with a hasher
func (s *Slashing) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Header1'
	if s.Header1 == nil {
		s.Header1 = new(SignedBeaconBlockHeader)
	}
	if err = s.Header1.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (1) 'Header2'
	if s.Header2 == nil {
		s.Header2 = new(SignedBeaconBlockHeader)
	}
	if err = s.Header2.HashTreeRootWith(hh); err != nil {
		return
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the Slashing object
func (s *Slashing) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(s)
}

// MarshalSSZ ssz marshals the Attestation object
func (a *Attestation) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(a)
}

// MarshalSSZTo ssz marshals the Attestation object to a target array
func (a *Attestation) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(148)

	// Offset (0) 'AggregationBits'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(a.AggregationBits)

	// Field (1) 'Data'
	if a.Data == nil {
		a.Data = new(AttestationData)
	}
	if dst, err = a.Data.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (2) 'Signature'
	dst = append(dst, a.Signature[:]...)

	// Field (0) 'AggregationBits'
	if size := len(a.AggregationBits); size > 2048 {
		err = ssz.ErrBytesLengthFn("Attestation.AggregationBits", size, 2048)
		return
	}
	dst = append(dst, a.AggregationBits...)

	return
}

// UnmarshalSSZ ssz unmarshals the Attestation object
func (a *Attestation) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 148 {
		return ssz.ErrSize
	}

	tail := buf
	var o0 uint64

	// Offset (0) 'AggregationBits'
	if o0 = ssz.ReadOffset(buf[0:4]); o0 > size {
		return ssz.ErrOffset
	}

	if o0 < 148 {
		return ssz.ErrInvalidVariableOffset
	}

	// Field (1) 'Data'
	if a.Data == nil {
		a.Data = new(AttestationData)
	}
	if err = a.Data.UnmarshalSSZ(buf[4:52]); err != nil {
		return err
	}

	// Field (2) 'Signature'
	copy(a.Signature[:], buf[52:148])

	// Field (0) 'AggregationBits'
	{
		buf = tail[o0:]
		if err = ssz.ValidateBitlist(buf, 2048); err != nil {
			return err
		}
		if cap(a.AggregationBits) == 0 {
			a.AggregationBits = make([]byte, 0, len(buf))
		}
		a.AggregationBits = append(a.AggregationBits, buf...)
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the Attestation object
func (a *Attestation) SizeSSZ() (size int) {
	size = 148

	// Field (0) 'AggregationBits'
	size += len(a.AggregationBits)

	return
}

// HashTreeRoot ssz hashes the Attestation object
func (a *Attestation) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(a)
}

// HashTreeRootWith ssz hashes the Attestation object with a hasher
func (a *Attestation) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'AggregationBits'
	if len(a.AggregationBits) == 0 {
		err = ssz.ErrEmptyBitlist
		return
	}
	hh.PutBitlist(a.AggregationBits, 2048)

	// Field (1) 'Data'
	if a.Data == nil {
		a.Data = new(AttestationData)
	}
	if err = a.Data.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (2) 'Signature'
	hh.PutBytes(a.Signature[:])

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the Attestation object
func (a *Attestation) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(a)
}

// MarshalSSZ ssz marshals the DepositData object
func (d *DepositData) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(d)
}

// MarshalSSZTo ssz marshals the DepositData object to a target array
func (d *DepositData) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'PubKey'
	dst = append(dst, d.PubKey[:]...)

	// Field (1) 'WithdrawalCredentials'
	if size := len(d.WithdrawalCredentials); size != 32 {
		err = ssz.ErrBytesLengthFn("DepositData.WithdrawalCredentials", size, 32)
		return
	}
	dst = append(dst, d.WithdrawalCredentials...)

	// Field (2) 'Amount'
	dst = ssz.MarshalUint64(dst, d.Amount)

	// Field (3) 'Signature'
	dst = append(dst, d.Signature[:]...)

	return
}

// UnmarshalSSZ ssz unmarshals the DepositData object
func (d *DepositData) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size != 184 {
		return ssz.ErrSize
	}

	// Field (0) 'PubKey'
	copy(d.PubKey[:], buf[0:48])

	// Field (1) 'WithdrawalCredentials'
	if cap(d.WithdrawalCredentials) == 0 {
		d.WithdrawalCredentials = make([]byte, 0, len(buf[48:80]))
	}
	d.WithdrawalCredentials = append(d.WithdrawalCredentials, buf[48:80]...)

	// Field (2) 'Amount'
	d.Amount = ssz.UnmarshallUint64(buf[80:88])

	// Field (3) 'Signature'
	copy(d.Signature[:], buf[88:184])

	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the DepositData object
func (d *DepositData) SizeSSZ() (size int) {
	size = 184
	return
}

// HashTreeRoot ssz hashes the DepositData object
func (d *DepositData) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(d)
}

// HashTreeRootWith ssz hashes the DepositData object with a hasher
func (d *DepositData) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'PubKey'
	hh.PutBytes(d.PubKey[:])

	// Field (1) 'WithdrawalCredentials'
	if size := len(d.WithdrawalCredentials); size != 32 {
		err = ssz.ErrBytesLengthFn("DepositData.WithdrawalCredentials", size, 32)
		return
	}
	hh.PutBytes(d.WithdrawalCredentials)

	// Field (2) 'Amount'
	hh.PutUint64(d.Amount)

	// Field (3) 'Signature'
	hh.PutBytes(d.Signature[:])

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the DepositData object
func (d *DepositData) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(d)
}

// MarshalSSZ ssz marshals the Deposit object
func (d *Deposit) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(d)
}

// MarshalSSZTo ssz marshals the Deposit object to a target array
func (d *Deposit) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'Proof'
	if size := len(d.Proof); size != 33 {
		err = ssz.ErrVectorLengthFn("Deposit.Proof", size, 33)
		return
	}
	for ii := 0; ii < 33; ii++ {
		if size := len(d.Proof[ii]); size != 32 {
			err = ssz.ErrBytesLengthFn("Deposit.Proof[ii]", size, 32)
			return
		}
		dst = append(dst, d.Proof[ii]...)
	}

	// Field (1) 'Data'
	if d.Data == nil {
		d.Data = new(DepositData)
	}
	if dst, err = d.Data.MarshalSSZTo(dst); err != nil {
		return
	}

	return
}

// UnmarshalSSZ ssz unmarshals the Deposit object
func (d *Deposit) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size != 1240 {
		return ssz.ErrSize
	}

	// Field (0) 'Proof'
	d.Proof = make([][]byte, 33)
	for ii := 0; ii < 33; ii++ {
		if cap(d.Proof[ii]) == 0 {
			d.Proof[ii] = make([]byte, 0, len(buf[0:1056][ii*32:(ii+1)*32]))
		}
		d.Proof[ii] = append(d.Proof[ii], buf[0:1056][ii*32:(ii+1)*32]...)
	}

	// Field (1) 'Data'
	if d.Data == nil {
		d.Data = new(DepositData)
	}
	if err = d.Data.UnmarshalSSZ(buf[1056:1240]); err != nil {
		return err
	}

	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the Deposit object
func (d *Deposit) SizeSSZ() (size int) {
	size = 1240
	return
}

// HashTreeRoot ssz hashes the Deposit object
func (d *Deposit) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(d)
}

// HashTreeRootWith ssz hashes the Deposit object with a hasher
func (d *Deposit) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Proof'
	{
		if size := len(d.Proof); size != 33 {
			err = ssz.ErrVectorLengthFn("Deposit.Proof", size, 33)
			return
		}
		subIndx := hh.Index()
		for _, i := range d.Proof {
			if len(i) != 32 {
				err = ssz.ErrBytesLength
				return
			}
			hh.Append(i)
		}
		hh.Merkleize(subIndx)
	}

	// Field (1) 'Data'
	if d.Data == nil {
		d.Data = new(DepositData)
	}
	if err = d.Data.HashTreeRootWith(hh); err != nil {
		return
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the Deposit object
func (d *Deposit) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(d)
}

// MarshalSSZ ssz marshals the VoluntaryExit object
func (v *VoluntaryExit) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(v)
}

// MarshalSSZTo ssz marshals the VoluntaryExit object to a target array
func (v *VoluntaryExit) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'Epoch'
	dst = ssz.MarshalUint64(dst, v.Epoch)

	// Field (1) 'ValidatorIndex'
	dst = ssz.MarshalUint64(dst, v.ValidatorIndex)

	return
}

// UnmarshalSSZ ssz unmarshals the VoluntaryExit object
func (v *VoluntaryExit) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size != 16 {
		return ssz.ErrSize
	}

	// Field (0) 'Epoch'
	v.Epoch = ssz.UnmarshallUint64(buf[0:8])

	// Field (1) 'ValidatorIndex'
	v.ValidatorIndex = ssz.UnmarshallUint64(buf[8:16])

	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the VoluntaryExit object
func (v *VoluntaryExit) SizeSSZ() (size int) {
	size = 16
	return
}

// HashTreeRoot ssz hashes the VoluntaryExit object
func (v *VoluntaryExit) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(v)
}

// HashTreeRootWith ssz hashes the VoluntaryExit object with a hasher
func (v *VoluntaryExit) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Epoch'
	hh.PutUint64(v.Epoch)

	// Field (1) 'ValidatorIndex'
	hh.PutUint64(v.ValidatorIndex)

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the VoluntaryExit object
func (v *VoluntaryExit) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(v)
}

// MarshalSSZ ssz marshals the SignedVoluntaryExit object
func (s *SignedVoluntaryExit) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(s)
}

// MarshalSSZTo ssz marshals the SignedVoluntaryExit object to a target array
func (s *SignedVoluntaryExit) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'VolunaryExit'
	if s.VolunaryExit == nil {
		s.VolunaryExit = new(VoluntaryExit)
	}
	if dst, err = s.VolunaryExit.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (1) 'Signature'
	dst = append(dst, s.Signature[:]...)

	return
}

// UnmarshalSSZ ssz unmarshals the SignedVoluntaryExit object
func (s *SignedVoluntaryExit) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size != 112 {
		return ssz.ErrSize
	}

	// Field (0) 'VolunaryExit'
	if s.VolunaryExit == nil {
		s.VolunaryExit = new(VoluntaryExit)
	}
	if err = s.VolunaryExit.UnmarshalSSZ(buf[0:16]); err != nil {
		return err
	}

	// Field (1) 'Signature'
	copy(s.Signature[:], buf[16:112])

	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the SignedVoluntaryExit object
func (s *SignedVoluntaryExit) SizeSSZ() (size int) {
	size = 112
	return
}

// HashTreeRoot ssz hashes the SignedVoluntaryExit object
func (s *SignedVoluntaryExit) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(s)
}

// HashTreeRootWith ssz hashes the SignedVoluntaryExit object with a hasher
func (s *SignedVoluntaryExit) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'VolunaryExit'
	if s.VolunaryExit == nil {
		s.VolunaryExit = new(VoluntaryExit)
	}
	if err = s.VolunaryExit.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (1) 'Signature'
	hh.PutBytes(s.Signature[:])

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the SignedVoluntaryExit object
func (s *SignedVoluntaryExit) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(s)
}

// MarshalSSZ ssz marshals the SyncAggregate object
func (s *SyncAggregate) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(s)
}

// MarshalSSZTo ssz marshals the SyncAggregate object to a target array
func (s *SyncAggregate) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'SyncCommiteeBits'
	if size := len(s.SyncCommiteeBits); size != 64 {
		err = ssz.ErrBytesLengthFn("SyncAggregate.SyncCommiteeBits", size, 64)
		return
	}
	dst = append(dst, s.SyncCommiteeBits...)

	// Field (1) 'SyncCommiteeSignature'
	dst = append(dst, s.SyncCommiteeSignature[:]...)

	return
}

// UnmarshalSSZ ssz unmarshals the SyncAggregate object
func (s *SyncAggregate) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size != 160 {
		return ssz.ErrSize
	}

	// Field (0) 'SyncCommiteeBits'
	if cap(s.SyncCommiteeBits) == 0 {
		s.SyncCommiteeBits = make([]byte, 0, len(buf[0:64]))
	}
	s.SyncCommiteeBits = append(s.SyncCommiteeBits, buf[0:64]...)

	// Field (1) 'SyncCommiteeSignature'
	copy(s.SyncCommiteeSignature[:], buf[64:160])

	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the SyncAggregate object
func (s *SyncAggregate) SizeSSZ() (size int) {
	size = 160
	return
}

// HashTreeRoot ssz hashes the SyncAggregate object
func (s *SyncAggregate) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(s)
}

// HashTreeRootWith ssz hashes the SyncAggregate object with a hasher
func (s *SyncAggregate) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'SyncCommiteeBits'
	if size := len(s.SyncCommiteeBits); size != 64 {
		err = ssz.ErrBytesLengthFn("SyncAggregate.SyncCommiteeBits", size, 64)
		return
	}
	hh.PutBytes(s.SyncCommiteeBits)

	// Field (1) 'SyncCommiteeSignature'
	hh.PutBytes(s.SyncCommiteeSignature[:])

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the SyncAggregate object
func (s *SyncAggregate) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(s)
}

// MarshalSSZ ssz marshals the ExecutionPayload object
func (e *ExecutionPayload) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(e)
}

// MarshalSSZTo ssz marshals the ExecutionPayload object to a target array
func (e *ExecutionPayload) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(508)

	// Field (0) 'ParentHash'
	dst = append(dst, e.ParentHash[:]...)

	// Field (1) 'FeeRecipient'
	dst = append(dst, e.FeeRecipient[:]...)

	// Field (2) 'StateRoot'
	dst = append(dst, e.StateRoot[:]...)

	// Field (3) 'ReceiptsRoot'
	dst = append(dst, e.ReceiptsRoot[:]...)

	// Field (4) 'LogsBloom'
	if size := len(e.LogsBloom); size != 256 {
		err = ssz.ErrBytesLengthFn("ExecutionPayload.LogsBloom", size, 256)
		return
	}
	dst = append(dst, e.LogsBloom...)

	// Field (5) 'PrevRandao'
	dst = append(dst, e.PrevRandao[:]...)

	// Field (6) 'BlockNumber'
	dst = ssz.MarshalUint64(dst, e.BlockNumber)

	// Field (7) 'GasLimit'
	dst = ssz.MarshalUint64(dst, e.GasLimit)

	// Field (8) 'GasUsed'
	dst = ssz.MarshalUint64(dst, e.GasUsed)

	// Field (9) 'Timestamp'
	dst = ssz.MarshalUint64(dst, e.Timestamp)

	// Offset (10) 'ExtraData'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(e.ExtraData)

	// Field (11) 'BaseFeePerGas'
	if size := len(e.BaseFeePerGas); size != 32 {
		err = ssz.ErrBytesLengthFn("ExecutionPayload.BaseFeePerGas", size, 32)
		return
	}
	dst = append(dst, e.BaseFeePerGas...)

	// Field (12) 'BlockHash'
	dst = append(dst, e.BlockHash[:]...)

	// Offset (13) 'Transactions'
	dst = ssz.WriteOffset(dst, offset)
	for ii := 0; ii < len(e.Transactions); ii++ {
		offset += 4
		offset += len(e.Transactions[ii])
	}

	// Field (10) 'ExtraData'
	if size := len(e.ExtraData); size > 32 {
		err = ssz.ErrBytesLengthFn("ExecutionPayload.ExtraData", size, 32)
		return
	}
	dst = append(dst, e.ExtraData...)

	// Field (13) 'Transactions'
	if size := len(e.Transactions); size > 1048576 {
		err = ssz.ErrListTooBigFn("ExecutionPayload.Transactions", size, 1048576)
		return
	}
	{
		offset = 4 * len(e.Transactions)
		for ii := 0; ii < len(e.Transactions); ii++ {
			dst = ssz.WriteOffset(dst, offset)
			offset += len(e.Transactions[ii])
		}
	}
	for ii := 0; ii < len(e.Transactions); ii++ {
		if size := len(e.Transactions[ii]); size > 1073741824 {
			err = ssz.ErrBytesLengthFn("ExecutionPayload.Transactions[ii]", size, 1073741824)
			return
		}
		dst = append(dst, e.Transactions[ii]...)
	}

	return
}

// UnmarshalSSZ ssz unmarshals the ExecutionPayload object
func (e *ExecutionPayload) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 508 {
		return ssz.ErrSize
	}

	tail := buf
	var o10, o13 uint64

	// Field (0) 'ParentHash'
	copy(e.ParentHash[:], buf[0:32])

	// Field (1) 'FeeRecipient'
	copy(e.FeeRecipient[:], buf[32:52])

	// Field (2) 'StateRoot'
	copy(e.StateRoot[:], buf[52:84])

	// Field (3) 'ReceiptsRoot'
	copy(e.ReceiptsRoot[:], buf[84:116])

	// Field (4) 'LogsBloom'
	if cap(e.LogsBloom) == 0 {
		e.LogsBloom = make([]byte, 0, len(buf[116:372]))
	}
	e.LogsBloom = append(e.LogsBloom, buf[116:372]...)

	// Field (5) 'PrevRandao'
	copy(e.PrevRandao[:], buf[372:404])

	// Field (6) 'BlockNumber'
	e.BlockNumber = ssz.UnmarshallUint64(buf[404:412])

	// Field (7) 'GasLimit'
	e.GasLimit = ssz.UnmarshallUint64(buf[412:420])

	// Field (8) 'GasUsed'
	e.GasUsed = ssz.UnmarshallUint64(buf[420:428])

	// Field (9) 'Timestamp'
	e.Timestamp = ssz.UnmarshallUint64(buf[428:436])

	// Offset (10) 'ExtraData'
	if o10 = ssz.ReadOffset(buf[436:440]); o10 > size {
		return ssz.ErrOffset
	}

	if o10 < 508 {
		return ssz.ErrInvalidVariableOffset
	}

	// Field (11) 'BaseFeePerGas'
	if cap(e.BaseFeePerGas) == 0 {
		e.BaseFeePerGas = make([]byte, 0, len(buf[440:472]))
	}
	e.BaseFeePerGas = append(e.BaseFeePerGas, buf[440:472]...)

	// Field (12) 'BlockHash'
	copy(e.BlockHash[:], buf[472:504])

	// Offset (13) 'Transactions'
	if o13 = ssz.ReadOffset(buf[504:508]); o13 > size || o10 > o13 {
		return ssz.ErrOffset
	}

	// Field (10) 'ExtraData'
	{
		buf = tail[o10:o13]
		if len(buf) > 32 {
			return ssz.ErrBytesLength
		}
		if cap(e.ExtraData) == 0 {
			e.ExtraData = make([]byte, 0, len(buf))
		}
		e.ExtraData = append(e.ExtraData, buf...)
	}

	// Field (13) 'Transactions'
	{
		buf = tail[o13:]
		num, err := ssz.DecodeDynamicLength(buf, 1048576)
		if err != nil {
			return err
		}
		e.Transactions = make([][]byte, num)
		err = ssz.UnmarshalDynamic(buf, num, func(indx int, buf []byte) (err error) {
			if len(buf) > 1073741824 {
				return ssz.ErrBytesLength
			}
			if cap(e.Transactions[indx]) == 0 {
				e.Transactions[indx] = make([]byte, 0, len(buf))
			}
			e.Transactions[indx] = append(e.Transactions[indx], buf...)
			return nil
		})
		if err != nil {
			return err
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the ExecutionPayload object
func (e *ExecutionPayload) SizeSSZ() (size int) {
	size = 508

	// Field (10) 'ExtraData'
	size += len(e.ExtraData)

	// Field (13) 'Transactions'
	for ii := 0; ii < len(e.Transactions); ii++ {
		size += 4
		size += len(e.Transactions[ii])
	}

	return
}

// HashTreeRoot ssz hashes the ExecutionPayload object
func (e *ExecutionPayload) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(e)
}

// HashTreeRootWith ssz hashes the ExecutionPayload object with a hasher
func (e *ExecutionPayload) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'ParentHash'
	hh.PutBytes(e.ParentHash[:])

	// Field (1) 'FeeRecipient'
	hh.PutBytes(e.FeeRecipient[:])

	// Field (2) 'StateRoot'
	hh.PutBytes(e.StateRoot[:])

	// Field (3) 'ReceiptsRoot'
	hh.PutBytes(e.ReceiptsRoot[:])

	// Field (4) 'LogsBloom'
	if size := len(e.LogsBloom); size != 256 {
		err = ssz.ErrBytesLengthFn("ExecutionPayload.LogsBloom", size, 256)
		return
	}
	hh.PutBytes(e.LogsBloom)

	// Field (5) 'PrevRandao'
	hh.PutBytes(e.PrevRandao[:])

	// Field (6) 'BlockNumber'
	hh.PutUint64(e.BlockNumber)

	// Field (7) 'GasLimit'
	hh.PutUint64(e.GasLimit)

	// Field (8) 'GasUsed'
	hh.PutUint64(e.GasUsed)

	// Field (9) 'Timestamp'
	hh.PutUint64(e.Timestamp)

	// Field (10) 'ExtraData'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(e.ExtraData))
		if byteLen > 32 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.PutBytes(e.ExtraData)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (32+31)/32)
	}

	// Field (11) 'BaseFeePerGas'
	if size := len(e.BaseFeePerGas); size != 32 {
		err = ssz.ErrBytesLengthFn("ExecutionPayload.BaseFeePerGas", size, 32)
		return
	}
	hh.PutBytes(e.BaseFeePerGas)

	// Field (12) 'BlockHash'
	hh.PutBytes(e.BlockHash[:])

	// Field (13) 'Transactions'
	{
		subIndx := hh.Index()
		num := uint64(len(e.Transactions))
		if num > 1048576 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range e.Transactions {
			{
				elemIndx := hh.Index()
				byteLen := uint64(len(elem))
				if byteLen > 1073741824 {
					err = ssz.ErrIncorrectListSize
					return
				}
				hh.AppendBytes32(elem)
				hh.MerkleizeWithMixin(elemIndx, byteLen, (1073741824+31)/32)
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 1048576)
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the ExecutionPayload object
func (e *ExecutionPayload) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(e)
}

// MarshalSSZ ssz marshals the BeaconBodyBellatrix object
func (b *BeaconBodyBellatrix) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(b)
}

// MarshalSSZTo ssz marshals the BeaconBodyBellatrix object to a target array
func (b *BeaconBodyBellatrix) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(384)

	// Field (0) 'RandaoReveal'
	dst = append(dst, b.RandaoReveal[:]...)

	// Field (1) 'Eth1Data'
	if b.Eth1Data == nil {
		b.Eth1Data = new(Eth1Data)
	}
	if dst, err = b.Eth1Data.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (2) 'Graffiti'
	if size := len(b.Graffiti); size != 32 {
		err = ssz.ErrBytesLengthFn("BeaconBodyBellatrix.Graffiti", size, 32)
		return
	}
	dst = append(dst, b.Graffiti...)

	// Offset (3) 'ProposerSlashings'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(b.ProposerSlashings) * 416

	// Offset (4) 'AttesterSlashings'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(b.AttesterSlashings) * 416

	// Offset (5) 'Attestations'
	dst = ssz.WriteOffset(dst, offset)
	for ii := 0; ii < len(b.Attestations); ii++ {
		offset += 4
		offset += b.Attestations[ii].SizeSSZ()
	}

	// Offset (6) 'Deposits'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(b.Deposits) * 1240

	// Offset (7) 'VoluntaryExits'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(b.VoluntaryExits) * 112

	// Field (8) 'SyncAggregate'
	if b.SyncAggregate == nil {
		b.SyncAggregate = new(SyncAggregate)
	}
	if dst, err = b.SyncAggregate.MarshalSSZTo(dst); err != nil {
		return
	}

	// Offset (9) 'ExecutionPayload'
	dst = ssz.WriteOffset(dst, offset)
	if b.ExecutionPayload == nil {
		b.ExecutionPayload = new(ExecutionPayload)
	}
	offset += b.ExecutionPayload.SizeSSZ()

	// Field (3) 'ProposerSlashings'
	if size := len(b.ProposerSlashings); size > 16 {
		err = ssz.ErrListTooBigFn("BeaconBodyBellatrix.ProposerSlashings", size, 16)
		return
	}
	for ii := 0; ii < len(b.ProposerSlashings); ii++ {
		if dst, err = b.ProposerSlashings[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	// Field (4) 'AttesterSlashings'
	if size := len(b.AttesterSlashings); size > 2 {
		err = ssz.ErrListTooBigFn("BeaconBodyBellatrix.AttesterSlashings", size, 2)
		return
	}
	for ii := 0; ii < len(b.AttesterSlashings); ii++ {
		if dst, err = b.AttesterSlashings[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	// Field (5) 'Attestations'
	if size := len(b.Attestations); size > 128 {
		err = ssz.ErrListTooBigFn("BeaconBodyBellatrix.Attestations", size, 128)
		return
	}
	{
		offset = 4 * len(b.Attestations)
		for ii := 0; ii < len(b.Attestations); ii++ {
			dst = ssz.WriteOffset(dst, offset)
			offset += b.Attestations[ii].SizeSSZ()
		}
	}
	for ii := 0; ii < len(b.Attestations); ii++ {
		if dst, err = b.Attestations[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	// Field (6) 'Deposits'
	if size := len(b.Deposits); size > 16 {
		err = ssz.ErrListTooBigFn("BeaconBodyBellatrix.Deposits", size, 16)
		return
	}
	for ii := 0; ii < len(b.Deposits); ii++ {
		if dst, err = b.Deposits[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	// Field (7) 'VoluntaryExits'
	if size := len(b.VoluntaryExits); size > 16 {
		err = ssz.ErrListTooBigFn("BeaconBodyBellatrix.VoluntaryExits", size, 16)
		return
	}
	for ii := 0; ii < len(b.VoluntaryExits); ii++ {
		if dst, err = b.VoluntaryExits[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	// Field (9) 'ExecutionPayload'
	if dst, err = b.ExecutionPayload.MarshalSSZTo(dst); err != nil {
		return
	}

	return
}

// UnmarshalSSZ ssz unmarshals the BeaconBodyBellatrix object
func (b *BeaconBodyBellatrix) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 384 {
		return ssz.ErrSize
	}

	tail := buf
	var o3, o4, o5, o6, o7, o9 uint64

	// Field (0) 'RandaoReveal'
	copy(b.RandaoReveal[:], buf[0:96])

	// Field (1) 'Eth1Data'
	if b.Eth1Data == nil {
		b.Eth1Data = new(Eth1Data)
	}
	if err = b.Eth1Data.UnmarshalSSZ(buf[96:168]); err != nil {
		return err
	}

	// Field (2) 'Graffiti'
	if cap(b.Graffiti) == 0 {
		b.Graffiti = make([]byte, 0, len(buf[168:200]))
	}
	b.Graffiti = append(b.Graffiti, buf[168:200]...)

	// Offset (3) 'ProposerSlashings'
	if o3 = ssz.ReadOffset(buf[200:204]); o3 > size {
		return ssz.ErrOffset
	}

	if o3 < 384 {
		return ssz.ErrInvalidVariableOffset
	}

	// Offset (4) 'AttesterSlashings'
	if o4 = ssz.ReadOffset(buf[204:208]); o4 > size || o3 > o4 {
		return ssz.ErrOffset
	}

	// Offset (5) 'Attestations'
	if o5 = ssz.ReadOffset(buf[208:212]); o5 > size || o4 > o5 {
		return ssz.ErrOffset
	}

	// Offset (6) 'Deposits'
	if o6 = ssz.ReadOffset(buf[212:216]); o6 > size || o5 > o6 {
		return ssz.ErrOffset
	}

	// Offset (7) 'VoluntaryExits'
	if o7 = ssz.ReadOffset(buf[216:220]); o7 > size || o6 > o7 {
		return ssz.ErrOffset
	}

	// Field (8) 'SyncAggregate'
	if b.SyncAggregate == nil {
		b.SyncAggregate = new(SyncAggregate)
	}
	if err = b.SyncAggregate.UnmarshalSSZ(buf[220:380]); err != nil {
		return err
	}

	// Offset (9) 'ExecutionPayload'
	if o9 = ssz.ReadOffset(buf[380:384]); o9 > size || o7 > o9 {
		return ssz.ErrOffset
	}

	// Field (3) 'ProposerSlashings'
	{
		buf = tail[o3:o4]
		num, err := ssz.DivideInt2(len(buf), 416, 16)
		if err != nil {
			return err
		}
		b.ProposerSlashings = make([]*Slashing, num)
		for ii := 0; ii < num; ii++ {
			if b.ProposerSlashings[ii] == nil {
				b.ProposerSlashings[ii] = new(Slashing)
			}
			if err = b.ProposerSlashings[ii].UnmarshalSSZ(buf[ii*416 : (ii+1)*416]); err != nil {
				return err
			}
		}
	}

	// Field (4) 'AttesterSlashings'
	{
		buf = tail[o4:o5]
		num, err := ssz.DivideInt2(len(buf), 416, 2)
		if err != nil {
			return err
		}
		b.AttesterSlashings = make([]*Slashing, num)
		for ii := 0; ii < num; ii++ {
			if b.AttesterSlashings[ii] == nil {
				b.AttesterSlashings[ii] = new(Slashing)
			}
			if err = b.AttesterSlashings[ii].UnmarshalSSZ(buf[ii*416 : (ii+1)*416]); err != nil {
				return err
			}
		}
	}

	// Field (5) 'Attestations'
	{
		buf = tail[o5:o6]
		num, err := ssz.DecodeDynamicLength(buf, 128)
		if err != nil {
			return err
		}
		b.Attestations = make([]*Attestation, num)
		err = ssz.UnmarshalDynamic(buf, num, func(indx int, buf []byte) (err error) {
			if b.Attestations[indx] == nil {
				b.Attestations[indx] = new(Attestation)
			}
			if err = b.Attestations[indx].UnmarshalSSZ(buf); err != nil {
				return err
			}
			return nil
		})
		if err != nil {
			return err
		}
	}

	// Field (6) 'Deposits'
	{
		buf = tail[o6:o7]
		num, err := ssz.DivideInt2(len(buf), 1240, 16)
		if err != nil {
			return err
		}
		b.Deposits = make([]*Deposit, num)
		for ii := 0; ii < num; ii++ {
			if b.Deposits[ii] == nil {
				b.Deposits[ii] = new(Deposit)
			}
			if err = b.Deposits[ii].UnmarshalSSZ(buf[ii*1240 : (ii+1)*1240]); err != nil {
				return err
			}
		}
	}

	// Field (7) 'VoluntaryExits'
	{
		buf = tail[o7:o9]
		num, err := ssz.DivideInt2(len(buf), 112, 16)
		if err != nil {
			return err
		}
		b.VoluntaryExits = make([]*SignedVoluntaryExit, num)
		for ii := 0; ii < num; ii++ {
			if b.VoluntaryExits[ii] == nil {
				b.VoluntaryExits[ii] = new(SignedVoluntaryExit)
			}
			if err = b.VoluntaryExits[ii].UnmarshalSSZ(buf[ii*112 : (ii+1)*112]); err != nil {
				return err
			}
		}
	}

	// Field (9) 'ExecutionPayload'
	{
		buf = tail[o9:]
		if b.ExecutionPayload == nil {
			b.ExecutionPayload = new(ExecutionPayload)
		}
		if err = b.ExecutionPayload.UnmarshalSSZ(buf); err != nil {
			return err
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the BeaconBodyBellatrix object
func (b *BeaconBodyBellatrix) SizeSSZ() (size int) {
	size = 384

	// Field (3) 'ProposerSlashings'
	size += len(b.ProposerSlashings) * 416

	// Field (4) 'AttesterSlashings'
	size += len(b.AttesterSlashings) * 416

	// Field (5) 'Attestations'
	for ii := 0; ii < len(b.Attestations); ii++ {
		size += 4
		size += b.Attestations[ii].SizeSSZ()
	}

	// Field (6) 'Deposits'
	size += len(b.Deposits) * 1240

	// Field (7) 'VoluntaryExits'
	size += len(b.VoluntaryExits) * 112

	// Field (9) 'ExecutionPayload'
	if b.ExecutionPayload == nil {
		b.ExecutionPayload = new(ExecutionPayload)
	}
	size += b.ExecutionPayload.SizeSSZ()

	return
}

// HashTreeRoot ssz hashes the BeaconBodyBellatrix object
func (b *BeaconBodyBellatrix) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(b)
}

// HashTreeRootWith ssz hashes the BeaconBodyBellatrix object with a hasher
func (b *BeaconBodyBellatrix) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'RandaoReveal'
	hh.PutBytes(b.RandaoReveal[:])

	// Field (1) 'Eth1Data'
	if b.Eth1Data == nil {
		b.Eth1Data = new(Eth1Data)
	}
	if err = b.Eth1Data.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (2) 'Graffiti'
	if size := len(b.Graffiti); size != 32 {
		err = ssz.ErrBytesLengthFn("BeaconBodyBellatrix.Graffiti", size, 32)
		return
	}
	hh.PutBytes(b.Graffiti)

	// Field (3) 'ProposerSlashings'
	{
		subIndx := hh.Index()
		num := uint64(len(b.ProposerSlashings))
		if num > 16 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range b.ProposerSlashings {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 16)
	}

	// Field (4) 'AttesterSlashings'
	{
		subIndx := hh.Index()
		num := uint64(len(b.AttesterSlashings))
		if num > 2 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range b.AttesterSlashings {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 2)
	}

	// Field (5) 'Attestations'
	{
		subIndx := hh.Index()
		num := uint64(len(b.Attestations))
		if num > 128 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range b.Attestations {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 128)
	}

	// Field (6) 'Deposits'
	{
		subIndx := hh.Index()
		num := uint64(len(b.Deposits))
		if num > 16 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range b.Deposits {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 16)
	}

	// Field (7) 'VoluntaryExits'
	{
		subIndx := hh.Index()
		num := uint64(len(b.VoluntaryExits))
		if num > 16 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range b.VoluntaryExits {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 16)
	}

	// Field (8) 'SyncAggregate'
	if b.SyncAggregate == nil {
		b.SyncAggregate = new(SyncAggregate)
	}
	if err = b.SyncAggregate.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (9) 'ExecutionPayload'
	if err = b.ExecutionPayload.HashTreeRootWith(hh); err != nil {
		return
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the BeaconBodyBellatrix object
func (b *BeaconBodyBellatrix) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(b)
}

// MarshalSSZ ssz marshals the BeaconBlockBellatrix object
func (b *BeaconBlockBellatrix) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(b)
}

// MarshalSSZTo ssz marshals the BeaconBlockBellatrix object to a target array
func (b *BeaconBlockBellatrix) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(84)

	// Field (0) 'Slot'
	dst = ssz.MarshalUint64(dst, b.Slot)

	// Field (1) 'ProposerIndex'
	dst = ssz.MarshalUint64(dst, b.ProposerIndex)

	// Field (2) 'ParentRoot'
	dst = append(dst, b.ParentRoot[:]...)

	// Field (3) 'StateRoot'
	dst = append(dst, b.StateRoot[:]...)

	// Offset (4) 'Body'
	dst = ssz.WriteOffset(dst, offset)
	if b.Body == nil {
		b.Body = new(BeaconBodyBellatrix)
	}
	offset += b.Body.SizeSSZ()

	// Field (4) 'Body'
	if dst, err = b.Body.MarshalSSZTo(dst); err != nil {
		return
	}

	return
}

// UnmarshalSSZ ssz unmarshals the BeaconBlockBellatrix object
func (b *BeaconBlockBellatrix) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 84 {
		return ssz.ErrSize
	}

	tail := buf
	var o4 uint64

	// Field (0) 'Slot'
	b.Slot = ssz.UnmarshallUint64(buf[0:8])

	// Field (1) 'ProposerIndex'
	b.ProposerIndex = ssz.UnmarshallUint64(buf[8:16])

	// Field (2) 'ParentRoot'
	copy(b.ParentRoot[:], buf[16:48])

	// Field (3) 'StateRoot'
	copy(b.StateRoot[:], buf[48:80])

	// Offset (4) 'Body'
	if o4 = ssz.ReadOffset(buf[80:84]); o4 > size {
		return ssz.ErrOffset
	}

	if o4 < 84 {
		return ssz.ErrInvalidVariableOffset
	}

	// Field (4) 'Body'
	{
		buf = tail[o4:]
		if b.Body == nil {
			b.Body = new(BeaconBodyBellatrix)
		}
		if err = b.Body.UnmarshalSSZ(buf); err != nil {
			return err
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the BeaconBlockBellatrix object
func (b *BeaconBlockBellatrix) SizeSSZ() (size int) {
	size = 84

	// Field (4) 'Body'
	if b.Body == nil {
		b.Body = new(BeaconBodyBellatrix)
	}
	size += b.Body.SizeSSZ()

	return
}

// HashTreeRoot ssz hashes the BeaconBlockBellatrix object
func (b *BeaconBlockBellatrix) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(b)
}

// HashTreeRootWith ssz hashes the BeaconBlockBellatrix object with a hasher
func (b *BeaconBlockBellatrix) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Slot'
	hh.PutUint64(b.Slot)

	// Field (1) 'ProposerIndex'
	hh.PutUint64(b.ProposerIndex)

	// Field (2) 'ParentRoot'
	hh.PutBytes(b.ParentRoot[:])

	// Field (3) 'StateRoot'
	hh.PutBytes(b.StateRoot[:])

	// Field (4) 'Body'
	if err = b.Body.HashTreeRootWith(hh); err != nil {
		return
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the BeaconBlockBellatrix object
func (b *BeaconBlockBellatrix) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(b)
}

// MarshalSSZ ssz marshals the SignedBeaconBlockBellatrix object
func (s *SignedBeaconBlockBellatrix) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(s)
}

// MarshalSSZTo ssz marshals the SignedBeaconBlockBellatrix object to a target array
func (s *SignedBeaconBlockBellatrix) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(100)

	// Offset (0) 'Block'
	dst = ssz.WriteOffset(dst, offset)
	if s.Block == nil {
		s.Block = new(BeaconBlockBellatrix)
	}
	offset += s.Block.SizeSSZ()

	// Field (1) 'Signature'
	dst = append(dst, s.Signature[:]...)

	// Field (0) 'Block'
	if dst, err = s.Block.MarshalSSZTo(dst); err != nil {
		return
	}

	return
}

// UnmarshalSSZ ssz unmarshals the SignedBeaconBlockBellatrix object
func (s *SignedBeaconBlockBellatrix) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 100 {
		return ssz.ErrSize
	}

	tail := buf
	var o0 uint64

	// Offset (0) 'Block'
	if o0 = ssz.ReadOffset(buf[0:4]); o0 > size {
		return ssz.ErrOffset
	}

	if o0 < 100 {
		return ssz.ErrInvalidVariableOffset
	}

	// Field (1) 'Signature'
	copy(s.Signature[:], buf[4:100])

	// Field (0) 'Block'
	{
		buf = tail[o0:]
		if s.Block == nil {
			s.Block = new(BeaconBlockBellatrix)
		}
		if err = s.Block.UnmarshalSSZ(buf); err != nil {
			return err
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the SignedBeaconBlockBellatrix object
func (s *SignedBeaconBlockBellatrix) SizeSSZ() (size int) {
	size = 100

	// Field (0) 'Block'
	if s.Block == nil {
		s.Block = new(BeaconBlockBellatrix)
	}
	size += s.Block.SizeSSZ()

	return
}

// HashTreeRoot ssz hashes the SignedBeaconBlockBellatrix object
func (s *SignedBeaconBlockBellatrix) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(s)
}

// HashTreeRootWith ssz hashes the SignedBeaconBlockBellatrix object with a hasher
func (s *SignedBeaconBlockBellatrix) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Block'
	if err = s.Block.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (1) 'Signature'
	hh.PutBytes(s.Signature[:])

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the SignedBeaconBlockBellatrix object
func (s *SignedBeaconBlockBellatrix) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(s)
}

// MarshalSSZ ssz marshals the SyncCommittee object
func (s *SyncCommittee) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(s)
}

// MarshalSSZTo ssz marshals the SyncCommittee object to a target array
func (s *SyncCommittee) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'PubKeys'
	if size := len(s.PubKeys); size != 512 {
		err = ssz.ErrVectorLengthFn("SyncCommittee.PubKeys", size, 512)
		return
	}
	for ii := 0; ii < 512; ii++ {
		dst = append(dst, s.PubKeys[ii][:]...)
	}

	return
}

// UnmarshalSSZ ssz unmarshals the SyncCommittee object
func (s *SyncCommittee) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size != 24576 {
		return ssz.ErrSize
	}

	// Field (0) 'PubKeys'
	s.PubKeys = make([][48]byte, 512)
	for ii := 0; ii < 512; ii++ {
		copy(s.PubKeys[ii][:], buf[0:24576][ii*48:(ii+1)*48])
	}

	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the SyncCommittee object
func (s *SyncCommittee) SizeSSZ() (size int) {
	size = 24576
	return
}

// HashTreeRoot ssz hashes the SyncCommittee object
func (s *SyncCommittee) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(s)
}

// HashTreeRootWith ssz hashes the SyncCommittee object with a hasher
func (s *SyncCommittee) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'PubKeys'
	{
		if size := len(s.PubKeys); size != 512 {
			err = ssz.ErrVectorLengthFn("SyncCommittee.PubKeys", size, 512)
			return
		}
		subIndx := hh.Index()
		for _, i := range s.PubKeys {
			hh.PutBytes(i[:])
		}
		hh.Merkleize(subIndx)
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the SyncCommittee object
func (s *SyncCommittee) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(s)
}

// MarshalSSZ ssz marshals the LightClientBootstrap object
func (l *LightClientBootstrap) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(l)
}

// MarshalSSZTo ssz marshals the LightClientBootstrap object to a target array
func (l *LightClientBootstrap) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'Header'
	if l.Header == nil {
		l.Header = new(BeaconBlockHeader)
	}
	if dst, err = l.Header.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (1) 'CurrentSyncCommittee'
	if l.CurrentSyncCommittee == nil {
		l.CurrentSyncCommittee = new(SyncCommittee)
	}
	if dst, err = l.CurrentSyncCommittee.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (2) 'CurrentSyncCommitteeBranch'
	if size := len(l.CurrentSyncCommitteeBranch); size != 5 {
		err = ssz.ErrVectorLengthFn("LightClientBootstrap.CurrentSyncCommitteeBranch", size, 5)
		return
	}
	for ii := 0; ii < 5; ii++ {
		if size := len(l.CurrentSyncCommitteeBranch[ii]); size != 32 {
			err = ssz.ErrBytesLengthFn("LightClientBootstrap.CurrentSyncCommitteeBranch[ii]", size, 32)
			return
		}
		dst = append(dst, l.CurrentSyncCommitteeBranch[ii]...)
	}

	return
}

// UnmarshalSSZ ssz unmarshals the LightClientBootstrap object
func (l *LightClientBootstrap) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size != 24848 {
		return ssz.ErrSize
	}

	// Field (0) 'Header'
	if l.Header == nil {
		l.Header = new(BeaconBlockHeader)
	}
	if err = l.Header.UnmarshalSSZ(buf[0:112]); err != nil {
		return err
	}

	// Field (1) 'CurrentSyncCommittee'
	if l.CurrentSyncCommittee == nil {
		l.CurrentSyncCommittee = new(SyncCommittee)
	}
	if err = l.CurrentSyncCommittee.UnmarshalSSZ(buf[112:24688]); err != nil {
		return err
	}

	// Field (2) 'CurrentSyncCommitteeBranch'
	l.CurrentSyncCommitteeBranch = make([][]byte, 5)
	for ii := 0; ii < 5; ii++ {
		if cap(l.CurrentSyncCommitteeBranch[ii]) == 0 {
			l.CurrentSyncCommitteeBranch[ii] = make([]byte, 0, len(buf[24688:24848][ii*32:(ii+1)*32]))
		}
		l.CurrentSyncCommitteeBranch[ii] = append(l.CurrentSyncCommitteeBranch[ii], buf[24688:24848][ii*32:(ii+1)*32]...)
	}

	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the LightClientBootstrap object
func (l *LightClientBootstrap) SizeSSZ() (size int) {
	size = 24848
	return
}

// HashTreeRoot ssz hashes the LightClientBootstrap object
func (l *LightClientBootstrap) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(l)
}

// HashTreeRootWith ssz hashes the LightClientBootstrap object with a hasher
func (l *LightClientBootstrap) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Header'
	if l.Header == nil {
		l.Header = new(BeaconBlockHeader)
	}
	if err = l.Header.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (1) 'CurrentSyncCommittee'
	if l.CurrentSyncCommittee == nil {
		l.CurrentSyncCommittee = new(SyncCommittee)
	}
	if err = l.CurrentSyncCommittee.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (2) 'CurrentSyncCommitteeBranch'
	{
		if size := len(l.CurrentSyncCommitteeBranch); size != 5 {
			err = ssz.ErrVectorLengthFn("LightClientBootstrap.CurrentSyncCommitteeBranch", size, 5)
			return
		}
		subIndx := hh.Index()
		for _, i := range l.CurrentSyncCommitteeBranch {
			if len(i) != 32 {
				err = ssz.ErrBytesLength
				return
			}
			hh.Append(i)
		}
		hh.Merkleize(subIndx)
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the LightClientBootstrap object
func (l *LightClientBootstrap) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(l)
}

// MarshalSSZ ssz marshals the LightClientUpdate object
func (l *LightClientUpdate) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(l)
}

// MarshalSSZTo ssz marshals the LightClientUpdate object to a target array
func (l *LightClientUpdate) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'AttestedHeader'
	if l.AttestedHeader == nil {
		l.AttestedHeader = new(BeaconBlockHeader)
	}
	if dst, err = l.AttestedHeader.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (1) 'NextSyncCommitee'
	if l.NextSyncCommitee == nil {
		l.NextSyncCommitee = new(SyncCommittee)
	}
	if dst, err = l.NextSyncCommitee.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (2) 'NextSyncCommitteeBranch'
	if size := len(l.NextSyncCommitteeBranch); size != 5 {
		err = ssz.ErrVectorLengthFn("LightClientUpdate.NextSyncCommitteeBranch", size, 5)
		return
	}
	for ii := 0; ii < 5; ii++ {
		if size := len(l.NextSyncCommitteeBranch[ii]); size != 32 {
			err = ssz.ErrBytesLengthFn("LightClientUpdate.NextSyncCommitteeBranch[ii]", size, 32)
			return
		}
		dst = append(dst, l.NextSyncCommitteeBranch[ii]...)
	}

	// Field (3) 'FinalizedHeader'
	if l.FinalizedHeader == nil {
		l.FinalizedHeader = new(BeaconBlockHeader)
	}
	if dst, err = l.FinalizedHeader.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (4) 'FinalityBranch'
	if size := len(l.FinalityBranch); size != 6 {
		err = ssz.ErrVectorLengthFn("LightClientUpdate.FinalityBranch", size, 6)
		return
	}
	for ii := 0; ii < 6; ii++ {
		if size := len(l.FinalityBranch[ii]); size != 32 {
			err = ssz.ErrBytesLengthFn("LightClientUpdate.FinalityBranch[ii]", size, 32)
			return
		}
		dst = append(dst, l.FinalityBranch[ii]...)
	}

	// Field (5) 'SyncAggregate'
	if l.SyncAggregate == nil {
		l.SyncAggregate = new(SyncAggregate)
	}
	if dst, err = l.SyncAggregate.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (6) 'SignatureSlot'
	dst = ssz.MarshalUint64(dst, l.SignatureSlot)

	return
}

// UnmarshalSSZ ssz unmarshals the LightClientUpdate object
func (l *LightClientUpdate) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size != 25320 {
		return ssz.ErrSize
	}

	// Field (0) 'AttestedHeader'
	if l.AttestedHeader == nil {
		l.AttestedHeader = new(BeaconBlockHeader)
	}
	if err = l.AttestedHeader.UnmarshalSSZ(buf[0:112]); err != nil {
		return err
	}

	// Field (1) 'NextSyncCommitee'
	if l.NextSyncCommitee == nil {
		l.NextSyncCommitee = new(SyncCommittee)
	}
	if err = l.NextSyncCommitee.UnmarshalSSZ(buf[112:24688]); err != nil {
		return err
	}

	// Field (2) 'NextSyncCommitteeBranch'
	l.NextSyncCommitteeBranch = make([][]byte, 5)
	for ii := 0; ii < 5; ii++ {
		if cap(l.NextSyncCommitteeBranch[ii]) == 0 {
			l.NextSyncCommitteeBranch[ii] = make([]byte, 0, len(buf[24688:24848][ii*32:(ii+1)*32]))
		}
		l.NextSyncCommitteeBranch[ii] = append(l.NextSyncCommitteeBranch[ii], buf[24688:24848][ii*32:(ii+1)*32]...)
	}

	// Field (3) 'FinalizedHeader'
	if l.FinalizedHeader == nil {
		l.FinalizedHeader = new(BeaconBlockHeader)
	}
	if err = l.FinalizedHeader.UnmarshalSSZ(buf[24848:24960]); err != nil {
		return err
	}

	// Field (4) 'FinalityBranch'
	l.FinalityBranch = make([][]byte, 6)
	for ii := 0; ii < 6; ii++ {
		if cap(l.FinalityBranch[ii]) == 0 {
			l.FinalityBranch[ii] = make([]byte, 0, len(buf[24960:25152][ii*32:(ii+1)*32]))
		}
		l.FinalityBranch[ii] = append(l.FinalityBranch[ii], buf[24960:25152][ii*32:(ii+1)*32]...)
	}

	// Field (5) 'SyncAggregate'
	if l.SyncAggregate == nil {
		l.SyncAggregate = new(SyncAggregate)
	}
	if err = l.SyncAggregate.UnmarshalSSZ(buf[25152:25312]); err != nil {
		return err
	}

	// Field (6) 'SignatureSlot'
	l.SignatureSlot = ssz.UnmarshallUint64(buf[25312:25320])

	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the LightClientUpdate object
func (l *LightClientUpdate) SizeSSZ() (size int) {
	size = 25320
	return
}

// HashTreeRoot ssz hashes the LightClientUpdate object
func (l *LightClientUpdate) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(l)
}

// HashTreeRootWith ssz hashes the LightClientUpdate object with a hasher
func (l *LightClientUpdate) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'AttestedHeader'
	if l.AttestedHeader == nil {
		l.AttestedHeader = new(BeaconBlockHeader)
	}
	if err = l.AttestedHeader.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (1) 'NextSyncCommitee'
	if l.NextSyncCommitee == nil {
		l.NextSyncCommitee = new(SyncCommittee)
	}
	if err = l.NextSyncCommitee.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (2) 'NextSyncCommitteeBranch'
	{
		if size := len(l.NextSyncCommitteeBranch); size != 5 {
			err = ssz.ErrVectorLengthFn("LightClientUpdate.NextSyncCommitteeBranch", size, 5)
			return
		}
		subIndx := hh.Index()
		for _, i := range l.NextSyncCommitteeBranch {
			if len(i) != 32 {
				err = ssz.ErrBytesLength
				return
			}
			hh.Append(i)
		}
		hh.Merkleize(subIndx)
	}

	// Field (3) 'FinalizedHeader'
	if l.FinalizedHeader == nil {
		l.FinalizedHeader = new(BeaconBlockHeader)
	}
	if err = l.FinalizedHeader.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (4) 'FinalityBranch'
	{
		if size := len(l.FinalityBranch); size != 6 {
			err = ssz.ErrVectorLengthFn("LightClientUpdate.FinalityBranch", size, 6)
			return
		}
		subIndx := hh.Index()
		for _, i := range l.FinalityBranch {
			if len(i) != 32 {
				err = ssz.ErrBytesLength
				return
			}
			hh.Append(i)
		}
		hh.Merkleize(subIndx)
	}

	// Field (5) 'SyncAggregate'
	if l.SyncAggregate == nil {
		l.SyncAggregate = new(SyncAggregate)
	}
	if err = l.SyncAggregate.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (6) 'SignatureSlot'
	hh.PutUint64(l.SignatureSlot)

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the LightClientUpdate object
func (l *LightClientUpdate) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(l)
}

// MarshalSSZ ssz marshals the LightClientFinalityUpdate object
func (l *LightClientFinalityUpdate) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(l)
}

// MarshalSSZTo ssz marshals the LightClientFinalityUpdate object to a target array
func (l *LightClientFinalityUpdate) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'AttestedHeader'
	if l.AttestedHeader == nil {
		l.AttestedHeader = new(BeaconBlockHeader)
	}
	if dst, err = l.AttestedHeader.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (1) 'FinalizedHeader'
	if l.FinalizedHeader == nil {
		l.FinalizedHeader = new(BeaconBlockHeader)
	}
	if dst, err = l.FinalizedHeader.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (2) 'FinalityBranch'
	if size := len(l.FinalityBranch); size != 6 {
		err = ssz.ErrVectorLengthFn("LightClientFinalityUpdate.FinalityBranch", size, 6)
		return
	}
	for ii := 0; ii < 6; ii++ {
		if size := len(l.FinalityBranch[ii]); size != 32 {
			err = ssz.ErrBytesLengthFn("LightClientFinalityUpdate.FinalityBranch[ii]", size, 32)
			return
		}
		dst = append(dst, l.FinalityBranch[ii]...)
	}

	// Field (3) 'SyncAggregate'
	if l.SyncAggregate == nil {
		l.SyncAggregate = new(SyncAggregate)
	}
	if dst, err = l.SyncAggregate.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (4) 'SignatureSlot'
	dst = ssz.MarshalUint64(dst, l.SignatureSlot)

	return
}

// UnmarshalSSZ ssz unmarshals the LightClientFinalityUpdate object
func (l *LightClientFinalityUpdate) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size != 584 {
		return ssz.ErrSize
	}

	// Field (0) 'AttestedHeader'
	if l.AttestedHeader == nil {
		l.AttestedHeader = new(BeaconBlockHeader)
	}
	if err = l.AttestedHeader.UnmarshalSSZ(buf[0:112]); err != nil {
		return err
	}

	// Field (1) 'FinalizedHeader'
	if l.FinalizedHeader == nil {
		l.FinalizedHeader = new(BeaconBlockHeader)
	}
	if err = l.FinalizedHeader.UnmarshalSSZ(buf[112:224]); err != nil {
		return err
	}

	// Field (2) 'FinalityBranch'
	l.FinalityBranch = make([][]byte, 6)
	for ii := 0; ii < 6; ii++ {
		if cap(l.FinalityBranch[ii]) == 0 {
			l.FinalityBranch[ii] = make([]byte, 0, len(buf[224:416][ii*32:(ii+1)*32]))
		}
		l.FinalityBranch[ii] = append(l.FinalityBranch[ii], buf[224:416][ii*32:(ii+1)*32]...)
	}

	// Field (3) 'SyncAggregate'
	if l.SyncAggregate == nil {
		l.SyncAggregate = new(SyncAggregate)
	}
	if err = l.SyncAggregate.UnmarshalSSZ(buf[416:576]); err != nil {
		return err
	}

	// Field (4) 'SignatureSlot'
	l.SignatureSlot = ssz.UnmarshallUint64(buf[576:584])

	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the LightClientFinalityUpdate object
func (l *LightClientFinalityUpdate) SizeSSZ() (size int) {
	size = 584
	return
}

// HashTreeRoot ssz hashes the LightClientFinalityUpdate object
func (l *LightClientFinalityUpdate) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(l)
}

// HashTreeRootWith ssz hashes the LightClientFinalityUpdate object with a hasher
func (l *LightClientFinalityUpdate) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'AttestedHeader'
	if l.AttestedHeader == nil {
		l.AttestedHeader = new(BeaconBlockHeader)
	}
	if err = l.AttestedHeader.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (1) 'FinalizedHeader'
	if l.FinalizedHeader == nil {
		l.FinalizedHeader = new(BeaconBlockHeader)
	}
	if err = l.FinalizedHeader.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (2) 'FinalityBranch'
	{
		if size := len(l.FinalityBranch); size != 6 {
			err = ssz.ErrVectorLengthFn("LightClientFinalityUpdate.FinalityBranch", size, 6)
			return
		}
		subIndx := hh.Index()
		for _, i := range l.FinalityBranch {
			if len(i) != 32 {
				err = ssz.ErrBytesLength
				return
			}
			hh.Append(i)
		}
		hh.Merkleize(subIndx)
	}

	// Field (3) 'SyncAggregate'
	if l.SyncAggregate == nil {
		l.SyncAggregate = new(SyncAggregate)
	}
	if err = l.SyncAggregate.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (4) 'SignatureSlot'
	hh.PutUint64(l.SignatureSlot)

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the LightClientFinalityUpdate object
func (l *LightClientFinalityUpdate) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(l)
}

// MarshalSSZ ssz marshals the LightClientOptimisticUpdate object
func (l *LightClientOptimisticUpdate) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(l)
}

// MarshalSSZTo ssz marshals the LightClientOptimisticUpdate object to a target array
func (l *LightClientOptimisticUpdate) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'AttestedHeader'
	if l.AttestedHeader == nil {
		l.AttestedHeader = new(BeaconBlockHeader)
	}
	if dst, err = l.AttestedHeader.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (1) 'SyncAggregate'
	if l.SyncAggregate == nil {
		l.SyncAggregate = new(SyncAggregate)
	}
	if dst, err = l.SyncAggregate.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (2) 'SignatureSlot'
	dst = ssz.MarshalUint64(dst, l.SignatureSlot)

	return
}

// UnmarshalSSZ ssz unmarshals the LightClientOptimisticUpdate object
func (l *LightClientOptimisticUpdate) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size != 280 {
		return ssz.ErrSize
	}

	// Field (0) 'AttestedHeader'
	if l.AttestedHeader == nil {
		l.AttestedHeader = new(BeaconBlockHeader)
	}
	if err = l.AttestedHeader.UnmarshalSSZ(buf[0:112]); err != nil {
		return err
	}

	// Field (1) 'SyncAggregate'
	if l.SyncAggregate == nil {
		l.SyncAggregate = new(SyncAggregate)
	}
	if err = l.SyncAggregate.UnmarshalSSZ(buf[112:272]); err != nil {
		return err
	}

	// Field (2) 'SignatureSlot'
	l.SignatureSlot = ssz.UnmarshallUint64(buf[272:280])

	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the LightClientOptimisticUpdate object
func (l *LightClientOptimisticUpdate) SizeSSZ() (size int) {
	size = 280
	return
}

// HashTreeRoot ssz hashes the LightClientOptimisticUpdate object
func (l *LightClientOptimisticUpdate) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(l)
}

// HashTreeRootWith ssz hashes the LightClientOptimisticUpdate object with a hasher
func (l *LightClientOptimisticUpdate) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'AttestedHeader'
	if l.AttestedHeader == nil {
		l.AttestedHeader = new(BeaconBlockHeader)
	}
	if err = l.AttestedHeader.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (1) 'SyncAggregate'
	if l.SyncAggregate == nil {
		l.SyncAggregate = new(SyncAggregate)
	}
	if err = l.SyncAggregate.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (2) 'SignatureSlot'
	hh.PutUint64(l.SignatureSlot)

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the LightClientOptimisticUpdate object
func (l *LightClientOptimisticUpdate) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(l)
}
