// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package downloader

import (
	context "context"
	grpc "google.golang.org/grpc"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	sync "sync"
)

// Ensure, that DownloaderClientMock does implement DownloaderClient.
// If this is not the case, regenerate this file with moq.
var _ DownloaderClient = &DownloaderClientMock{}

// DownloaderClientMock is a mock implementation of DownloaderClient.
//
//	func TestSomethingThatUsesDownloaderClient(t *testing.T) {
//
//		// make and configure a mocked DownloaderClient
//		mockedDownloaderClient := &DownloaderClientMock{
//			AddFunc: func(ctx context.Context, in *AddRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
//				panic("mock out the Add method")
//			},
//			DeleteFunc: func(ctx context.Context, in *DeleteRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
//				panic("mock out the Delete method")
//			},
//			ProhibitNewDownloadsFunc: func(ctx context.Context, in *ProhibitNewDownloadsRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
//				panic("mock out the ProhibitNewDownloads method")
//			},
//			StatsFunc: func(ctx context.Context, in *StatsRequest, opts ...grpc.CallOption) (*StatsReply, error) {
//				panic("mock out the Stats method")
//			},
//			VerifyFunc: func(ctx context.Context, in *VerifyRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
//				panic("mock out the Verify method")
//			},
//		}
//
//		// use mockedDownloaderClient in code that requires DownloaderClient
//		// and then make assertions.
//
//	}
type DownloaderClientMock struct {
	// AddFunc mocks the Add method.
	AddFunc func(ctx context.Context, in *AddRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)

	// DeleteFunc mocks the Delete method.
	DeleteFunc func(ctx context.Context, in *DeleteRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)

	// ProhibitNewDownloadsFunc mocks the ProhibitNewDownloads method.
	ProhibitNewDownloadsFunc func(ctx context.Context, in *ProhibitNewDownloadsRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)

	// StatsFunc mocks the Stats method.
	StatsFunc func(ctx context.Context, in *StatsRequest, opts ...grpc.CallOption) (*StatsReply, error)

	// VerifyFunc mocks the Verify method.
	VerifyFunc func(ctx context.Context, in *VerifyRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)

	// calls tracks calls to the methods.
	calls struct {
		// Add holds details about calls to the Add method.
		Add []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *AddRequest
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
		// Delete holds details about calls to the Delete method.
		Delete []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *DeleteRequest
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
		// ProhibitNewDownloads holds details about calls to the ProhibitNewDownloads method.
		ProhibitNewDownloads []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *ProhibitNewDownloadsRequest
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
		// Stats holds details about calls to the Stats method.
		Stats []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *StatsRequest
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
		// Verify holds details about calls to the Verify method.
		Verify []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *VerifyRequest
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
	}
	lockAdd                  sync.RWMutex
	lockDelete               sync.RWMutex
	lockProhibitNewDownloads sync.RWMutex
	lockStats                sync.RWMutex
	lockVerify               sync.RWMutex
}

// Add calls AddFunc.
func (mock *DownloaderClientMock) Add(ctx context.Context, in *AddRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	callInfo := struct {
		Ctx  context.Context
		In   *AddRequest
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockAdd.Lock()
	mock.calls.Add = append(mock.calls.Add, callInfo)
	mock.lockAdd.Unlock()
	if mock.AddFunc == nil {
		var (
			emptyOut *emptypb.Empty
			errOut   error
		)
		return emptyOut, errOut
	}
	return mock.AddFunc(ctx, in, opts...)
}

// AddCalls gets all the calls that were made to Add.
// Check the length with:
//
//	len(mockedDownloaderClient.AddCalls())
func (mock *DownloaderClientMock) AddCalls() []struct {
	Ctx  context.Context
	In   *AddRequest
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *AddRequest
		Opts []grpc.CallOption
	}
	mock.lockAdd.RLock()
	calls = mock.calls.Add
	mock.lockAdd.RUnlock()
	return calls
}

// Delete calls DeleteFunc.
func (mock *DownloaderClientMock) Delete(ctx context.Context, in *DeleteRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	callInfo := struct {
		Ctx  context.Context
		In   *DeleteRequest
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockDelete.Lock()
	mock.calls.Delete = append(mock.calls.Delete, callInfo)
	mock.lockDelete.Unlock()
	if mock.DeleteFunc == nil {
		var (
			emptyOut *emptypb.Empty
			errOut   error
		)
		return emptyOut, errOut
	}
	return mock.DeleteFunc(ctx, in, opts...)
}

// DeleteCalls gets all the calls that were made to Delete.
// Check the length with:
//
//	len(mockedDownloaderClient.DeleteCalls())
func (mock *DownloaderClientMock) DeleteCalls() []struct {
	Ctx  context.Context
	In   *DeleteRequest
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *DeleteRequest
		Opts []grpc.CallOption
	}
	mock.lockDelete.RLock()
	calls = mock.calls.Delete
	mock.lockDelete.RUnlock()
	return calls
}

// ProhibitNewDownloads calls ProhibitNewDownloadsFunc.
func (mock *DownloaderClientMock) ProhibitNewDownloads(ctx context.Context, in *ProhibitNewDownloadsRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	callInfo := struct {
		Ctx  context.Context
		In   *ProhibitNewDownloadsRequest
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockProhibitNewDownloads.Lock()
	mock.calls.ProhibitNewDownloads = append(mock.calls.ProhibitNewDownloads, callInfo)
	mock.lockProhibitNewDownloads.Unlock()
	if mock.ProhibitNewDownloadsFunc == nil {
		var (
			emptyOut *emptypb.Empty
			errOut   error
		)
		return emptyOut, errOut
	}
	return mock.ProhibitNewDownloadsFunc(ctx, in, opts...)
}

// ProhibitNewDownloadsCalls gets all the calls that were made to ProhibitNewDownloads.
// Check the length with:
//
//	len(mockedDownloaderClient.ProhibitNewDownloadsCalls())
func (mock *DownloaderClientMock) ProhibitNewDownloadsCalls() []struct {
	Ctx  context.Context
	In   *ProhibitNewDownloadsRequest
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *ProhibitNewDownloadsRequest
		Opts []grpc.CallOption
	}
	mock.lockProhibitNewDownloads.RLock()
	calls = mock.calls.ProhibitNewDownloads
	mock.lockProhibitNewDownloads.RUnlock()
	return calls
}

// Stats calls StatsFunc.
func (mock *DownloaderClientMock) Stats(ctx context.Context, in *StatsRequest, opts ...grpc.CallOption) (*StatsReply, error) {
	callInfo := struct {
		Ctx  context.Context
		In   *StatsRequest
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockStats.Lock()
	mock.calls.Stats = append(mock.calls.Stats, callInfo)
	mock.lockStats.Unlock()
	if mock.StatsFunc == nil {
		var (
			statsReplyOut *StatsReply
			errOut        error
		)
		return statsReplyOut, errOut
	}
	return mock.StatsFunc(ctx, in, opts...)
}

// StatsCalls gets all the calls that were made to Stats.
// Check the length with:
//
//	len(mockedDownloaderClient.StatsCalls())
func (mock *DownloaderClientMock) StatsCalls() []struct {
	Ctx  context.Context
	In   *StatsRequest
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *StatsRequest
		Opts []grpc.CallOption
	}
	mock.lockStats.RLock()
	calls = mock.calls.Stats
	mock.lockStats.RUnlock()
	return calls
}

// Verify calls VerifyFunc.
func (mock *DownloaderClientMock) Verify(ctx context.Context, in *VerifyRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	callInfo := struct {
		Ctx  context.Context
		In   *VerifyRequest
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockVerify.Lock()
	mock.calls.Verify = append(mock.calls.Verify, callInfo)
	mock.lockVerify.Unlock()
	if mock.VerifyFunc == nil {
		var (
			emptyOut *emptypb.Empty
			errOut   error
		)
		return emptyOut, errOut
	}
	return mock.VerifyFunc(ctx, in, opts...)
}

// VerifyCalls gets all the calls that were made to Verify.
// Check the length with:
//
//	len(mockedDownloaderClient.VerifyCalls())
func (mock *DownloaderClientMock) VerifyCalls() []struct {
	Ctx  context.Context
	In   *VerifyRequest
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *VerifyRequest
		Opts []grpc.CallOption
	}
	mock.lockVerify.RLock()
	calls = mock.calls.Verify
	mock.lockVerify.RUnlock()
	return calls
}

// Ensure, that DownloaderServerMock does implement DownloaderServer.
// If this is not the case, regenerate this file with moq.
var _ DownloaderServer = &DownloaderServerMock{}

// DownloaderServerMock is a mock implementation of DownloaderServer.
//
//	func TestSomethingThatUsesDownloaderServer(t *testing.T) {
//
//		// make and configure a mocked DownloaderServer
//		mockedDownloaderServer := &DownloaderServerMock{
//			AddFunc: func(contextMoqParam context.Context, addRequest *AddRequest) (*emptypb.Empty, error) {
//				panic("mock out the Add method")
//			},
//			DeleteFunc: func(contextMoqParam context.Context, deleteRequest *DeleteRequest) (*emptypb.Empty, error) {
//				panic("mock out the Delete method")
//			},
//			ProhibitNewDownloadsFunc: func(contextMoqParam context.Context, prohibitNewDownloadsRequest *ProhibitNewDownloadsRequest) (*emptypb.Empty, error) {
//				panic("mock out the ProhibitNewDownloads method")
//			},
//			StatsFunc: func(contextMoqParam context.Context, statsRequest *StatsRequest) (*StatsReply, error) {
//				panic("mock out the Stats method")
//			},
//			VerifyFunc: func(contextMoqParam context.Context, verifyRequest *VerifyRequest) (*emptypb.Empty, error) {
//				panic("mock out the Verify method")
//			},
//			mustEmbedUnimplementedDownloaderServerFunc: func()  {
//				panic("mock out the mustEmbedUnimplementedDownloaderServer method")
//			},
//		}
//
//		// use mockedDownloaderServer in code that requires DownloaderServer
//		// and then make assertions.
//
//	}
type DownloaderServerMock struct {
	// AddFunc mocks the Add method.
	AddFunc func(contextMoqParam context.Context, addRequest *AddRequest) (*emptypb.Empty, error)

	// DeleteFunc mocks the Delete method.
	DeleteFunc func(contextMoqParam context.Context, deleteRequest *DeleteRequest) (*emptypb.Empty, error)

	// ProhibitNewDownloadsFunc mocks the ProhibitNewDownloads method.
	ProhibitNewDownloadsFunc func(contextMoqParam context.Context, prohibitNewDownloadsRequest *ProhibitNewDownloadsRequest) (*emptypb.Empty, error)

	// StatsFunc mocks the Stats method.
	StatsFunc func(contextMoqParam context.Context, statsRequest *StatsRequest) (*StatsReply, error)

	// VerifyFunc mocks the Verify method.
	VerifyFunc func(contextMoqParam context.Context, verifyRequest *VerifyRequest) (*emptypb.Empty, error)

	// mustEmbedUnimplementedDownloaderServerFunc mocks the mustEmbedUnimplementedDownloaderServer method.
	mustEmbedUnimplementedDownloaderServerFunc func()

	// calls tracks calls to the methods.
	calls struct {
		// Add holds details about calls to the Add method.
		Add []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
			// AddRequest is the addRequest argument value.
			AddRequest *AddRequest
		}
		// Delete holds details about calls to the Delete method.
		Delete []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
			// DeleteRequest is the deleteRequest argument value.
			DeleteRequest *DeleteRequest
		}
		// ProhibitNewDownloads holds details about calls to the ProhibitNewDownloads method.
		ProhibitNewDownloads []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
			// ProhibitNewDownloadsRequest is the prohibitNewDownloadsRequest argument value.
			ProhibitNewDownloadsRequest *ProhibitNewDownloadsRequest
		}
		// Stats holds details about calls to the Stats method.
		Stats []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
			// StatsRequest is the statsRequest argument value.
			StatsRequest *StatsRequest
		}
		// Verify holds details about calls to the Verify method.
		Verify []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
			// VerifyRequest is the verifyRequest argument value.
			VerifyRequest *VerifyRequest
		}
		// mustEmbedUnimplementedDownloaderServer holds details about calls to the mustEmbedUnimplementedDownloaderServer method.
		mustEmbedUnimplementedDownloaderServer []struct {
		}
	}
	lockAdd                                    sync.RWMutex
	lockDelete                                 sync.RWMutex
	lockProhibitNewDownloads                   sync.RWMutex
	lockStats                                  sync.RWMutex
	lockVerify                                 sync.RWMutex
	lockmustEmbedUnimplementedDownloaderServer sync.RWMutex
}

// Add calls AddFunc.
func (mock *DownloaderServerMock) Add(contextMoqParam context.Context, addRequest *AddRequest) (*emptypb.Empty, error) {
	callInfo := struct {
		ContextMoqParam context.Context
		AddRequest      *AddRequest
	}{
		ContextMoqParam: contextMoqParam,
		AddRequest:      addRequest,
	}
	mock.lockAdd.Lock()
	mock.calls.Add = append(mock.calls.Add, callInfo)
	mock.lockAdd.Unlock()
	if mock.AddFunc == nil {
		var (
			emptyOut *emptypb.Empty
			errOut   error
		)
		return emptyOut, errOut
	}
	return mock.AddFunc(contextMoqParam, addRequest)
}

// AddCalls gets all the calls that were made to Add.
// Check the length with:
//
//	len(mockedDownloaderServer.AddCalls())
func (mock *DownloaderServerMock) AddCalls() []struct {
	ContextMoqParam context.Context
	AddRequest      *AddRequest
} {
	var calls []struct {
		ContextMoqParam context.Context
		AddRequest      *AddRequest
	}
	mock.lockAdd.RLock()
	calls = mock.calls.Add
	mock.lockAdd.RUnlock()
	return calls
}

// Delete calls DeleteFunc.
func (mock *DownloaderServerMock) Delete(contextMoqParam context.Context, deleteRequest *DeleteRequest) (*emptypb.Empty, error) {
	callInfo := struct {
		ContextMoqParam context.Context
		DeleteRequest   *DeleteRequest
	}{
		ContextMoqParam: contextMoqParam,
		DeleteRequest:   deleteRequest,
	}
	mock.lockDelete.Lock()
	mock.calls.Delete = append(mock.calls.Delete, callInfo)
	mock.lockDelete.Unlock()
	if mock.DeleteFunc == nil {
		var (
			emptyOut *emptypb.Empty
			errOut   error
		)
		return emptyOut, errOut
	}
	return mock.DeleteFunc(contextMoqParam, deleteRequest)
}

// DeleteCalls gets all the calls that were made to Delete.
// Check the length with:
//
//	len(mockedDownloaderServer.DeleteCalls())
func (mock *DownloaderServerMock) DeleteCalls() []struct {
	ContextMoqParam context.Context
	DeleteRequest   *DeleteRequest
} {
	var calls []struct {
		ContextMoqParam context.Context
		DeleteRequest   *DeleteRequest
	}
	mock.lockDelete.RLock()
	calls = mock.calls.Delete
	mock.lockDelete.RUnlock()
	return calls
}

// ProhibitNewDownloads calls ProhibitNewDownloadsFunc.
func (mock *DownloaderServerMock) ProhibitNewDownloads(contextMoqParam context.Context, prohibitNewDownloadsRequest *ProhibitNewDownloadsRequest) (*emptypb.Empty, error) {
	callInfo := struct {
		ContextMoqParam             context.Context
		ProhibitNewDownloadsRequest *ProhibitNewDownloadsRequest
	}{
		ContextMoqParam:             contextMoqParam,
		ProhibitNewDownloadsRequest: prohibitNewDownloadsRequest,
	}
	mock.lockProhibitNewDownloads.Lock()
	mock.calls.ProhibitNewDownloads = append(mock.calls.ProhibitNewDownloads, callInfo)
	mock.lockProhibitNewDownloads.Unlock()
	if mock.ProhibitNewDownloadsFunc == nil {
		var (
			emptyOut *emptypb.Empty
			errOut   error
		)
		return emptyOut, errOut
	}
	return mock.ProhibitNewDownloadsFunc(contextMoqParam, prohibitNewDownloadsRequest)
}

// ProhibitNewDownloadsCalls gets all the calls that were made to ProhibitNewDownloads.
// Check the length with:
//
//	len(mockedDownloaderServer.ProhibitNewDownloadsCalls())
func (mock *DownloaderServerMock) ProhibitNewDownloadsCalls() []struct {
	ContextMoqParam             context.Context
	ProhibitNewDownloadsRequest *ProhibitNewDownloadsRequest
} {
	var calls []struct {
		ContextMoqParam             context.Context
		ProhibitNewDownloadsRequest *ProhibitNewDownloadsRequest
	}
	mock.lockProhibitNewDownloads.RLock()
	calls = mock.calls.ProhibitNewDownloads
	mock.lockProhibitNewDownloads.RUnlock()
	return calls
}

// Stats calls StatsFunc.
func (mock *DownloaderServerMock) Stats(contextMoqParam context.Context, statsRequest *StatsRequest) (*StatsReply, error) {
	callInfo := struct {
		ContextMoqParam context.Context
		StatsRequest    *StatsRequest
	}{
		ContextMoqParam: contextMoqParam,
		StatsRequest:    statsRequest,
	}
	mock.lockStats.Lock()
	mock.calls.Stats = append(mock.calls.Stats, callInfo)
	mock.lockStats.Unlock()
	if mock.StatsFunc == nil {
		var (
			statsReplyOut *StatsReply
			errOut        error
		)
		return statsReplyOut, errOut
	}
	return mock.StatsFunc(contextMoqParam, statsRequest)
}

// StatsCalls gets all the calls that were made to Stats.
// Check the length with:
//
//	len(mockedDownloaderServer.StatsCalls())
func (mock *DownloaderServerMock) StatsCalls() []struct {
	ContextMoqParam context.Context
	StatsRequest    *StatsRequest
} {
	var calls []struct {
		ContextMoqParam context.Context
		StatsRequest    *StatsRequest
	}
	mock.lockStats.RLock()
	calls = mock.calls.Stats
	mock.lockStats.RUnlock()
	return calls
}

// Verify calls VerifyFunc.
func (mock *DownloaderServerMock) Verify(contextMoqParam context.Context, verifyRequest *VerifyRequest) (*emptypb.Empty, error) {
	callInfo := struct {
		ContextMoqParam context.Context
		VerifyRequest   *VerifyRequest
	}{
		ContextMoqParam: contextMoqParam,
		VerifyRequest:   verifyRequest,
	}
	mock.lockVerify.Lock()
	mock.calls.Verify = append(mock.calls.Verify, callInfo)
	mock.lockVerify.Unlock()
	if mock.VerifyFunc == nil {
		var (
			emptyOut *emptypb.Empty
			errOut   error
		)
		return emptyOut, errOut
	}
	return mock.VerifyFunc(contextMoqParam, verifyRequest)
}

// VerifyCalls gets all the calls that were made to Verify.
// Check the length with:
//
//	len(mockedDownloaderServer.VerifyCalls())
func (mock *DownloaderServerMock) VerifyCalls() []struct {
	ContextMoqParam context.Context
	VerifyRequest   *VerifyRequest
} {
	var calls []struct {
		ContextMoqParam context.Context
		VerifyRequest   *VerifyRequest
	}
	mock.lockVerify.RLock()
	calls = mock.calls.Verify
	mock.lockVerify.RUnlock()
	return calls
}

// mustEmbedUnimplementedDownloaderServer calls mustEmbedUnimplementedDownloaderServerFunc.
func (mock *DownloaderServerMock) mustEmbedUnimplementedDownloaderServer() {
	callInfo := struct {
	}{}
	mock.lockmustEmbedUnimplementedDownloaderServer.Lock()
	mock.calls.mustEmbedUnimplementedDownloaderServer = append(mock.calls.mustEmbedUnimplementedDownloaderServer, callInfo)
	mock.lockmustEmbedUnimplementedDownloaderServer.Unlock()
	if mock.mustEmbedUnimplementedDownloaderServerFunc == nil {
		return
	}
	mock.mustEmbedUnimplementedDownloaderServerFunc()
}

// mustEmbedUnimplementedDownloaderServerCalls gets all the calls that were made to mustEmbedUnimplementedDownloaderServer.
// Check the length with:
//
//	len(mockedDownloaderServer.mustEmbedUnimplementedDownloaderServerCalls())
func (mock *DownloaderServerMock) mustEmbedUnimplementedDownloaderServerCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockmustEmbedUnimplementedDownloaderServer.RLock()
	calls = mock.calls.mustEmbedUnimplementedDownloaderServer
	mock.lockmustEmbedUnimplementedDownloaderServer.RUnlock()
	return calls
}
