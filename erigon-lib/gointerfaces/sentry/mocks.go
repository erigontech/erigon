// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package sentry

import (
	context "context"
	types "github.com/ledgerwatch/erigon-lib/gointerfaces/types"
	grpc "google.golang.org/grpc"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	sync "sync"
)

// Ensure, that SentryServerMock does implement SentryServer.
// If this is not the case, regenerate this file with moq.
var _ SentryServer = &SentryServerMock{}

// SentryServerMock is a mock implementation of SentryServer.
//
//	func TestSomethingThatUsesSentryServer(t *testing.T) {
//
//		// make and configure a mocked SentryServer
//		mockedSentryServer := &SentryServerMock{
//			AddPeerFunc: func(contextMoqParam context.Context, addPeerRequest *AddPeerRequest) (*AddPeerReply, error) {
//				panic("mock out the AddPeer method")
//			},
//			HandShakeFunc: func(contextMoqParam context.Context, empty *emptypb.Empty) (*HandShakeReply, error) {
//				panic("mock out the HandShake method")
//			},
//			MessagesFunc: func(messagesRequest *MessagesRequest, sentry_MessagesServer Sentry_MessagesServer) error {
//				panic("mock out the Messages method")
//			},
//			NodeInfoFunc: func(contextMoqParam context.Context, empty *emptypb.Empty) (*types.NodeInfoReply, error) {
//				panic("mock out the NodeInfo method")
//			},
//			PeerByIdFunc: func(contextMoqParam context.Context, peerByIdRequest *PeerByIdRequest) (*PeerByIdReply, error) {
//				panic("mock out the PeerById method")
//			},
//			PeerCountFunc: func(contextMoqParam context.Context, peerCountRequest *PeerCountRequest) (*PeerCountReply, error) {
//				panic("mock out the PeerCount method")
//			},
//			PeerEventsFunc: func(peerEventsRequest *PeerEventsRequest, sentry_PeerEventsServer Sentry_PeerEventsServer) error {
//				panic("mock out the PeerEvents method")
//			},
//			PeerMinBlockFunc: func(contextMoqParam context.Context, peerMinBlockRequest *PeerMinBlockRequest) (*emptypb.Empty, error) {
//				panic("mock out the PeerMinBlock method")
//			},
//			PeersFunc: func(contextMoqParam context.Context, empty *emptypb.Empty) (*PeersReply, error) {
//				panic("mock out the Peers method")
//			},
//			PenalizePeerFunc: func(contextMoqParam context.Context, penalizePeerRequest *PenalizePeerRequest) (*emptypb.Empty, error) {
//				panic("mock out the PenalizePeer method")
//			},
//			SendMessageByIdFunc: func(contextMoqParam context.Context, sendMessageByIdRequest *SendMessageByIdRequest) (*SentPeers, error) {
//				panic("mock out the SendMessageById method")
//			},
//			SendMessageByMinBlockFunc: func(contextMoqParam context.Context, sendMessageByMinBlockRequest *SendMessageByMinBlockRequest) (*SentPeers, error) {
//				panic("mock out the SendMessageByMinBlock method")
//			},
//			SendMessageToAllFunc: func(contextMoqParam context.Context, outboundMessageData *OutboundMessageData) (*SentPeers, error) {
//				panic("mock out the SendMessageToAll method")
//			},
//			SendMessageToRandomPeersFunc: func(contextMoqParam context.Context, sendMessageToRandomPeersRequest *SendMessageToRandomPeersRequest) (*SentPeers, error) {
//				panic("mock out the SendMessageToRandomPeers method")
//			},
//			SetStatusFunc: func(contextMoqParam context.Context, statusData *StatusData) (*SetStatusReply, error) {
//				panic("mock out the SetStatus method")
//			},
//			mustEmbedUnimplementedSentryServerFunc: func()  {
//				panic("mock out the mustEmbedUnimplementedSentryServer method")
//			},
//		}
//
//		// use mockedSentryServer in code that requires SentryServer
//		// and then make assertions.
//
//	}
type SentryServerMock struct {
	// AddPeerFunc mocks the AddPeer method.
	AddPeerFunc func(contextMoqParam context.Context, addPeerRequest *AddPeerRequest) (*AddPeerReply, error)

	// HandShakeFunc mocks the HandShake method.
	HandShakeFunc func(contextMoqParam context.Context, empty *emptypb.Empty) (*HandShakeReply, error)

	// MessagesFunc mocks the Messages method.
	MessagesFunc func(messagesRequest *MessagesRequest, sentry_MessagesServer Sentry_MessagesServer) error

	// NodeInfoFunc mocks the NodeInfo method.
	NodeInfoFunc func(contextMoqParam context.Context, empty *emptypb.Empty) (*types.NodeInfoReply, error)

	// PeerByIdFunc mocks the PeerById method.
	PeerByIdFunc func(contextMoqParam context.Context, peerByIdRequest *PeerByIdRequest) (*PeerByIdReply, error)

	// PeerCountFunc mocks the PeerCount method.
	PeerCountFunc func(contextMoqParam context.Context, peerCountRequest *PeerCountRequest) (*PeerCountReply, error)

	// PeerEventsFunc mocks the PeerEvents method.
	PeerEventsFunc func(peerEventsRequest *PeerEventsRequest, sentry_PeerEventsServer Sentry_PeerEventsServer) error

	// PeerMinBlockFunc mocks the PeerMinBlock method.
	PeerMinBlockFunc func(contextMoqParam context.Context, peerMinBlockRequest *PeerMinBlockRequest) (*emptypb.Empty, error)

	// PeersFunc mocks the Peers method.
	PeersFunc func(contextMoqParam context.Context, empty *emptypb.Empty) (*PeersReply, error)

	// PenalizePeerFunc mocks the PenalizePeer method.
	PenalizePeerFunc func(contextMoqParam context.Context, penalizePeerRequest *PenalizePeerRequest) (*emptypb.Empty, error)

	// SendMessageByIdFunc mocks the SendMessageById method.
	SendMessageByIdFunc func(contextMoqParam context.Context, sendMessageByIdRequest *SendMessageByIdRequest) (*SentPeers, error)

	// SendMessageByMinBlockFunc mocks the SendMessageByMinBlock method.
	SendMessageByMinBlockFunc func(contextMoqParam context.Context, sendMessageByMinBlockRequest *SendMessageByMinBlockRequest) (*SentPeers, error)

	// SendMessageToAllFunc mocks the SendMessageToAll method.
	SendMessageToAllFunc func(contextMoqParam context.Context, outboundMessageData *OutboundMessageData) (*SentPeers, error)

	// SendMessageToRandomPeersFunc mocks the SendMessageToRandomPeers method.
	SendMessageToRandomPeersFunc func(contextMoqParam context.Context, sendMessageToRandomPeersRequest *SendMessageToRandomPeersRequest) (*SentPeers, error)

	// SetStatusFunc mocks the SetStatus method.
	SetStatusFunc func(contextMoqParam context.Context, statusData *StatusData) (*SetStatusReply, error)

	// mustEmbedUnimplementedSentryServerFunc mocks the mustEmbedUnimplementedSentryServer method.
	mustEmbedUnimplementedSentryServerFunc func()

	// calls tracks calls to the methods.
	calls struct {
		// AddPeer holds details about calls to the AddPeer method.
		AddPeer []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
			// AddPeerRequest is the addPeerRequest argument value.
			AddPeerRequest *AddPeerRequest
		}
		// HandShake holds details about calls to the HandShake method.
		HandShake []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
			// Empty is the empty argument value.
			Empty *emptypb.Empty
		}
		// Messages holds details about calls to the Messages method.
		Messages []struct {
			// MessagesRequest is the messagesRequest argument value.
			MessagesRequest *MessagesRequest
			// Sentry_MessagesServer is the sentry_MessagesServer argument value.
			Sentry_MessagesServer Sentry_MessagesServer
		}
		// NodeInfo holds details about calls to the NodeInfo method.
		NodeInfo []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
			// Empty is the empty argument value.
			Empty *emptypb.Empty
		}
		// PeerById holds details about calls to the PeerById method.
		PeerById []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
			// PeerByIdRequest is the peerByIdRequest argument value.
			PeerByIdRequest *PeerByIdRequest
		}
		// PeerCount holds details about calls to the PeerCount method.
		PeerCount []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
			// PeerCountRequest is the peerCountRequest argument value.
			PeerCountRequest *PeerCountRequest
		}
		// PeerEvents holds details about calls to the PeerEvents method.
		PeerEvents []struct {
			// PeerEventsRequest is the peerEventsRequest argument value.
			PeerEventsRequest *PeerEventsRequest
			// Sentry_PeerEventsServer is the sentry_PeerEventsServer argument value.
			Sentry_PeerEventsServer Sentry_PeerEventsServer
		}
		// PeerMinBlock holds details about calls to the PeerMinBlock method.
		PeerMinBlock []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
			// PeerMinBlockRequest is the peerMinBlockRequest argument value.
			PeerMinBlockRequest *PeerMinBlockRequest
		}
		// Peers holds details about calls to the Peers method.
		Peers []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
			// Empty is the empty argument value.
			Empty *emptypb.Empty
		}
		// PenalizePeer holds details about calls to the PenalizePeer method.
		PenalizePeer []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
			// PenalizePeerRequest is the penalizePeerRequest argument value.
			PenalizePeerRequest *PenalizePeerRequest
		}
		// SendMessageById holds details about calls to the SendMessageById method.
		SendMessageById []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
			// SendMessageByIdRequest is the sendMessageByIdRequest argument value.
			SendMessageByIdRequest *SendMessageByIdRequest
		}
		// SendMessageByMinBlock holds details about calls to the SendMessageByMinBlock method.
		SendMessageByMinBlock []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
			// SendMessageByMinBlockRequest is the sendMessageByMinBlockRequest argument value.
			SendMessageByMinBlockRequest *SendMessageByMinBlockRequest
		}
		// SendMessageToAll holds details about calls to the SendMessageToAll method.
		SendMessageToAll []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
			// OutboundMessageData is the outboundMessageData argument value.
			OutboundMessageData *OutboundMessageData
		}
		// SendMessageToRandomPeers holds details about calls to the SendMessageToRandomPeers method.
		SendMessageToRandomPeers []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
			// SendMessageToRandomPeersRequest is the sendMessageToRandomPeersRequest argument value.
			SendMessageToRandomPeersRequest *SendMessageToRandomPeersRequest
		}
		// SetStatus holds details about calls to the SetStatus method.
		SetStatus []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
			// StatusData is the statusData argument value.
			StatusData *StatusData
		}
		// mustEmbedUnimplementedSentryServer holds details about calls to the mustEmbedUnimplementedSentryServer method.
		mustEmbedUnimplementedSentryServer []struct {
		}
	}
	lockAddPeer                            sync.RWMutex
	lockHandShake                          sync.RWMutex
	lockMessages                           sync.RWMutex
	lockNodeInfo                           sync.RWMutex
	lockPeerById                           sync.RWMutex
	lockPeerCount                          sync.RWMutex
	lockPeerEvents                         sync.RWMutex
	lockPeerMinBlock                       sync.RWMutex
	lockPeers                              sync.RWMutex
	lockPenalizePeer                       sync.RWMutex
	lockSendMessageById                    sync.RWMutex
	lockSendMessageByMinBlock              sync.RWMutex
	lockSendMessageToAll                   sync.RWMutex
	lockSendMessageToRandomPeers           sync.RWMutex
	lockSetStatus                          sync.RWMutex
	lockmustEmbedUnimplementedSentryServer sync.RWMutex
}

// AddPeer calls AddPeerFunc.
func (mock *SentryServerMock) AddPeer(contextMoqParam context.Context, addPeerRequest *AddPeerRequest) (*AddPeerReply, error) {
	callInfo := struct {
		ContextMoqParam context.Context
		AddPeerRequest  *AddPeerRequest
	}{
		ContextMoqParam: contextMoqParam,
		AddPeerRequest:  addPeerRequest,
	}
	mock.lockAddPeer.Lock()
	mock.calls.AddPeer = append(mock.calls.AddPeer, callInfo)
	mock.lockAddPeer.Unlock()
	if mock.AddPeerFunc == nil {
		var (
			addPeerReplyOut *AddPeerReply
			errOut          error
		)
		return addPeerReplyOut, errOut
	}
	return mock.AddPeerFunc(contextMoqParam, addPeerRequest)
}

// AddPeerCalls gets all the calls that were made to AddPeer.
// Check the length with:
//
//	len(mockedSentryServer.AddPeerCalls())
func (mock *SentryServerMock) AddPeerCalls() []struct {
	ContextMoqParam context.Context
	AddPeerRequest  *AddPeerRequest
} {
	var calls []struct {
		ContextMoqParam context.Context
		AddPeerRequest  *AddPeerRequest
	}
	mock.lockAddPeer.RLock()
	calls = mock.calls.AddPeer
	mock.lockAddPeer.RUnlock()
	return calls
}

// HandShake calls HandShakeFunc.
func (mock *SentryServerMock) HandShake(contextMoqParam context.Context, empty *emptypb.Empty) (*HandShakeReply, error) {
	callInfo := struct {
		ContextMoqParam context.Context
		Empty           *emptypb.Empty
	}{
		ContextMoqParam: contextMoqParam,
		Empty:           empty,
	}
	mock.lockHandShake.Lock()
	mock.calls.HandShake = append(mock.calls.HandShake, callInfo)
	mock.lockHandShake.Unlock()
	if mock.HandShakeFunc == nil {
		var (
			handShakeReplyOut *HandShakeReply
			errOut            error
		)
		return handShakeReplyOut, errOut
	}
	return mock.HandShakeFunc(contextMoqParam, empty)
}

// HandShakeCalls gets all the calls that were made to HandShake.
// Check the length with:
//
//	len(mockedSentryServer.HandShakeCalls())
func (mock *SentryServerMock) HandShakeCalls() []struct {
	ContextMoqParam context.Context
	Empty           *emptypb.Empty
} {
	var calls []struct {
		ContextMoqParam context.Context
		Empty           *emptypb.Empty
	}
	mock.lockHandShake.RLock()
	calls = mock.calls.HandShake
	mock.lockHandShake.RUnlock()
	return calls
}

// Messages calls MessagesFunc.
func (mock *SentryServerMock) Messages(messagesRequest *MessagesRequest, sentry_MessagesServer Sentry_MessagesServer) error {
	callInfo := struct {
		MessagesRequest       *MessagesRequest
		Sentry_MessagesServer Sentry_MessagesServer
	}{
		MessagesRequest:       messagesRequest,
		Sentry_MessagesServer: sentry_MessagesServer,
	}
	mock.lockMessages.Lock()
	mock.calls.Messages = append(mock.calls.Messages, callInfo)
	mock.lockMessages.Unlock()
	if mock.MessagesFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.MessagesFunc(messagesRequest, sentry_MessagesServer)
}

// MessagesCalls gets all the calls that were made to Messages.
// Check the length with:
//
//	len(mockedSentryServer.MessagesCalls())
func (mock *SentryServerMock) MessagesCalls() []struct {
	MessagesRequest       *MessagesRequest
	Sentry_MessagesServer Sentry_MessagesServer
} {
	var calls []struct {
		MessagesRequest       *MessagesRequest
		Sentry_MessagesServer Sentry_MessagesServer
	}
	mock.lockMessages.RLock()
	calls = mock.calls.Messages
	mock.lockMessages.RUnlock()
	return calls
}

// NodeInfo calls NodeInfoFunc.
func (mock *SentryServerMock) NodeInfo(contextMoqParam context.Context, empty *emptypb.Empty) (*types.NodeInfoReply, error) {
	callInfo := struct {
		ContextMoqParam context.Context
		Empty           *emptypb.Empty
	}{
		ContextMoqParam: contextMoqParam,
		Empty:           empty,
	}
	mock.lockNodeInfo.Lock()
	mock.calls.NodeInfo = append(mock.calls.NodeInfo, callInfo)
	mock.lockNodeInfo.Unlock()
	if mock.NodeInfoFunc == nil {
		var (
			nodeInfoReplyOut *types.NodeInfoReply
			errOut           error
		)
		return nodeInfoReplyOut, errOut
	}
	return mock.NodeInfoFunc(contextMoqParam, empty)
}

// NodeInfoCalls gets all the calls that were made to NodeInfo.
// Check the length with:
//
//	len(mockedSentryServer.NodeInfoCalls())
func (mock *SentryServerMock) NodeInfoCalls() []struct {
	ContextMoqParam context.Context
	Empty           *emptypb.Empty
} {
	var calls []struct {
		ContextMoqParam context.Context
		Empty           *emptypb.Empty
	}
	mock.lockNodeInfo.RLock()
	calls = mock.calls.NodeInfo
	mock.lockNodeInfo.RUnlock()
	return calls
}

// PeerById calls PeerByIdFunc.
func (mock *SentryServerMock) PeerById(contextMoqParam context.Context, peerByIdRequest *PeerByIdRequest) (*PeerByIdReply, error) {
	callInfo := struct {
		ContextMoqParam context.Context
		PeerByIdRequest *PeerByIdRequest
	}{
		ContextMoqParam: contextMoqParam,
		PeerByIdRequest: peerByIdRequest,
	}
	mock.lockPeerById.Lock()
	mock.calls.PeerById = append(mock.calls.PeerById, callInfo)
	mock.lockPeerById.Unlock()
	if mock.PeerByIdFunc == nil {
		var (
			peerByIdReplyOut *PeerByIdReply
			errOut           error
		)
		return peerByIdReplyOut, errOut
	}
	return mock.PeerByIdFunc(contextMoqParam, peerByIdRequest)
}

// PeerByIdCalls gets all the calls that were made to PeerById.
// Check the length with:
//
//	len(mockedSentryServer.PeerByIdCalls())
func (mock *SentryServerMock) PeerByIdCalls() []struct {
	ContextMoqParam context.Context
	PeerByIdRequest *PeerByIdRequest
} {
	var calls []struct {
		ContextMoqParam context.Context
		PeerByIdRequest *PeerByIdRequest
	}
	mock.lockPeerById.RLock()
	calls = mock.calls.PeerById
	mock.lockPeerById.RUnlock()
	return calls
}

// PeerCount calls PeerCountFunc.
func (mock *SentryServerMock) PeerCount(contextMoqParam context.Context, peerCountRequest *PeerCountRequest) (*PeerCountReply, error) {
	callInfo := struct {
		ContextMoqParam  context.Context
		PeerCountRequest *PeerCountRequest
	}{
		ContextMoqParam:  contextMoqParam,
		PeerCountRequest: peerCountRequest,
	}
	mock.lockPeerCount.Lock()
	mock.calls.PeerCount = append(mock.calls.PeerCount, callInfo)
	mock.lockPeerCount.Unlock()
	if mock.PeerCountFunc == nil {
		var (
			peerCountReplyOut *PeerCountReply
			errOut            error
		)
		return peerCountReplyOut, errOut
	}
	return mock.PeerCountFunc(contextMoqParam, peerCountRequest)
}

// PeerCountCalls gets all the calls that were made to PeerCount.
// Check the length with:
//
//	len(mockedSentryServer.PeerCountCalls())
func (mock *SentryServerMock) PeerCountCalls() []struct {
	ContextMoqParam  context.Context
	PeerCountRequest *PeerCountRequest
} {
	var calls []struct {
		ContextMoqParam  context.Context
		PeerCountRequest *PeerCountRequest
	}
	mock.lockPeerCount.RLock()
	calls = mock.calls.PeerCount
	mock.lockPeerCount.RUnlock()
	return calls
}

// PeerEvents calls PeerEventsFunc.
func (mock *SentryServerMock) PeerEvents(peerEventsRequest *PeerEventsRequest, sentry_PeerEventsServer Sentry_PeerEventsServer) error {
	callInfo := struct {
		PeerEventsRequest       *PeerEventsRequest
		Sentry_PeerEventsServer Sentry_PeerEventsServer
	}{
		PeerEventsRequest:       peerEventsRequest,
		Sentry_PeerEventsServer: sentry_PeerEventsServer,
	}
	mock.lockPeerEvents.Lock()
	mock.calls.PeerEvents = append(mock.calls.PeerEvents, callInfo)
	mock.lockPeerEvents.Unlock()
	if mock.PeerEventsFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.PeerEventsFunc(peerEventsRequest, sentry_PeerEventsServer)
}

// PeerEventsCalls gets all the calls that were made to PeerEvents.
// Check the length with:
//
//	len(mockedSentryServer.PeerEventsCalls())
func (mock *SentryServerMock) PeerEventsCalls() []struct {
	PeerEventsRequest       *PeerEventsRequest
	Sentry_PeerEventsServer Sentry_PeerEventsServer
} {
	var calls []struct {
		PeerEventsRequest       *PeerEventsRequest
		Sentry_PeerEventsServer Sentry_PeerEventsServer
	}
	mock.lockPeerEvents.RLock()
	calls = mock.calls.PeerEvents
	mock.lockPeerEvents.RUnlock()
	return calls
}

// PeerMinBlock calls PeerMinBlockFunc.
func (mock *SentryServerMock) PeerMinBlock(contextMoqParam context.Context, peerMinBlockRequest *PeerMinBlockRequest) (*emptypb.Empty, error) {
	callInfo := struct {
		ContextMoqParam     context.Context
		PeerMinBlockRequest *PeerMinBlockRequest
	}{
		ContextMoqParam:     contextMoqParam,
		PeerMinBlockRequest: peerMinBlockRequest,
	}
	mock.lockPeerMinBlock.Lock()
	mock.calls.PeerMinBlock = append(mock.calls.PeerMinBlock, callInfo)
	mock.lockPeerMinBlock.Unlock()
	if mock.PeerMinBlockFunc == nil {
		var (
			emptyOut *emptypb.Empty
			errOut   error
		)
		return emptyOut, errOut
	}
	return mock.PeerMinBlockFunc(contextMoqParam, peerMinBlockRequest)
}

// PeerMinBlockCalls gets all the calls that were made to PeerMinBlock.
// Check the length with:
//
//	len(mockedSentryServer.PeerMinBlockCalls())
func (mock *SentryServerMock) PeerMinBlockCalls() []struct {
	ContextMoqParam     context.Context
	PeerMinBlockRequest *PeerMinBlockRequest
} {
	var calls []struct {
		ContextMoqParam     context.Context
		PeerMinBlockRequest *PeerMinBlockRequest
	}
	mock.lockPeerMinBlock.RLock()
	calls = mock.calls.PeerMinBlock
	mock.lockPeerMinBlock.RUnlock()
	return calls
}

// Peers calls PeersFunc.
func (mock *SentryServerMock) Peers(contextMoqParam context.Context, empty *emptypb.Empty) (*PeersReply, error) {
	callInfo := struct {
		ContextMoqParam context.Context
		Empty           *emptypb.Empty
	}{
		ContextMoqParam: contextMoqParam,
		Empty:           empty,
	}
	mock.lockPeers.Lock()
	mock.calls.Peers = append(mock.calls.Peers, callInfo)
	mock.lockPeers.Unlock()
	if mock.PeersFunc == nil {
		var (
			peersReplyOut *PeersReply
			errOut        error
		)
		return peersReplyOut, errOut
	}
	return mock.PeersFunc(contextMoqParam, empty)
}

// PeersCalls gets all the calls that were made to Peers.
// Check the length with:
//
//	len(mockedSentryServer.PeersCalls())
func (mock *SentryServerMock) PeersCalls() []struct {
	ContextMoqParam context.Context
	Empty           *emptypb.Empty
} {
	var calls []struct {
		ContextMoqParam context.Context
		Empty           *emptypb.Empty
	}
	mock.lockPeers.RLock()
	calls = mock.calls.Peers
	mock.lockPeers.RUnlock()
	return calls
}

// PenalizePeer calls PenalizePeerFunc.
func (mock *SentryServerMock) PenalizePeer(contextMoqParam context.Context, penalizePeerRequest *PenalizePeerRequest) (*emptypb.Empty, error) {
	callInfo := struct {
		ContextMoqParam     context.Context
		PenalizePeerRequest *PenalizePeerRequest
	}{
		ContextMoqParam:     contextMoqParam,
		PenalizePeerRequest: penalizePeerRequest,
	}
	mock.lockPenalizePeer.Lock()
	mock.calls.PenalizePeer = append(mock.calls.PenalizePeer, callInfo)
	mock.lockPenalizePeer.Unlock()
	if mock.PenalizePeerFunc == nil {
		var (
			emptyOut *emptypb.Empty
			errOut   error
		)
		return emptyOut, errOut
	}
	return mock.PenalizePeerFunc(contextMoqParam, penalizePeerRequest)
}

// PenalizePeerCalls gets all the calls that were made to PenalizePeer.
// Check the length with:
//
//	len(mockedSentryServer.PenalizePeerCalls())
func (mock *SentryServerMock) PenalizePeerCalls() []struct {
	ContextMoqParam     context.Context
	PenalizePeerRequest *PenalizePeerRequest
} {
	var calls []struct {
		ContextMoqParam     context.Context
		PenalizePeerRequest *PenalizePeerRequest
	}
	mock.lockPenalizePeer.RLock()
	calls = mock.calls.PenalizePeer
	mock.lockPenalizePeer.RUnlock()
	return calls
}

// SendMessageById calls SendMessageByIdFunc.
func (mock *SentryServerMock) SendMessageById(contextMoqParam context.Context, sendMessageByIdRequest *SendMessageByIdRequest) (*SentPeers, error) {
	callInfo := struct {
		ContextMoqParam        context.Context
		SendMessageByIdRequest *SendMessageByIdRequest
	}{
		ContextMoqParam:        contextMoqParam,
		SendMessageByIdRequest: sendMessageByIdRequest,
	}
	mock.lockSendMessageById.Lock()
	mock.calls.SendMessageById = append(mock.calls.SendMessageById, callInfo)
	mock.lockSendMessageById.Unlock()
	if mock.SendMessageByIdFunc == nil {
		var (
			sentPeersOut *SentPeers
			errOut       error
		)
		return sentPeersOut, errOut
	}
	return mock.SendMessageByIdFunc(contextMoqParam, sendMessageByIdRequest)
}

// SendMessageByIdCalls gets all the calls that were made to SendMessageById.
// Check the length with:
//
//	len(mockedSentryServer.SendMessageByIdCalls())
func (mock *SentryServerMock) SendMessageByIdCalls() []struct {
	ContextMoqParam        context.Context
	SendMessageByIdRequest *SendMessageByIdRequest
} {
	var calls []struct {
		ContextMoqParam        context.Context
		SendMessageByIdRequest *SendMessageByIdRequest
	}
	mock.lockSendMessageById.RLock()
	calls = mock.calls.SendMessageById
	mock.lockSendMessageById.RUnlock()
	return calls
}

// SendMessageByMinBlock calls SendMessageByMinBlockFunc.
func (mock *SentryServerMock) SendMessageByMinBlock(contextMoqParam context.Context, sendMessageByMinBlockRequest *SendMessageByMinBlockRequest) (*SentPeers, error) {
	callInfo := struct {
		ContextMoqParam              context.Context
		SendMessageByMinBlockRequest *SendMessageByMinBlockRequest
	}{
		ContextMoqParam:              contextMoqParam,
		SendMessageByMinBlockRequest: sendMessageByMinBlockRequest,
	}
	mock.lockSendMessageByMinBlock.Lock()
	mock.calls.SendMessageByMinBlock = append(mock.calls.SendMessageByMinBlock, callInfo)
	mock.lockSendMessageByMinBlock.Unlock()
	if mock.SendMessageByMinBlockFunc == nil {
		var (
			sentPeersOut *SentPeers
			errOut       error
		)
		return sentPeersOut, errOut
	}
	return mock.SendMessageByMinBlockFunc(contextMoqParam, sendMessageByMinBlockRequest)
}

// SendMessageByMinBlockCalls gets all the calls that were made to SendMessageByMinBlock.
// Check the length with:
//
//	len(mockedSentryServer.SendMessageByMinBlockCalls())
func (mock *SentryServerMock) SendMessageByMinBlockCalls() []struct {
	ContextMoqParam              context.Context
	SendMessageByMinBlockRequest *SendMessageByMinBlockRequest
} {
	var calls []struct {
		ContextMoqParam              context.Context
		SendMessageByMinBlockRequest *SendMessageByMinBlockRequest
	}
	mock.lockSendMessageByMinBlock.RLock()
	calls = mock.calls.SendMessageByMinBlock
	mock.lockSendMessageByMinBlock.RUnlock()
	return calls
}

// SendMessageToAll calls SendMessageToAllFunc.
func (mock *SentryServerMock) SendMessageToAll(contextMoqParam context.Context, outboundMessageData *OutboundMessageData) (*SentPeers, error) {
	callInfo := struct {
		ContextMoqParam     context.Context
		OutboundMessageData *OutboundMessageData
	}{
		ContextMoqParam:     contextMoqParam,
		OutboundMessageData: outboundMessageData,
	}
	mock.lockSendMessageToAll.Lock()
	mock.calls.SendMessageToAll = append(mock.calls.SendMessageToAll, callInfo)
	mock.lockSendMessageToAll.Unlock()
	if mock.SendMessageToAllFunc == nil {
		var (
			sentPeersOut *SentPeers
			errOut       error
		)
		return sentPeersOut, errOut
	}
	return mock.SendMessageToAllFunc(contextMoqParam, outboundMessageData)
}

// SendMessageToAllCalls gets all the calls that were made to SendMessageToAll.
// Check the length with:
//
//	len(mockedSentryServer.SendMessageToAllCalls())
func (mock *SentryServerMock) SendMessageToAllCalls() []struct {
	ContextMoqParam     context.Context
	OutboundMessageData *OutboundMessageData
} {
	var calls []struct {
		ContextMoqParam     context.Context
		OutboundMessageData *OutboundMessageData
	}
	mock.lockSendMessageToAll.RLock()
	calls = mock.calls.SendMessageToAll
	mock.lockSendMessageToAll.RUnlock()
	return calls
}

// SendMessageToRandomPeers calls SendMessageToRandomPeersFunc.
func (mock *SentryServerMock) SendMessageToRandomPeers(contextMoqParam context.Context, sendMessageToRandomPeersRequest *SendMessageToRandomPeersRequest) (*SentPeers, error) {
	callInfo := struct {
		ContextMoqParam                 context.Context
		SendMessageToRandomPeersRequest *SendMessageToRandomPeersRequest
	}{
		ContextMoqParam:                 contextMoqParam,
		SendMessageToRandomPeersRequest: sendMessageToRandomPeersRequest,
	}
	mock.lockSendMessageToRandomPeers.Lock()
	mock.calls.SendMessageToRandomPeers = append(mock.calls.SendMessageToRandomPeers, callInfo)
	mock.lockSendMessageToRandomPeers.Unlock()
	if mock.SendMessageToRandomPeersFunc == nil {
		var (
			sentPeersOut *SentPeers
			errOut       error
		)
		return sentPeersOut, errOut
	}
	return mock.SendMessageToRandomPeersFunc(contextMoqParam, sendMessageToRandomPeersRequest)
}

// SendMessageToRandomPeersCalls gets all the calls that were made to SendMessageToRandomPeers.
// Check the length with:
//
//	len(mockedSentryServer.SendMessageToRandomPeersCalls())
func (mock *SentryServerMock) SendMessageToRandomPeersCalls() []struct {
	ContextMoqParam                 context.Context
	SendMessageToRandomPeersRequest *SendMessageToRandomPeersRequest
} {
	var calls []struct {
		ContextMoqParam                 context.Context
		SendMessageToRandomPeersRequest *SendMessageToRandomPeersRequest
	}
	mock.lockSendMessageToRandomPeers.RLock()
	calls = mock.calls.SendMessageToRandomPeers
	mock.lockSendMessageToRandomPeers.RUnlock()
	return calls
}

// SetStatus calls SetStatusFunc.
func (mock *SentryServerMock) SetStatus(contextMoqParam context.Context, statusData *StatusData) (*SetStatusReply, error) {
	callInfo := struct {
		ContextMoqParam context.Context
		StatusData      *StatusData
	}{
		ContextMoqParam: contextMoqParam,
		StatusData:      statusData,
	}
	mock.lockSetStatus.Lock()
	mock.calls.SetStatus = append(mock.calls.SetStatus, callInfo)
	mock.lockSetStatus.Unlock()
	if mock.SetStatusFunc == nil {
		var (
			setStatusReplyOut *SetStatusReply
			errOut            error
		)
		return setStatusReplyOut, errOut
	}
	return mock.SetStatusFunc(contextMoqParam, statusData)
}

// SetStatusCalls gets all the calls that were made to SetStatus.
// Check the length with:
//
//	len(mockedSentryServer.SetStatusCalls())
func (mock *SentryServerMock) SetStatusCalls() []struct {
	ContextMoqParam context.Context
	StatusData      *StatusData
} {
	var calls []struct {
		ContextMoqParam context.Context
		StatusData      *StatusData
	}
	mock.lockSetStatus.RLock()
	calls = mock.calls.SetStatus
	mock.lockSetStatus.RUnlock()
	return calls
}

// mustEmbedUnimplementedSentryServer calls mustEmbedUnimplementedSentryServerFunc.
func (mock *SentryServerMock) mustEmbedUnimplementedSentryServer() {
	callInfo := struct {
	}{}
	mock.lockmustEmbedUnimplementedSentryServer.Lock()
	mock.calls.mustEmbedUnimplementedSentryServer = append(mock.calls.mustEmbedUnimplementedSentryServer, callInfo)
	mock.lockmustEmbedUnimplementedSentryServer.Unlock()
	if mock.mustEmbedUnimplementedSentryServerFunc == nil {
		return
	}
	mock.mustEmbedUnimplementedSentryServerFunc()
}

// mustEmbedUnimplementedSentryServerCalls gets all the calls that were made to mustEmbedUnimplementedSentryServer.
// Check the length with:
//
//	len(mockedSentryServer.mustEmbedUnimplementedSentryServerCalls())
func (mock *SentryServerMock) mustEmbedUnimplementedSentryServerCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockmustEmbedUnimplementedSentryServer.RLock()
	calls = mock.calls.mustEmbedUnimplementedSentryServer
	mock.lockmustEmbedUnimplementedSentryServer.RUnlock()
	return calls
}

// Ensure, that SentryClientMock does implement SentryClient.
// If this is not the case, regenerate this file with moq.
var _ SentryClient = &SentryClientMock{}

// SentryClientMock is a mock implementation of SentryClient.
//
//	func TestSomethingThatUsesSentryClient(t *testing.T) {
//
//		// make and configure a mocked SentryClient
//		mockedSentryClient := &SentryClientMock{
//			AddPeerFunc: func(ctx context.Context, in *AddPeerRequest, opts ...grpc.CallOption) (*AddPeerReply, error) {
//				panic("mock out the AddPeer method")
//			},
//			HandShakeFunc: func(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*HandShakeReply, error) {
//				panic("mock out the HandShake method")
//			},
//			MessagesFunc: func(ctx context.Context, in *MessagesRequest, opts ...grpc.CallOption) (Sentry_MessagesClient, error) {
//				panic("mock out the Messages method")
//			},
//			NodeInfoFunc: func(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*types.NodeInfoReply, error) {
//				panic("mock out the NodeInfo method")
//			},
//			PeerByIdFunc: func(ctx context.Context, in *PeerByIdRequest, opts ...grpc.CallOption) (*PeerByIdReply, error) {
//				panic("mock out the PeerById method")
//			},
//			PeerCountFunc: func(ctx context.Context, in *PeerCountRequest, opts ...grpc.CallOption) (*PeerCountReply, error) {
//				panic("mock out the PeerCount method")
//			},
//			PeerEventsFunc: func(ctx context.Context, in *PeerEventsRequest, opts ...grpc.CallOption) (Sentry_PeerEventsClient, error) {
//				panic("mock out the PeerEvents method")
//			},
//			PeerMinBlockFunc: func(ctx context.Context, in *PeerMinBlockRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
//				panic("mock out the PeerMinBlock method")
//			},
//			PeersFunc: func(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*PeersReply, error) {
//				panic("mock out the Peers method")
//			},
//			PenalizePeerFunc: func(ctx context.Context, in *PenalizePeerRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
//				panic("mock out the PenalizePeer method")
//			},
//			SendMessageByIdFunc: func(ctx context.Context, in *SendMessageByIdRequest, opts ...grpc.CallOption) (*SentPeers, error) {
//				panic("mock out the SendMessageById method")
//			},
//			SendMessageByMinBlockFunc: func(ctx context.Context, in *SendMessageByMinBlockRequest, opts ...grpc.CallOption) (*SentPeers, error) {
//				panic("mock out the SendMessageByMinBlock method")
//			},
//			SendMessageToAllFunc: func(ctx context.Context, in *OutboundMessageData, opts ...grpc.CallOption) (*SentPeers, error) {
//				panic("mock out the SendMessageToAll method")
//			},
//			SendMessageToRandomPeersFunc: func(ctx context.Context, in *SendMessageToRandomPeersRequest, opts ...grpc.CallOption) (*SentPeers, error) {
//				panic("mock out the SendMessageToRandomPeers method")
//			},
//			SetStatusFunc: func(ctx context.Context, in *StatusData, opts ...grpc.CallOption) (*SetStatusReply, error) {
//				panic("mock out the SetStatus method")
//			},
//		}
//
//		// use mockedSentryClient in code that requires SentryClient
//		// and then make assertions.
//
//	}
type SentryClientMock struct {
	// AddPeerFunc mocks the AddPeer method.
	AddPeerFunc func(ctx context.Context, in *AddPeerRequest, opts ...grpc.CallOption) (*AddPeerReply, error)

	// HandShakeFunc mocks the HandShake method.
	HandShakeFunc func(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*HandShakeReply, error)

	// MessagesFunc mocks the Messages method.
	MessagesFunc func(ctx context.Context, in *MessagesRequest, opts ...grpc.CallOption) (Sentry_MessagesClient, error)

	// NodeInfoFunc mocks the NodeInfo method.
	NodeInfoFunc func(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*types.NodeInfoReply, error)

	// PeerByIdFunc mocks the PeerById method.
	PeerByIdFunc func(ctx context.Context, in *PeerByIdRequest, opts ...grpc.CallOption) (*PeerByIdReply, error)

	// PeerCountFunc mocks the PeerCount method.
	PeerCountFunc func(ctx context.Context, in *PeerCountRequest, opts ...grpc.CallOption) (*PeerCountReply, error)

	// PeerEventsFunc mocks the PeerEvents method.
	PeerEventsFunc func(ctx context.Context, in *PeerEventsRequest, opts ...grpc.CallOption) (Sentry_PeerEventsClient, error)

	// PeerMinBlockFunc mocks the PeerMinBlock method.
	PeerMinBlockFunc func(ctx context.Context, in *PeerMinBlockRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)

	// PeersFunc mocks the Peers method.
	PeersFunc func(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*PeersReply, error)

	// PenalizePeerFunc mocks the PenalizePeer method.
	PenalizePeerFunc func(ctx context.Context, in *PenalizePeerRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)

	// SendMessageByIdFunc mocks the SendMessageById method.
	SendMessageByIdFunc func(ctx context.Context, in *SendMessageByIdRequest, opts ...grpc.CallOption) (*SentPeers, error)

	// SendMessageByMinBlockFunc mocks the SendMessageByMinBlock method.
	SendMessageByMinBlockFunc func(ctx context.Context, in *SendMessageByMinBlockRequest, opts ...grpc.CallOption) (*SentPeers, error)

	// SendMessageToAllFunc mocks the SendMessageToAll method.
	SendMessageToAllFunc func(ctx context.Context, in *OutboundMessageData, opts ...grpc.CallOption) (*SentPeers, error)

	// SendMessageToRandomPeersFunc mocks the SendMessageToRandomPeers method.
	SendMessageToRandomPeersFunc func(ctx context.Context, in *SendMessageToRandomPeersRequest, opts ...grpc.CallOption) (*SentPeers, error)

	// SetStatusFunc mocks the SetStatus method.
	SetStatusFunc func(ctx context.Context, in *StatusData, opts ...grpc.CallOption) (*SetStatusReply, error)

	// calls tracks calls to the methods.
	calls struct {
		// AddPeer holds details about calls to the AddPeer method.
		AddPeer []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *AddPeerRequest
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
		// HandShake holds details about calls to the HandShake method.
		HandShake []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *emptypb.Empty
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
		// Messages holds details about calls to the Messages method.
		Messages []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *MessagesRequest
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
		// NodeInfo holds details about calls to the NodeInfo method.
		NodeInfo []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *emptypb.Empty
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
		// PeerById holds details about calls to the PeerById method.
		PeerById []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *PeerByIdRequest
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
		// PeerCount holds details about calls to the PeerCount method.
		PeerCount []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *PeerCountRequest
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
		// PeerEvents holds details about calls to the PeerEvents method.
		PeerEvents []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *PeerEventsRequest
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
		// PeerMinBlock holds details about calls to the PeerMinBlock method.
		PeerMinBlock []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *PeerMinBlockRequest
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
		// Peers holds details about calls to the Peers method.
		Peers []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *emptypb.Empty
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
		// PenalizePeer holds details about calls to the PenalizePeer method.
		PenalizePeer []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *PenalizePeerRequest
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
		// SendMessageById holds details about calls to the SendMessageById method.
		SendMessageById []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *SendMessageByIdRequest
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
		// SendMessageByMinBlock holds details about calls to the SendMessageByMinBlock method.
		SendMessageByMinBlock []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *SendMessageByMinBlockRequest
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
		// SendMessageToAll holds details about calls to the SendMessageToAll method.
		SendMessageToAll []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *OutboundMessageData
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
		// SendMessageToRandomPeers holds details about calls to the SendMessageToRandomPeers method.
		SendMessageToRandomPeers []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *SendMessageToRandomPeersRequest
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
		// SetStatus holds details about calls to the SetStatus method.
		SetStatus []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *StatusData
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
	}
	lockAddPeer                  sync.RWMutex
	lockHandShake                sync.RWMutex
	lockMessages                 sync.RWMutex
	lockNodeInfo                 sync.RWMutex
	lockPeerById                 sync.RWMutex
	lockPeerCount                sync.RWMutex
	lockPeerEvents               sync.RWMutex
	lockPeerMinBlock             sync.RWMutex
	lockPeers                    sync.RWMutex
	lockPenalizePeer             sync.RWMutex
	lockSendMessageById          sync.RWMutex
	lockSendMessageByMinBlock    sync.RWMutex
	lockSendMessageToAll         sync.RWMutex
	lockSendMessageToRandomPeers sync.RWMutex
	lockSetStatus                sync.RWMutex
}

// AddPeer calls AddPeerFunc.
func (mock *SentryClientMock) AddPeer(ctx context.Context, in *AddPeerRequest, opts ...grpc.CallOption) (*AddPeerReply, error) {
	callInfo := struct {
		Ctx  context.Context
		In   *AddPeerRequest
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockAddPeer.Lock()
	mock.calls.AddPeer = append(mock.calls.AddPeer, callInfo)
	mock.lockAddPeer.Unlock()
	if mock.AddPeerFunc == nil {
		var (
			addPeerReplyOut *AddPeerReply
			errOut          error
		)
		return addPeerReplyOut, errOut
	}
	return mock.AddPeerFunc(ctx, in, opts...)
}

// AddPeerCalls gets all the calls that were made to AddPeer.
// Check the length with:
//
//	len(mockedSentryClient.AddPeerCalls())
func (mock *SentryClientMock) AddPeerCalls() []struct {
	Ctx  context.Context
	In   *AddPeerRequest
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *AddPeerRequest
		Opts []grpc.CallOption
	}
	mock.lockAddPeer.RLock()
	calls = mock.calls.AddPeer
	mock.lockAddPeer.RUnlock()
	return calls
}

// HandShake calls HandShakeFunc.
func (mock *SentryClientMock) HandShake(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*HandShakeReply, error) {
	callInfo := struct {
		Ctx  context.Context
		In   *emptypb.Empty
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockHandShake.Lock()
	mock.calls.HandShake = append(mock.calls.HandShake, callInfo)
	mock.lockHandShake.Unlock()
	if mock.HandShakeFunc == nil {
		var (
			handShakeReplyOut *HandShakeReply
			errOut            error
		)
		return handShakeReplyOut, errOut
	}
	return mock.HandShakeFunc(ctx, in, opts...)
}

// HandShakeCalls gets all the calls that were made to HandShake.
// Check the length with:
//
//	len(mockedSentryClient.HandShakeCalls())
func (mock *SentryClientMock) HandShakeCalls() []struct {
	Ctx  context.Context
	In   *emptypb.Empty
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *emptypb.Empty
		Opts []grpc.CallOption
	}
	mock.lockHandShake.RLock()
	calls = mock.calls.HandShake
	mock.lockHandShake.RUnlock()
	return calls
}

// Messages calls MessagesFunc.
func (mock *SentryClientMock) Messages(ctx context.Context, in *MessagesRequest, opts ...grpc.CallOption) (Sentry_MessagesClient, error) {
	callInfo := struct {
		Ctx  context.Context
		In   *MessagesRequest
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockMessages.Lock()
	mock.calls.Messages = append(mock.calls.Messages, callInfo)
	mock.lockMessages.Unlock()
	if mock.MessagesFunc == nil {
		var (
			sentry_MessagesClientOut Sentry_MessagesClient
			errOut                   error
		)
		return sentry_MessagesClientOut, errOut
	}
	return mock.MessagesFunc(ctx, in, opts...)
}

// MessagesCalls gets all the calls that were made to Messages.
// Check the length with:
//
//	len(mockedSentryClient.MessagesCalls())
func (mock *SentryClientMock) MessagesCalls() []struct {
	Ctx  context.Context
	In   *MessagesRequest
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *MessagesRequest
		Opts []grpc.CallOption
	}
	mock.lockMessages.RLock()
	calls = mock.calls.Messages
	mock.lockMessages.RUnlock()
	return calls
}

// NodeInfo calls NodeInfoFunc.
func (mock *SentryClientMock) NodeInfo(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*types.NodeInfoReply, error) {
	callInfo := struct {
		Ctx  context.Context
		In   *emptypb.Empty
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockNodeInfo.Lock()
	mock.calls.NodeInfo = append(mock.calls.NodeInfo, callInfo)
	mock.lockNodeInfo.Unlock()
	if mock.NodeInfoFunc == nil {
		var (
			nodeInfoReplyOut *types.NodeInfoReply
			errOut           error
		)
		return nodeInfoReplyOut, errOut
	}
	return mock.NodeInfoFunc(ctx, in, opts...)
}

// NodeInfoCalls gets all the calls that were made to NodeInfo.
// Check the length with:
//
//	len(mockedSentryClient.NodeInfoCalls())
func (mock *SentryClientMock) NodeInfoCalls() []struct {
	Ctx  context.Context
	In   *emptypb.Empty
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *emptypb.Empty
		Opts []grpc.CallOption
	}
	mock.lockNodeInfo.RLock()
	calls = mock.calls.NodeInfo
	mock.lockNodeInfo.RUnlock()
	return calls
}

// PeerById calls PeerByIdFunc.
func (mock *SentryClientMock) PeerById(ctx context.Context, in *PeerByIdRequest, opts ...grpc.CallOption) (*PeerByIdReply, error) {
	callInfo := struct {
		Ctx  context.Context
		In   *PeerByIdRequest
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockPeerById.Lock()
	mock.calls.PeerById = append(mock.calls.PeerById, callInfo)
	mock.lockPeerById.Unlock()
	if mock.PeerByIdFunc == nil {
		var (
			peerByIdReplyOut *PeerByIdReply
			errOut           error
		)
		return peerByIdReplyOut, errOut
	}
	return mock.PeerByIdFunc(ctx, in, opts...)
}

// PeerByIdCalls gets all the calls that were made to PeerById.
// Check the length with:
//
//	len(mockedSentryClient.PeerByIdCalls())
func (mock *SentryClientMock) PeerByIdCalls() []struct {
	Ctx  context.Context
	In   *PeerByIdRequest
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *PeerByIdRequest
		Opts []grpc.CallOption
	}
	mock.lockPeerById.RLock()
	calls = mock.calls.PeerById
	mock.lockPeerById.RUnlock()
	return calls
}

// PeerCount calls PeerCountFunc.
func (mock *SentryClientMock) PeerCount(ctx context.Context, in *PeerCountRequest, opts ...grpc.CallOption) (*PeerCountReply, error) {
	callInfo := struct {
		Ctx  context.Context
		In   *PeerCountRequest
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockPeerCount.Lock()
	mock.calls.PeerCount = append(mock.calls.PeerCount, callInfo)
	mock.lockPeerCount.Unlock()
	if mock.PeerCountFunc == nil {
		var (
			peerCountReplyOut *PeerCountReply
			errOut            error
		)
		return peerCountReplyOut, errOut
	}
	return mock.PeerCountFunc(ctx, in, opts...)
}

// PeerCountCalls gets all the calls that were made to PeerCount.
// Check the length with:
//
//	len(mockedSentryClient.PeerCountCalls())
func (mock *SentryClientMock) PeerCountCalls() []struct {
	Ctx  context.Context
	In   *PeerCountRequest
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *PeerCountRequest
		Opts []grpc.CallOption
	}
	mock.lockPeerCount.RLock()
	calls = mock.calls.PeerCount
	mock.lockPeerCount.RUnlock()
	return calls
}

// PeerEvents calls PeerEventsFunc.
func (mock *SentryClientMock) PeerEvents(ctx context.Context, in *PeerEventsRequest, opts ...grpc.CallOption) (Sentry_PeerEventsClient, error) {
	callInfo := struct {
		Ctx  context.Context
		In   *PeerEventsRequest
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockPeerEvents.Lock()
	mock.calls.PeerEvents = append(mock.calls.PeerEvents, callInfo)
	mock.lockPeerEvents.Unlock()
	if mock.PeerEventsFunc == nil {
		var (
			sentry_PeerEventsClientOut Sentry_PeerEventsClient
			errOut                     error
		)
		return sentry_PeerEventsClientOut, errOut
	}
	return mock.PeerEventsFunc(ctx, in, opts...)
}

// PeerEventsCalls gets all the calls that were made to PeerEvents.
// Check the length with:
//
//	len(mockedSentryClient.PeerEventsCalls())
func (mock *SentryClientMock) PeerEventsCalls() []struct {
	Ctx  context.Context
	In   *PeerEventsRequest
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *PeerEventsRequest
		Opts []grpc.CallOption
	}
	mock.lockPeerEvents.RLock()
	calls = mock.calls.PeerEvents
	mock.lockPeerEvents.RUnlock()
	return calls
}

// PeerMinBlock calls PeerMinBlockFunc.
func (mock *SentryClientMock) PeerMinBlock(ctx context.Context, in *PeerMinBlockRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	callInfo := struct {
		Ctx  context.Context
		In   *PeerMinBlockRequest
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockPeerMinBlock.Lock()
	mock.calls.PeerMinBlock = append(mock.calls.PeerMinBlock, callInfo)
	mock.lockPeerMinBlock.Unlock()
	if mock.PeerMinBlockFunc == nil {
		var (
			emptyOut *emptypb.Empty
			errOut   error
		)
		return emptyOut, errOut
	}
	return mock.PeerMinBlockFunc(ctx, in, opts...)
}

// PeerMinBlockCalls gets all the calls that were made to PeerMinBlock.
// Check the length with:
//
//	len(mockedSentryClient.PeerMinBlockCalls())
func (mock *SentryClientMock) PeerMinBlockCalls() []struct {
	Ctx  context.Context
	In   *PeerMinBlockRequest
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *PeerMinBlockRequest
		Opts []grpc.CallOption
	}
	mock.lockPeerMinBlock.RLock()
	calls = mock.calls.PeerMinBlock
	mock.lockPeerMinBlock.RUnlock()
	return calls
}

// Peers calls PeersFunc.
func (mock *SentryClientMock) Peers(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*PeersReply, error) {
	callInfo := struct {
		Ctx  context.Context
		In   *emptypb.Empty
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockPeers.Lock()
	mock.calls.Peers = append(mock.calls.Peers, callInfo)
	mock.lockPeers.Unlock()
	if mock.PeersFunc == nil {
		var (
			peersReplyOut *PeersReply
			errOut        error
		)
		return peersReplyOut, errOut
	}
	return mock.PeersFunc(ctx, in, opts...)
}

// PeersCalls gets all the calls that were made to Peers.
// Check the length with:
//
//	len(mockedSentryClient.PeersCalls())
func (mock *SentryClientMock) PeersCalls() []struct {
	Ctx  context.Context
	In   *emptypb.Empty
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *emptypb.Empty
		Opts []grpc.CallOption
	}
	mock.lockPeers.RLock()
	calls = mock.calls.Peers
	mock.lockPeers.RUnlock()
	return calls
}

// PenalizePeer calls PenalizePeerFunc.
func (mock *SentryClientMock) PenalizePeer(ctx context.Context, in *PenalizePeerRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	callInfo := struct {
		Ctx  context.Context
		In   *PenalizePeerRequest
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockPenalizePeer.Lock()
	mock.calls.PenalizePeer = append(mock.calls.PenalizePeer, callInfo)
	mock.lockPenalizePeer.Unlock()
	if mock.PenalizePeerFunc == nil {
		var (
			emptyOut *emptypb.Empty
			errOut   error
		)
		return emptyOut, errOut
	}
	return mock.PenalizePeerFunc(ctx, in, opts...)
}

// PenalizePeerCalls gets all the calls that were made to PenalizePeer.
// Check the length with:
//
//	len(mockedSentryClient.PenalizePeerCalls())
func (mock *SentryClientMock) PenalizePeerCalls() []struct {
	Ctx  context.Context
	In   *PenalizePeerRequest
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *PenalizePeerRequest
		Opts []grpc.CallOption
	}
	mock.lockPenalizePeer.RLock()
	calls = mock.calls.PenalizePeer
	mock.lockPenalizePeer.RUnlock()
	return calls
}

// SendMessageById calls SendMessageByIdFunc.
func (mock *SentryClientMock) SendMessageById(ctx context.Context, in *SendMessageByIdRequest, opts ...grpc.CallOption) (*SentPeers, error) {
	callInfo := struct {
		Ctx  context.Context
		In   *SendMessageByIdRequest
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockSendMessageById.Lock()
	mock.calls.SendMessageById = append(mock.calls.SendMessageById, callInfo)
	mock.lockSendMessageById.Unlock()
	if mock.SendMessageByIdFunc == nil {
		var (
			sentPeersOut *SentPeers
			errOut       error
		)
		return sentPeersOut, errOut
	}
	return mock.SendMessageByIdFunc(ctx, in, opts...)
}

// SendMessageByIdCalls gets all the calls that were made to SendMessageById.
// Check the length with:
//
//	len(mockedSentryClient.SendMessageByIdCalls())
func (mock *SentryClientMock) SendMessageByIdCalls() []struct {
	Ctx  context.Context
	In   *SendMessageByIdRequest
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *SendMessageByIdRequest
		Opts []grpc.CallOption
	}
	mock.lockSendMessageById.RLock()
	calls = mock.calls.SendMessageById
	mock.lockSendMessageById.RUnlock()
	return calls
}

// SendMessageByMinBlock calls SendMessageByMinBlockFunc.
func (mock *SentryClientMock) SendMessageByMinBlock(ctx context.Context, in *SendMessageByMinBlockRequest, opts ...grpc.CallOption) (*SentPeers, error) {
	callInfo := struct {
		Ctx  context.Context
		In   *SendMessageByMinBlockRequest
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockSendMessageByMinBlock.Lock()
	mock.calls.SendMessageByMinBlock = append(mock.calls.SendMessageByMinBlock, callInfo)
	mock.lockSendMessageByMinBlock.Unlock()
	if mock.SendMessageByMinBlockFunc == nil {
		var (
			sentPeersOut *SentPeers
			errOut       error
		)
		return sentPeersOut, errOut
	}
	return mock.SendMessageByMinBlockFunc(ctx, in, opts...)
}

// SendMessageByMinBlockCalls gets all the calls that were made to SendMessageByMinBlock.
// Check the length with:
//
//	len(mockedSentryClient.SendMessageByMinBlockCalls())
func (mock *SentryClientMock) SendMessageByMinBlockCalls() []struct {
	Ctx  context.Context
	In   *SendMessageByMinBlockRequest
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *SendMessageByMinBlockRequest
		Opts []grpc.CallOption
	}
	mock.lockSendMessageByMinBlock.RLock()
	calls = mock.calls.SendMessageByMinBlock
	mock.lockSendMessageByMinBlock.RUnlock()
	return calls
}

// SendMessageToAll calls SendMessageToAllFunc.
func (mock *SentryClientMock) SendMessageToAll(ctx context.Context, in *OutboundMessageData, opts ...grpc.CallOption) (*SentPeers, error) {
	callInfo := struct {
		Ctx  context.Context
		In   *OutboundMessageData
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockSendMessageToAll.Lock()
	mock.calls.SendMessageToAll = append(mock.calls.SendMessageToAll, callInfo)
	mock.lockSendMessageToAll.Unlock()
	if mock.SendMessageToAllFunc == nil {
		var (
			sentPeersOut *SentPeers
			errOut       error
		)
		return sentPeersOut, errOut
	}
	return mock.SendMessageToAllFunc(ctx, in, opts...)
}

// SendMessageToAllCalls gets all the calls that were made to SendMessageToAll.
// Check the length with:
//
//	len(mockedSentryClient.SendMessageToAllCalls())
func (mock *SentryClientMock) SendMessageToAllCalls() []struct {
	Ctx  context.Context
	In   *OutboundMessageData
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *OutboundMessageData
		Opts []grpc.CallOption
	}
	mock.lockSendMessageToAll.RLock()
	calls = mock.calls.SendMessageToAll
	mock.lockSendMessageToAll.RUnlock()
	return calls
}

// SendMessageToRandomPeers calls SendMessageToRandomPeersFunc.
func (mock *SentryClientMock) SendMessageToRandomPeers(ctx context.Context, in *SendMessageToRandomPeersRequest, opts ...grpc.CallOption) (*SentPeers, error) {
	callInfo := struct {
		Ctx  context.Context
		In   *SendMessageToRandomPeersRequest
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockSendMessageToRandomPeers.Lock()
	mock.calls.SendMessageToRandomPeers = append(mock.calls.SendMessageToRandomPeers, callInfo)
	mock.lockSendMessageToRandomPeers.Unlock()
	if mock.SendMessageToRandomPeersFunc == nil {
		var (
			sentPeersOut *SentPeers
			errOut       error
		)
		return sentPeersOut, errOut
	}
	return mock.SendMessageToRandomPeersFunc(ctx, in, opts...)
}

// SendMessageToRandomPeersCalls gets all the calls that were made to SendMessageToRandomPeers.
// Check the length with:
//
//	len(mockedSentryClient.SendMessageToRandomPeersCalls())
func (mock *SentryClientMock) SendMessageToRandomPeersCalls() []struct {
	Ctx  context.Context
	In   *SendMessageToRandomPeersRequest
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *SendMessageToRandomPeersRequest
		Opts []grpc.CallOption
	}
	mock.lockSendMessageToRandomPeers.RLock()
	calls = mock.calls.SendMessageToRandomPeers
	mock.lockSendMessageToRandomPeers.RUnlock()
	return calls
}

// SetStatus calls SetStatusFunc.
func (mock *SentryClientMock) SetStatus(ctx context.Context, in *StatusData, opts ...grpc.CallOption) (*SetStatusReply, error) {
	callInfo := struct {
		Ctx  context.Context
		In   *StatusData
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockSetStatus.Lock()
	mock.calls.SetStatus = append(mock.calls.SetStatus, callInfo)
	mock.lockSetStatus.Unlock()
	if mock.SetStatusFunc == nil {
		var (
			setStatusReplyOut *SetStatusReply
			errOut            error
		)
		return setStatusReplyOut, errOut
	}
	return mock.SetStatusFunc(ctx, in, opts...)
}

// SetStatusCalls gets all the calls that were made to SetStatus.
// Check the length with:
//
//	len(mockedSentryClient.SetStatusCalls())
func (mock *SentryClientMock) SetStatusCalls() []struct {
	Ctx  context.Context
	In   *StatusData
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *StatusData
		Opts []grpc.CallOption
	}
	mock.lockSetStatus.RLock()
	calls = mock.calls.SetStatus
	mock.lockSetStatus.RUnlock()
	return calls
}
