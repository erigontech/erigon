Great. I’ll do a deep technical dive into Arbitrum One, focusing specifically on the differences from Geth (Go-Ethereum) and covering all transaction types supported by Arbitrum One and their handling.

I’ll break it down across architecture, execution environment, transaction formats, Nitro-specific enhancements, and key protocol-level distinctions. I’ll get back to you shortly with detailed insights.

# Arbitrum One (Nitro) vs. Go-Ethereum: Architecture & Transactions

## Execution Layer: WASM-Based Nitro vs. Native EVM in Geth  
**Arbitrum Nitro’s WASM Execution:** Arbitrum One (Nitro) departs from Go-Ethereum’s native EVM by running the Ethereum state transition logic inside a WebAssembly (WASM) environment. The Nitro stack effectively **compiles Geth’s EVM implementation to WASM** (sometimes called “WAVM” in Nitro) for use in fraud proofs and execution. In normal operation, the Arbitrum sequencer runs a modified Geth engine natively for speed, but the **WASM layer is used to deterministically replay transactions on L1** during dispute resolution . This design provides full EVM compatibility while enabling Arbitrum to verify L2 execution on Ethereum (L1) via interactive fraud proofs (the WASM code yields identical results as the native run). By using a highly optimized WASM runtime, Nitro achieves faster execution than Ethereum’s interpreted EVM, contributing to lower fees and higher throughput on Arbitrum. In summary, **Geth’s core EVM logic is embedded within Nitro as a WASM-compatible module**, whereas on L1 Ethereum, Geth executes EVM bytecode directly on bare metal. 

**EVM Compatibility:** Aside from the compilation to WASM, Arbitrum aims to preserve EVM semantics. Smart contracts on Arbitrum One still deploy as EVM bytecode and run with the same opcode gas costs as on Ethereum . This ensures that most Ethereum software (Solidity contracts, tooling, etc.) works on Arbitrum without modification. Arbitrum Nitro supplements the EVM with an **optional Stylus WASM VM** for running Rust/C++ contracts, but traditional Solidity contracts continue to execute in the embedded EVM environment. 

## State Storage and Access Patterns  
**Ethereum State vs. Arbitrum State:** Like Ethereum, Arbitrum Nitro maintains the global state as a Merkle-Patricia trie of accounts and storage values. Nitro inherits Ethereum’s state representation, but with additional instrumentation for the rollup. When the Arbitrum node executes transactions, it uses a special **Recording Key-Value Store** that wraps the state trie and logs every accessed key (preimage) during execution. This **RecordingKV** mechanism captures all state reads/writes needed to later prove the transaction results on L1. The recorded state accesses are used to generate Merkle proofs in case a fraud proof is needed . In contrast, vanilla Geth does not record state accesses by default (Ethereum has no built-in fraud proof requirement). This difference allows Arbitrum validators to reconstruct a Merkle proof of any L2 state change and submit it on Ethereum to challenge incorrect results.

**ArbOS State in Ethereum Trie:** Arbitrum’s node software includes an on-chain “operating system” called **ArbOS**, which handles L2-specific logic (sequencer inbox parsing, fee accounting, etc.). Nitro cleverly **stores ArbOS’s own state as an account in the standard state trie** of the chain. A fictitious account (at address `0xA4B05...FFFFF`) represents ArbOS, so ArbOS state updates are just writes to this account’s storage . This way, ArbOS state changes are subject to the same transactional semantics as regular contract storage (they revert on transaction failures, appear in the state root, etc.). Ethereum’s Geth of course has no such “OS account,” since Ethereum’s protocol logic isn’t implemented as a first-class contract. This design gives Arbitrum flexibility: things that Ethereum hard-codes in the protocol can be managed by ArbOS at L2 software level . 

**State Commitments:** Each Arbitrum L2 block results in a new state root, which is eventually posted to the L1 rollup contract. While Geth achieves finality via Ethereum consensus, Arbitrum achieves it by **anchoring the state root on L1 and enforcing it via fraud proofs**. Thus, Arbitrum’s state is always backed by a canonical hash on Ethereum, even though the full state data resides off-chain on Arbitrum nodes.

## Sequencer and Rollup Mechanics  
**Sequencer vs. Ethereum Miners/Validators:** Instead of decentralized miners or PoS validators ordering transactions, Arbitrum One relies on a **single (at present) sequencer** to collect and order L2 transactions. The sequencer receives user transactions directly and instantly provides them soft-confirmations . It then periodically batches these transactions and posts the batch data to an Ethereum L1 contract. This contrasts with Go-Ethereum, where blocks are built by miners/validators and gossip-propagated; the Arbitrum sequencer is a centralized actor for fast UX. However, Arbitrum’s security comes from the L1 batch postings: the sequencer’s output is not final until it’s on L1 and past the dispute window.

**Inbox and Batching:** Arbitrum uses an **inbox model** to combine two transaction streams: (1) transactions directly from the sequencer and (2) **delayed messages posted on L1**. All L2-bound messages are inserted into a single total order via the **Sequencer Inbox contract** on Ethereum. The sequencer normally writes an L2 batch by calling an L1 function that appends a compressed list of transactions to the inbox (updating an accumulator) . Users can also bypass the sequencer by sending transactions to a **Delayed Inbox** on L1 (for example, depositing funds or if the sequencer is offline). The sequencer is expected to routinely include these delayed inbox messages in the L2 timeline. If it fails to do so within a certain delay (e.g. if it censors or goes down), **anyone can force-include L1 messages** by calling a force-inclusion function on L1 after a timeout. This ensures liveness and censorship-resistance: ultimately all L1-posted transactions will be processed on L2, even if out-of-band sequencing fails .

**Rollup Blocks:** The Arbitrum sequencer produces L2 blocks (sometimes several per Ethereum block) and eventually posts a commitment to L1. Each L2 block contains a pointer to the L1 block it was derived from or posted in. Notably, Arbitrum maintains *two notions of block number*: the L2 block index and the L1 block number of the “ancestor” L1 block. In fact, inside the EVM, `block.number` on Arbitrum returns the **L1 Ethereum block number** (of the most recent L1 block at time of L2 block creation). This is a key difference in semantics – it helps preserve sensible timing assumptions for contracts (since Arbitrum can produce many L2 blocks per L1 block, using L1’s number avoids fast-forwarding the block number too quickly). Meanwhile, `block.timestamp` on Arbitrum is set by the sequencer (based on its local clock) and is not directly tied to L1 timestamps. The sequencer must increase timestamps monotonically and is bounded (it cannot set a timestamp too far in the future or past relative to real time). In Ethereum, miners have minor freedom in setting timestamps; Arbitrum’s sequencer likewise can adjust timestamps within tolerance, but with safeguards to prevent abuse.

**Finality and Fraud Proofs:** Once the sequencer posts a batch and state root to L1, there is a dispute period (e.g. ~7 days) where any validator can challenge an incorrect state root. Arbitrum Nitro uses an interactive bisection protocol (the **BoLD dispute protocol**) to pinpoint the first failing step between two asserted execution traces . The deterministic WASM version of the machine is used on L1 to prove a fraudulent step if needed. Honest validators (including the sequencer) will post the correct state root, and if no one proves a discrepancy, it becomes final. This mechanism is unique to rollups – in Ethereum’s native chain, finality comes from economic consensus and 51% assumptions, whereas Arbitrum inherits Ethereum’s security via fraud proofs on L1.

## Node Implementation: Arbitrum Nitro vs. Geth Codebase  
Arbitrum Nitro’s node is built as a **layered modification of Geth**. Rather than writing a client from scratch, Offchain Labs integrated ArbOS logic on top of Geth’s Ethereum implementation. The Nitro node has three main layers:

- **1. Base Layer – Geth Core:** At the bottom is a slightly modified fork of Geth which provides EVM execution, Ethereum state management (tries, transaction processing), and P2P/RPC infrastructure. Nitro links Geth as a library and strives to *minimize changes to its core*, to maintain EVM compatibility. For example, it retains Geth’s `ApplyTransaction` logic but injects custom hooks at key points. This design means most Ethereum protocol rules (EVM opcode behavior, trie formats, etc.) remain identical on Arbitrum.

- **2. Middle Layer – ArbOS:** ArbOS is Arbitrum’s “operating system” that extends Geth for the rollup context . It runs within the state transition, orchestrating L2-specific functionality: e.g. **parsing incoming batch data**, decoding the stream of L1/L2 messages, managing cross-chain message queues, and handling **fee accounting and refunds**. ArbOS is also responsible for implementing system actions like L2 block number updates, network fee accounting, and more (often via the special internal transactions discussed later). It’s essentially the **“glue” that manages resources and logistics** that L1 Ethereum would normally handle via on-chain rules. This layer is upgradable and can evolve more flexibly than L1 protocol changes. ArbOS is integrated by way of hooks and by using the reserved ArbOS account in state, as described above.

- **3. Top Layer – Node and Networking:** The highest layer is the node software that handles peer-to-peer networking, transaction gossip, and JSON-RPC APIs . Much of this is derived from Geth’s existing code. For instance, Nitro uses a modified Ethereum P2P protocol to broadcast L2 blocks/tx, and a similar JSON-RPC interface as Geth. This allows developers to interact with Arbitrum using standard Ethereum tools. Some RPC methods have been extended for Arbitrum (e.g. returning L1-specific data), but overall it feels like an Ethereum node with extra features.

**Internal Hooks in Geth:** To support ArbOS, Nitro’s Geth fork introduces several hook points in the transaction processing pipeline: 

- **StartTxHook:** Called at the start of applying each transaction. ArbOS uses this to intercept **Arbitrum-specific transaction types** before EVM execution. For example, if a transaction is an **ArbitrumDeposit** or **SubmitRetryable**, the StartTxHook will perform the required state updates (crediting an account balance, or creating a retryable ticket) and then **signal that the transaction is “complete” without executing normal EVM code**  . This is how L1-triggered deposits and retryables are handled – via ArbOS logic rather than EVM bytecode. (On Ethereum, there is no analogous hook – all transactions are either regular EVM execution or precompiles.) 

- **GasChargingHook:** This hook runs during transaction execution to adjust gas fees. In Nitro, before the EVM runs, ArbOS must ensure the user pays for the **L1 calldata cost** of the transaction. The GasChargingHook verifies the sender has enough balance for the L1 posting cost; if not, the tx is refused (reverted) . If yes, it **deducts the L1 fee component and earmarks it to reimburse the batch poster** later. Geth normally would only check transaction gas vs. account balance for the gas *price* (computation fee); Arbitrum extends this to also account for the data cost on L1. The hook also handles Arbitrum’s larger gas accounting (described below), such as capping gas in excess of the per-block limit and refunding any surplus gas to the user at end of execution . 

- **EndTxHook:** Called after the EVM finishes executing a transaction, just before finalizing state changes. ArbOS uses EndTxHook to do final accounting – e.g. actually transfer the fee amounts to the **appropriate fee collector accounts** (the sequencer’s reimbursement and the Arbitrum network fee) now that the exact gas used is known. It’s also used to handle the **L1-to-L2 message transactions** that require action at end of execution. For instance, an L1-to-L2 call (ArbitrumUnsigned/ContractTx) is processed through the EVM and then EndTxHook performs any concluding steps. Similarly, a Retryable redemption (ArbitrumRetryTx) executes as a normal call and EndTxHook would clean up the ticket from the queue if successful. Geth doesn’t have this concept of post-tx accounting hook because Ethereum fees are simply transferred to the miner within the EVM’s `SELFDESTRUCT`/fee refund handling. In Nitro, fee distribution is a bit more complex (split between poster and network). 

These hooks, along with some interface glue code, are the **only modifications to Geth’s core**. By keeping Geth’s behavior mostly unchanged except at well-defined hook points, Arbitrum Nitro preserves Ethereum’s expected behavior but injects L2-specific logic where needed.

## Precompiles and System Contracts  
Arbitrum One introduces several **system-level contracts (precompiles)** that do not exist in L1 Ethereum, to expose ArbOS functionality to user contracts. These are analogous to Ethereum precompiled contracts (fixed addresses that implement logic in the client), but provide Arbitrum-specific features. Notable examples include:

- **ArbSys (0x64):** The primary **Arbitrum System contract** for L2→L1 messaging and chain info , get the Arbitrum block number or chain ID, and other utility functions. For instance, `ArbSys.sendTxToL1(address, bytes)` adds a message to the outbox for execution on L1 after the fraud window.

- **ArbRetryableTx (0x6e):** A precompile that manages **retryable tickets** . It has functions like `redeem(bytes32 ticketID)` to execute a queued retryable transaction and `getRetryableTicketInfo(...)` to query status. The ArbOS will invoke this precompile automatically for auto-redeeming tickets, and users can call it to manually redeem if needed. This contract also emits events like `TicketCreated` when a new retryable is made . Ethereum L1 has no concept of retryable tickets, so this precompile is unique to Arbitrum.

- **ArbGasInfo (0x6c):** Exposes information about gas prices and costs on Arbitrum. For example, it can report the current L1 gas price estimate that Arbitrum is using, the L2 base fee, etc. It’s a way for contracts to query how expensive an L1 call would be, or to get the “gasUsedForL1” of their transaction (also provided in receipts) .

- **ArbAggregator (0x6d):** Used for configuring transaction aggregators/submitters . (In Arbitrum One, a single sequencer plays the role of aggregator. This precompile allows for future extensibility, e.g. if multiple aggregators or a decentralized sequencer set were introduced, users could select or register an aggregator here.)

- **ArbWasm (0x71):** A precompile to manage deployment of Stylus (WASM) contracts . It handles operations like uploading a WASM module, initiating its compilation to native code, etc., as part of Arbitrum’s support for non-EVM contracts. Ethereum L1 doesn’t support arbitrary WASM contracts, so this is a new feature in Arbitrum.

These system contracts live at reserved addresses (typically low 8-bit addresses like 0x64, 0x65, … 0xFF in hex) and are implemented in the Nitro node software (Go code) rather than as Solidity code. They are conceptually similar to how Ethereum has precompiles for e.g. BN256 math at addresses 0x06…0x09, but Arbitrum’s precompiles target rollup-specific needs. **ArbOS uses the precompiles internally as well** – e.g., when a user makes a deposit, ArbOS will call ArbRetryableTx to create the ticket and emit the event.

Additionally, Arbitrum employs an **address aliasing scheme** for L1-to-L2 transactions. When L1 contracts or users initiate messages to L2, the **sender address is adjusted (aliased) on L2** to prevent it colliding with normal L2 addresses. A fixed offset is added to the original L1 `msg.sender` address when it’s represented on L2. This ensures that an L1 contract calling an L2 function cannot be confused with a genuine L2 EOA or contract (the addresses will differ by a known constant). The Arbitrum Inbox contract applies this aliasing to the `sender` field of messages. As a result, in Arbitrum transaction receipts, the `from` field for L1-originated transactions shows the **aliased L2 address** (not the real L1 address) . Users and contracts can de-alias if needed (the alias formula is public), but generally this provides a simple way for L2 contracts to recognize that a call came from an L1 origin. Ethereum of course does not do anything like this, since it doesn’t receive “outside” messages in the same way – Arbitrum’s aliasing is a solution to the unique problem of combining two domains of origin (L1 and L2) in one execution environment.

## L1–L2 Message Passing and Bridging  
Because Arbitrum is an L2, it has explicit mechanisms for **cross-chain messaging** between the Ethereum L1 and the Arbitrum L2. This contrasts with a layer-1 like Ethereum which doesn’t need “bridging” to itself. Key components of Arbitrum’s message passing include:

- **Inbox/Bridge Contracts on L1:** Arbitrum Nitro’s core L1 contracts (often called the “bridge”) include an **Inbox contract** for incoming messages and an **Outbox contract** for outgoing messages. The Inbox contract (which has a sequencer inbox and delayed inbox) is where transactions or withdrawals are posted on L1. For L1 → L2 communication, users or the sequencer call functions like `Inbox.sendL2Message(bytes)` or `Inbox.createRetryableTicket(...)` on L1. These functions log an event or update a merkle accumulator that the Arbitrum node watches. Each L1 message is assigned a sequential number and becomes part of the ordered feed of L2 transactions. The **Delayed Inbox** path (also via the bridge) specifically handles messages that users put directly in L1 storage (with a guaranteed inclusion after a timeout).

- **Interpreting L1 Messages as L2 Transactions:** When the Arbitrum sequencer or any validator constructs an L2 block, it **pulls any pending L1 messages from the inbox** (respecting the ordering and inclusion delay rules) and converts them into special L2 transactions in the block. For example, if a user deposited ETH and called a contract via the Inbox, ArbOS will inject an **ArbitrumDepositTx** to credit the ETH, followed immediately by an **ArbitrumSubmitRetryableTx** to represent the contract call request (the “retryable ticket” creation). These appear in the L2 block alongside normal user transactions. The previous section on transaction types details these special L2 representations. The important point is that **every L1→L2 message becomes one or more L2 transactions**, processed under Arbitrum’s state transition function. The system ensures the **bridge-enforced ordering and authenticity** of these: since the Inbox contract on L1 was called by a specific L1 address, ArbOS knows the call’s origin (and uses address aliasing and special tx types for it). This gives Arbitrum a secure, verifiable way to import L1 intents.

- **L2 → L1 Outbox:** For messages going from Arbitrum back to Ethereum, Arbitrum provides an Outbox contract on L1 that holds a merkle root of all L2-to-L1 outputs (events) from finalized blocks. When an L2 contract calls `ArbSys.sendTxToL1(target, data)`, ArbOS will record this as an L2 outbound message (part of a merkle tree of outputs, often called the **send root**). After the rollup block is finalized on L1 (i.e., no fraud proof during the challenge window), users can **prove the message’s inclusion** to the Outbox contract and execute it on L1. The Outbox will then perform the call to the `target` address on L1 with the provided data, as if the L2 contract had directly invoked that L1 address. This mechanism effectively lets L2 contracts trigger L1 actions (like unlocking tokens or any cross-chain logic). There is a challenge period delay in executing outbox messages corresponding to the rollup’s dispute window (so typically one must wait ~7 days after the L2 event before it can be relayed on L1). Ethereum L1 doesn’t have an outbox concept – this is specific to rollups – but from a developer perspective, ArbSys makes it as easy as calling a function to initiate a withdrawal.

- **Trust Model:** The bridging is **trustless** under Ethereum’s security. The Inbox contract only accepts L1 transactions (which have immediate Ethereum finality for deposits). The Outbox will only relay messages from an L2 block if that block’s assertion on L1 is confirmed and unchallenged. Thus users do not have to trust the sequencer for the final outcome; even if the sequencer is malicious or down, the bridge guarantees eventual delivery of messages (or the ability to challenge fraudulent ones). This is a key difference from sidechains – Arbitrum is an *optimistic rollup*, so all cross-chain messages are ultimately governed by Ethereum’s security.

## Fork Rules and Opcode Differences  
Arbitrum Nitro strives to mimic Ethereum’s protocol rules, but some **differences in block context and opcodes** exist due to the Layer-2 nature:

- **Block Numbers:** As mentioned, `block.number` in an Arbitrum L2 EVM context returns the **Ethereum L1 block number** (of the most recent parent block when the L2 block was created), *not* the Arbitrum L2 block height. This means from a contract’s perspective, block numbers on Arbitrum advance only when Ethereum L1’s block number advances. For example, if several Arbitrum blocks are produced between Ethereum block N and N+1, all those Arbitrum blocks will report `block.number = N` until the sequencer includes an L1 block update. This design keeps Arbitrum’s `block.number` roughly in sync with wall-clock time and Ethereum’s progression, avoiding issues that could arise if `block.number` increased too quickly (some contracts use it for time or difficulty-related logic).

- **Block Timestamps:** Arbitrum’s `block.timestamp` is set by the sequencer and increases with each L2 block, but it is not explicitly tied to L1 timestamps. The sequencer’s clock generally dictates it. However, there are safeguards: if a user transaction comes via the delayed inbox (i.e., posted on L1), the timestamp of the L2 block that includes it will be at least the L1 timestamp when it was posted (to ensure L1->L2 message ordering by time) . Also, the sequencer cannot set an L2 timestamp too far in the future (currently the timestamp can be at most 1 hour ahead of real time, and no more than 24 hours behind) . These rules prevent the sequencer from manipulating time excessively. On Ethereum, miners/validators must put a timestamp >= parent and within ~15 seconds of real time; Arbitrum’s rules are analogous, just with a bit more leeway to account for L1 posting delays.

- **Coinbase and Rewards:** In Ethereum, `block.coinbase` (now often called `block.miner` or `block.producer`) returns the address of the miner/validator, and that address receives block rewards and gas tips. On Arbitrum, there is no PoW miner or PoS proposer to reward, but `block.coinbase` still needs a defined value. Arbitrum sets the coinbase to a **dedicated fee collection account** (sometimes referred to as the “network fee address”). This is an address controlled by the Arbitrum protocol where **L2 transaction fees accrue** . All user-paid L2 fees (the portion for validators/network) effectively go to this account, which in Arbitrum One’s case is managed by the DAO or sequencer for funding the system (there’s no mining reward to distribute). As a result, any contract reading `block.coinbase` on Arbitrum will see that fixed address. The sequencer’s Ethereum address is not directly exposed via coinbase, since ordering is not decided by highest bid and no per-block auction is needed. In fact, Arbitrum does **not require a tip** for transaction inclusion – the sequencer processes transactions in FIFO order by default (no priority gas auctions). Users only pay the required fees, and adding a tip doesn’t affect ordering (though Arbitrum’s transaction format still has fields for maxPriorityFee for compatibility). Essentially, Arbitrum replaced Ethereum’s miner tip mechanism with a fixed policy: first-come, first-served sequencing, and all fees go to the protocol.

- **Base Fee (EIP-1559):** Arbitrum has its own notion of base fee per gas on L2, but the mechanism differs from L1 Ethereum’s target-block-size formula. Arbitrum actually maintains **two base fees**: one for L2 execution gas and one for L1 calldata pricing. The **L2 base fee** adjusts based on congestion of the L2 chain – Nitro uses an exponential moving average of backlog to raise or lower this fee. The **L1 base fee (data price)** is Arbitrum’s internal estimate of how expensive posting data to Ethereum currently is. It’s dynamically adjusted by ArbOS’s pricing algorithm to closely track actual L1 costs over time . When the sequencer posts a batch, it reports the L1 basefee it paid; ArbOS uses that to calibrate the pricing model for future transactions. In practice, this means the “gas price” a user pays on Arbitrum covers two components: the L2 base fee (for execution) and an extra amount for the L1 cost (computed via the current L1 data price and the transaction’s size). Both components are denominated in ETH and summed up as the effective fee. If a user specifies a maxFeePerGas, it must exceed the current base fee (as usual) or the tx won’t be processed . From the user’s perspective, EIP-1559 style fields exist and Arbitrum fees burn or redirect the base fee similar to Ethereum, but instead of burning, Arbitrum’s base fee is collected to the protocol’s fee account (no ETH is burned on L2; burning happens if and when fees are paid on L1). 

- **Gas Limits:** Arbitrum blocks can use substantially more gas than Ethereum L1 blocks (since Arbitrum’s execution is cheaper). The protocol defines a **maximum per-block gas limit** (e.g. 50 million) and a **gas pool** that refills over time, allowing bursts above the per-block limit in short intervals . If a user tries to use more gas than allowed, ArbOS will cap it and **refund the excess gas** (via the EndTxHook’s refund logic) so that only the allowed gas is consumed . This refund is handled by an internal mechanism (ForceRefundGas) to ensure the user isn’t charged for gas beyond the limit . Ethereum’s miners simply enforce a hard block gas limit; Arbitrum’s approach is a bit more flexible, treating the limit more like a rate limit with refunds, because the sequencer can pack many tx into a block and wants to maximize throughput while protecting against DoS. 

- **Opcode Equivalence:** Nearly all EVM opcodes function the same on Arbitrum as on Ethereum (since it’s the same Geth EVM code). For example, arithmetic, logs, memory operations, etc., have identical semantics. Opcodes that query blockchain state return Arbitrum-specific values where applicable: e.g. `CHAINID` returns 42161 on Arbitrum One (Arbitrum’s chain ID), versus 1 on Ethereum mainnet. Some environment opcodes have the adjusted behaviors noted (TIMESTAMP, NUMBER, COINBASE as discussed). `BLOCKHASH` on Arbitrum can only retrieve L2 block hashes for recent L2 blocks, which aren’t really used in consensus (and it might be disabled or return zero if out of range; Arbitrum’s blockhash is not tied to L1 blockhashes except indirectly via state root updates). There is no meaningful “difficulty” or “randomness” value pre-merge – Arbitrum might set the `DIFFICULTY` (now called `PREVRANDAO`) field to zero or a constant, since it’s not applicable. After Ethereum’s merge, the `PREVRANDAO` is derived from the beacon chain; Arbitrum likely uses a pseudo-random or default value for it as well, given no beacon chain drives Arbitrum’s randomness. These differences are minor and mostly affect low-level contracts (e.g. those expecting randomness from difficulty may not get useful entropy on L2).

In summary, Arbitrum Nitro carefully mirrors Ethereum’s execution, but as a Layer 2 it **overrides certain block context opcodes and adds new fee logic**. The result is that most Ethereum contracts run unmodified on Arbitrum, with only edge-case differences (like block number or lack of miner tips) which are documented in Arbitrum’s developer materials .

## Transaction Types on Arbitrum One (Nitro)  
Arbitrum One supports all the standard Ethereum transaction types *and* introduces several custom L2-specific transaction formats. Under the hood, Nitro uses the **EIP-2718 typed transaction envelope** to encode its custom types . On Ethereum, there are three main transaction types (legacy `0x0`, Access List `0x1`, and EIP-1559 `0x2`). Arbitrum recognizes those plus additional types with distinct type codes (0x64 and above, in hex). These transaction types are produced either by the Arbitrum bridge (for L1-originating messages) or by ArbOS itself. Below we enumerate all transaction types used on Arbitrum One and their roles:

- **Legacy & Standard Types (0, 1, 2):** First, note that **ordinary L2 transactions** (submitted directly by users to the sequencer) use the same format as Ethereum. A user can send a legacy zero-byte-prefixed transaction, an EIP-2930 access-list tx (type 1), or an EIP-1559 tx (type 2) with gas fee caps. These will be processed by Nitro’s Geth core just like on Ethereum. They have a normal `from` (the user’s L2 address), nonce, gas limit, etc., and carry a signature. From an RPC perspective, these look the same as on Ethereum (type 0x0/0x1/0x2). Arbitrum adds **six custom transaction types (type codes 100+)** for special purposes :

  - **ArbitrumDepositTx (Type 0x64 / 100):** This represents an **ETH deposit from L1 to L2**. When a user calls the Ethereum bridge’s deposit ETH function, the bridge enqueues an L2 message to credit that ETH to the user’s L2 address. ArbOS interprets that message as an ArbitrumDepositTx which, when executed on L2, simply **increases the target account’s balance** by the deposited amount. There is no “sender” on L2 for this tx (the value comes from L1), and it carries no nonce or data – it’s purely a balance update. The `from` address seen in RPC for a deposit tx is a special aliased form of the L1 sender (often the L1 bridge itself, aliased) . ArbitrumDepositTx is handled in the Nitro node’s StartTxHook: ArbOS adds the funds to the account and marks the tx as completed without running EVM code. This type exists because on Ethereum, depositing ETH to a contract doesn’t automatically credit a user on another chain – Nitro needs a custom tx to effect the cross-chain transfer.

  - **ArbitrumUnsignedTx (Type 0x65 / 101):** An **L1-to-L2 message from an EOA (externally owned account)** on L1, calling an L2 contract, is represented as ArbitrumUnsignedTx . “Unsigned” refers to the fact that *no L2 signature is provided* – the authenticity comes from the L1 transaction. This allows an L1 user to invoke an L2 function without having an L2 private key signature. The Arbitrum bridge uses the L1 EOA’s address as the logical origin, and ArbOS will **apply an address alias** to that address on L2  so that it doesn’t collide with a real L2 EOA. The UnsignedTx carries the callee (L2 contract address), the calldata, and the amount of ETH (if any) to send, as provided by the L1 message . It does not include a nonce or signature – instead, the Arbitrum Inbox enforces ordering by assigning each L1 message a sequential number. When ArbOS executes an ArbitrumUnsignedTx, it will invoke the target contract on L2 as if called by the aliased user address . This transaction type’s name arises because from the L2 perspective it’s not “signed” by a key; the trust is that the L1 inbox was called by the true owner. (If a contract on L1 *did* want to simulate a user call, it could use this, but normally contracts use the next type.)

  - **ArbitrumContractTx (Type 0x66 / 102):** This is similar to UnsignedTx but intended for **L1 contracts calling L2** . Since an L1 contract account has no private key and cannot sign, any L2 action it triggers cannot have an L2 signature. The difference from UnsignedTx is how nonces are handled. If an L1 contract sends multiple L2 messages, we don’t want to require the contract to track an “L2 nonce”. Thus, ArbitrumContractTx uses the **bridge’s global nonce** (a unique sequence number for each message) rather than any user-specified nonce . An L1 contract *could* use an UnsignedTx, but then it would have to manage a nonce in its storage to avoid replay; the ContractTx frees it from that requirement. In effect, ArbitrumContractTx is an **L1-originated call carrying a globally ordered nonce**. When executed on L2, it calls the specified L2 contract with `msg.sender` as an aliased version of the L1 contract’s address . Aside from the nonce handling, it behaves like UnsignedTx. Both UnsignedTx and ContractTx are processed via ArbOS at the EndTxHook (after running the call), since they need no special pre-execution setup beyond address aliasing. In RPC, these transactions will show `type: 101` or `102` and their `from` will be the aliased L1 address.

  - **ArbitrumSubmitRetryableTx (Type 0x69 / 105):** This corresponds to **creating a retryable ticket** on L2. When a user uses the Arbitrum Inbox on L1 to submit a transaction that should be executed on L2 (typically a contract call with some ETH attached), the Nitro system doesn’t execute it immediately as a single L2 call. Instead, it creates a **“retryable ticket”**, which is a retriable L2 transaction that can be executed, potentially re-executed if it fails, or canceled after a timeout. The SubmitRetryableTx is the L2 transaction that ArbOS uses to record this intent. It is produced by the bridge when an L1 message calls the Inbox’s `createRetryableTicket` function. On L2, processing an ArbitrumSubmitRetryableTx will **create the retryable ticket in ArbOS’s pending queue** (with details like the payload, the sender, the payment for fees, etc.). If the user’s L1 deposit for this ticket included enough gas for execution, ArbOS will immediately schedule an attempt to execute the ticket’s payload in the same block (that execution is the ArbitrumRetryTx, described next) . Essentially, ArbitrumSubmitRetryableTx says “we’ve received a request to execute X on L2; if resources permit, auto-run it now or else make it retrievable for later.” This tx type is handled in the StartTxHook – ArbOS interprets the fields (which include the L2 message’s calldata, the submission fee, etc.), creates an entry in the retryable-ticket list, and if auto-redeem gas is provided, schedules the redeem attempt . The transaction then “completes” without directly executing user contract code itself (the actual user code runs in the subsequent RetryTx). In the RPC, a SubmitRetryableTx will show `type: 105` and typically a very low `gasUsed` (just the overhead), since it doesn’t call the user contract directly.

  - **ArbitrumRetryTx (Type 0x68 / 104):** This represents the **execution of a retryable ticket’s payload** on L2. When a retryable ticket is redeemed – either automatically or via a user calling redeem – the system generates an ArbitrumRetryTx in the L2 block. The RetryTx carries the actual call that the user wanted to perform (the target L2 contract, the calldata, and the amount of ETH, all originally packed in the ticket). It executes just like a normal transaction to that contract (with `msg.sender` as the ticket’s beneficiary or aliased origin) and consumes gas. If the retryable execution was triggered automatically, it will appear in the same block immediately after the SubmitRetryableTx; if manually, it will appear whenever the user (or another actor) called the ArbRetryableTx.precompile’s `redeem(ticketID)` function. In RPC, this shows as `type: 104` (RetryTx) coming from the alias of the ticket creator (or possibly a designated retry redeemer address). The Nitro docs note that RetryTx is scheduled via the ArbRetryableTx precompile’s redeem call or auto-redeem logic . After a RetryTx executes, ArbOS will mark the corresponding retryable ticket as resolved (no further retries allowed unless it fails and user calls again within the window). If the RetryTx fails (reverts) due to out-of-gas or other error and there is time left, the ticket remains available for another retry.

  - **ArbitrumInternalTx (Type 0x6A / 106):** This is a special type for **internal ArbOS-generated transactions**. Since ArbOS runs on top of Geth, some of its own house-keeping operations are easiest to implement by injecting a transaction that modifies ArbOS state in the state trie. For example, **updating the L1 block number and L1 base fee reference at the start of each L2 block** is done by an internal transaction. Indeed, Nitro guarantees that the **first transaction in every L2 block** is an InternalTx called `InternalTxStartBlock`. This transaction writes the L1 block number and timestamp (and basefee info) into ArbOS’s state so that if any user tx in this block queries `block.number` or the L1 base fee, ArbOS can return the correct values . The InternalTx has a subtype field indicating what it’s doing (currently only the StartBlock type is used, but the design allows future internal ops). These never come from the “outside”; they are generated by ArbOS itself during block construction. RPC calls like `eth_getTransactionByHash` will show type 106 for these, and one can identify them by the fact that they have no true originator (likely `from` is an internal ArbOS address or zero address). They do not exist on Ethereum at all, since Ethereum protocol would handle such state updates (like base fee updates) as part of block header processing, not as transactions.

To summarize, **Arbitrum’s transaction types 100-106 cover all forms of L1-to-L2 and internal activities**, while normal user-initiated L2 transactions use the standard Ethereum types. The custom types are fully documented in Arbitrum’s specs and exposed via the JSON-RPC `type` field. These types allow Arbitrum to incorporate L1 deposits and messages into the L2 chain in a transparent way. For instance, a deposit ETH will result in an ArbitrumDepositTx (to credit balance) which is visible in the L2 block explorer, rather than being some magic balance change with no transaction record. Likewise, a retryable ticket creation is an explicit L2 transaction, so it can be tracked and its ticket ID obtained from the `TicketCreated` event emitted on L2.

### Retryable Transaction Lifecycle on Arbitrum  
One of Arbitrum’s unique features is the **retryable ticket** mechanism, which underpins cross-chain contract calls. A *retryable ticket* is essentially a transaction that is guaranteed to be executable on L2, either immediately or after potential retries, or else refundable if it never succeeds. Here’s the lifecycle, tying together the SubmitRetryableTx and RetryTx types:

- **Submission (L1):** A user initiates a retryable ticket by calling the Arbitrum Inbox’s `createRetryableTicket` on L1 (or a convenience like `depositEth` which under the hood creates a retryable). They specify:
  - The L2 target contract address and calldata (the action they want on L2).
  - An `l2CallValue` (ETH to send to the target on L2, if any).
  - A **max submission cost** (fee to pay for the ticket’s creation) and provide that in ETH on L1.
  - A **max gas** and **max fee per gas** for executing the L2 call, and deposit the expected gas cost (maxGas * maxFeePerGas) in ETH.
  - Two refund addresses: one for excess gas fee refund and one for call-value refund. These will receive any leftover funds if the ticket is canceled or if not all gas is used.
  - An optional flag for “auto-redeem.” In practice, if maxGas > 0, the system will attempt auto-redeem; if a user sets maxGas=0, they might be intending to manually redeem later.

  If this L1 call succeeds, it emits an event and inserts the message into Arbitrum’s inbox. The user has now paid upfront: (a) the **submission fee** (which covers the L1 cost of including the ticket, calculated based on size) and (b) the **execution deposit** (to cover the eventual L2 gas). These funds are escrowed by ArbOS on L2. The user gets a **unique Ticket ID** (essentially a hash identifying the retryable). 

- **Ticket Creation (L2):** When the L1 message is pulled into the Arbitrum chain, an **ArbitrumSubmitRetryableTx (type 105)** is executed. This causes ArbOS to officially **create the retryable ticket in the L2 state**, storing its parameters (target, calldata, etc.) and the escrowed funds . ArbOS emits a **`TicketCreated` event** on L2 (through the ArbRetryableTx precompile) with the ticket ID , so users can confirm the ticket’s existence. At this point, the ticket is in the retryable “queue.” 

  ArbOS will then immediately attempt an **auto-redeem** of the ticket *in the same block*, by scheduling an **ArbitrumRetryTx (type 104)**, **provided the user supplied gas for it**. The `maxGas` and `maxFeePerGas` from the ticket are used to execute the RetryTx (the user in essence pre-funded this execution). If the user did not supply any gas (e.g. they only deposited ETH and set gas limit to 0), then no auto-redeem is done and the ticket will just await manual redemption.

- **Auto-Redeem (L2):** The ArbitrumRetryTx executes the target call on L2. If it **succeeds**, the process is done: the contract effect is applied, and any remaining gas deposit is refunded to the user’s specified refund address (along with any unused submission cost). If it **fails** (for instance, the user underestimated gas and the call ran out of gas or reverted), then the ticket remains alive. The auto-redeem may have consumed all provided gas; any **unused gas** is refunded, but if it failed due to lack of gas, essentially the user would need to retry manually with more gas.

- **Waiting Period:** A newly created retryable ticket has a **time-to-live of 7 days by default**. During this window, the ticket can be redeemed (executed) by anyone. If the first attempt failed, the user (or any other incentivized actor) can call the ArbRetryableTx precompile’s `redeem(ticketID)` function to trigger another ArbitrumRetryTx in a future block. The user might do this to supply more gas or after debugging a failure. The cost to redeem is just the normal gas for executing the tx (which can be paid out of the escrowed funds). **Multiple attempts** can be made if it continues to fail, as long as the ticket hasn’t expired and still has gas funds. Each retry will consume from the escrowed gas deposit. Importantly, **the ticket is guaranteed to be executable at least once**; the submission fee paid on L1 covers that. If the user never redeems, the ticket just sits in the queue.

- **Expiration and Refunds:** If the 7-day period passes without a successful execution, the retryable ticket **expires** and is removed from the queue. When it expires, Arbitrum will **refund the remaining escrowed ETH**. The `maxGas * maxFeePerGas` that was set aside for gas, if still unused, is sent to the **excessFeeRefundAddress** the user provided . Any `callValue` that was meant to go to the L2 contract (which was held in escrow separately) is sent back to the **callValueRefundAddress**. Thus, the user doesn’t lose their money except the small submission cost (which was spent to create the ticket in the first place). Notably, Arbitrum supports **extending a ticket’s life** by paying an additional fee before it expires, effectively “keeping it alive” indefinitely if desired. But if no one does that, 7 days is the default lifetime.

- **Manual vs. Auto:** In most cases, users will provide enough gas and the auto-redeem will succeed, making the cross-chain call atomic (from the user’s perspective). If auto-redeem fails, users have the responsibility to notice the failure (the L2 transaction will show a failure) and redeem the ticket manually. Tools and the SDK help track retryable tickets and alert if they need manual execution. This mechanism is a trade-off: it ensures that even if an L2 execution fails, the user has a chance to fix it, rather than the transaction just being lost. It also prevents the user from *completely* wasting their L1 fees – they can always get back the call value and unused gas if it doesn’t execute.

From a functional standpoint, **retryable tickets make Arbitrum’s cross-chain UX robust**. Ethereum L1 has no equivalent concept – if you send a transaction on Ethereum and it runs out of gas or fails, the fee is lost and you must try again by sending a new transaction (with a new fee). On Arbitrum, the initial L1 fee covers *multiple tries* of the L2 action. The design ensures eventual completion or refund, which is important given the asynchronous nature of L1→L2 calls. It’s one of the more innovative aspects of Arbitrum Nitro’s transaction system  .

### Gas Accounting Differences (L1 vs L2 Fees)  
Every transaction on Arbitrum has to pay for two resources: **L2 execution gas** and **L1 data inclusion cost**. This is a major difference from a layer-1 Ethereum transaction which only pays for its own execution (and storage) on that chain. Key points on Arbitrum gas and fees:

- **Same EVM Gas for Computation:** For the L2 execution component, Arbitrum uses the same gas schedule as Ethereum. Every EVM opcode has the same gas cost it would on L1. If a contract uses 1 million gas on Ethereum, it will use 1 million gas on Arbitrum (assuming no Arbitrum-specific precompiles are involved). This was a deliberate design choice to preserve compatibility and make it easy to port contracts.

- **Additional L1 Calldata Cost:** In Arbitrum, a transaction’s data (and some overhead) must be posted to Ethereum. The **parent-chain cost** is essentially `calldata_bytes * L1_gas_per_byte * L1_basefee`. ArbOS estimates this cost for each transaction. It actually compresses the transaction data with Brotli and calculates a “compressed length” to charge – this encourages smaller L2 transaction sizes and shares cost among batched txs fairly. The **batch poster (sequencer)** initially pays the L1 gas to post the batch, so Arbitrum charges each transaction a fee to **reimburse the poster** for its share of that cost . This is handled by GasChargingHook as described: the fee is “set aside” from the user’s balance. In the transaction receipt, Arbitrum provides a field `gasUsedForL1` which is the **amount of L2 gas that was counted toward paying for the L1 posting** . (This is effectively the L1 fee expressed in L2 gas units.)

- **Two Fee Targets:** There are effectively two “base fees” in play on Arbitrum: 
  - The **L2 base fee** (often called just base fee) which pricing of L2 gas (computation/storage). This rises and falls based on L2 demand. Arbitrum implements a variant of EIP-1559: if there’s congestion (many full blocks), the basefee grows exponentially to throttle usage. If there’s idle capacity, it lowers. This basefee applies to the sum of execution gas + calldata gas (in converted units).
  - The **L1 data base price** which is Arbitrum’s internal estimate of the current cost per byte on Ethereum. ArbOS dynamically adjusts this “data price” to not consistently over- or under-charge users for L1 costs . It does this by monitoring the actual gas spent by recent batches vs. fees collected (maintaining a surplus/deficit and adjusting price)  . Users can query an estimate of this via ArbGasInfo or the NodeInterface API .

  When a user sends a transaction on Arbitrum, they specify `maxFeePerGas` and `maxPriorityFeePerGas` just like on Ethereum. Internally, Arbitrum uses the `maxFeePerGas` against the current L2 basefee (which includes both components). Importantly, since the sequencer doesn’t do auction-based inclusion, the **priority fee** (tip) is largely irrelevant – the user will “always just pay the basefee regardless of the tip”. The tip can be set to zero; the sequencer does not give preferential treatment for higher tips in the current design . 

- **Fee Allocation:** Where do the fees go? On Ethereum, the basefee is burned and the tip goes to the miner. On Arbitrum, no ETH is burned on L2; instead:
  - The portion of the fee corresponding to L1 costs is later **paid out to the batch poster** (the sequencer) to reimburse their Ethereum expenditure . This is crucial for the sequencer’s economic viability.
  - The portion corresponding to L2 execution (and any excess over actual L1 cost due to the pricing model) is credited to a **network fee pool/account** . This could be viewed as analogous to a miner reward, except there’s no competitive mining – it’s effectively revenue for the Arbitrum network or DAO to cover costs of validators, support initiatives, or potentially to burn under governance. Currently, the sequencer (Offchain Labs) may retain some of this as income, but with the Arbitrum DAO, these funds might be managed by the community in the future.
  
- **Gas Usage and Refunds:** Arbitrum supports Ethereum-like **gas refund mechanics** (e.g., for SSTORE clears) which reduce the execution gas cost (capped by half, similar to Ethereum’s rules). Those reduce the gas used and thus lower the fee. Additionally, Arbitrum’s ArbOS sometimes adds **non-recoverable gas charges** to certain operations – for example, the gas spent for the L1 fee is deliberately excluded from any refund calculations. ArbOS marks that portion as “NonRefundableGas” so that a contract can’t game the refund to get a free ride on posting costs . 

  After execution, any gas that was reserved but not used (for instance, if a user sent a tx with gas limit 2 million but only 1.5 million was needed) is *not billed* to them (just like on L1). Nitro’s EndTxHook will refund the difference appropriately. In Arbitrum’s case, if the user had over-paid the L1 data cost (because the estimate overshoots actual compressed size, or the basefee dipped), any surplus is accumulated as “surplus” and eventually fed into lowering the data price, as mentioned.

- **Block Gas and Throughput:** Arbitrum One currently targets a much higher throughput than Ethereum L1. Nitro can process on the order of 7–10x or more transactions per second relative to L1. The L2 block gas limit is flexible but large (for example, Arbitrum may target ~50 million gas per block, whereas Ethereum is around 30 million post-1559, and Arbitrum blocks can be more frequent). ArbOS uses a notion of a **gas pool** to smooth usage – if one block underuses gas, the remainder carries over to next block (up to some cap) . This is invisible to users, who just see that high loads can be sustained for short periods. The **gas accounting is designed so that over time, average usage stays within safe limits**, but momentary spikes are allowed. This improves throughput and latency for L2.

In essence, Arbitrum’s gas model extends Ethereum’s by adding the **dimension of L1 resource pricing**. Users are charged a fair share for the data their transactions add to the L1 chain , plus the normal execution fee. The protocol actively manages these fees to match costs and avoid economic loss for the sequencer. From a developer standpoint, these differences manifest in RPC fields like `gasUsedForL1` in receipts and the need to estimate L1 costs (Arbitrum provides `eth_estimateGas` that returns a result considering both L2 and L1 gas). Otherwise, interacting with gas on Arbitrum is similar to Ethereum – you provide a gas limit and max fee, and if it runs out, the tx reverts; if it’s too high, you get a refund; if basefee spikes above your max, your tx remains pending, etc., all analogous to L1 behavior .