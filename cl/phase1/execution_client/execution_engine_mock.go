// Code generated by MockGen. DO NOT EDIT.
// Source: ./interface.go
//
// Generated by this command:
//
//	mockgen -source=./interface.go -destination=./execution_engine_mock.go -package=execution_client . ExecutionEngine
//

// Package execution_client is a generated GoMock package.
package execution_client

import (
	context "context"
	big "math/big"
	reflect "reflect"

	common "github.com/ledgerwatch/erigon-lib/common"
	cltypes "github.com/ledgerwatch/erigon/cl/cltypes"
	types "github.com/ledgerwatch/erigon/core/types"
	engine_types "github.com/ledgerwatch/erigon/turbo/engineapi/engine_types"
	gomock "go.uber.org/mock/gomock"
)

// MockExecutionEngine is a mock of ExecutionEngine interface.
type MockExecutionEngine struct {
	ctrl     *gomock.Controller
	recorder *MockExecutionEngineMockRecorder
}

// MockExecutionEngineMockRecorder is the mock recorder for MockExecutionEngine.
type MockExecutionEngineMockRecorder struct {
	mock *MockExecutionEngine
}

// NewMockExecutionEngine creates a new mock instance.
func NewMockExecutionEngine(ctrl *gomock.Controller) *MockExecutionEngine {
	mock := &MockExecutionEngine{ctrl: ctrl}
	mock.recorder = &MockExecutionEngineMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockExecutionEngine) EXPECT() *MockExecutionEngineMockRecorder {
	return m.recorder
}

// CurrentHeader mocks base method.
func (m *MockExecutionEngine) CurrentHeader(ctx context.Context) (*types.Header, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CurrentHeader", ctx)
	ret0, _ := ret[0].(*types.Header)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CurrentHeader indicates an expected call of CurrentHeader.
func (mr *MockExecutionEngineMockRecorder) CurrentHeader(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CurrentHeader", reflect.TypeOf((*MockExecutionEngine)(nil).CurrentHeader), ctx)
}

// ForkChoiceUpdate mocks base method.
func (m *MockExecutionEngine) ForkChoiceUpdate(ctx context.Context, finalized, head common.Hash, attributes *engine_types.PayloadAttributes) ([]byte, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ForkChoiceUpdate", ctx, finalized, head, attributes)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ForkChoiceUpdate indicates an expected call of ForkChoiceUpdate.
func (mr *MockExecutionEngineMockRecorder) ForkChoiceUpdate(ctx, finalized, head, attributes any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ForkChoiceUpdate", reflect.TypeOf((*MockExecutionEngine)(nil).ForkChoiceUpdate), ctx, finalized, head, attributes)
}

// FrozenBlocks mocks base method.
func (m *MockExecutionEngine) FrozenBlocks(ctx context.Context) uint64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FrozenBlocks", ctx)
	ret0, _ := ret[0].(uint64)
	return ret0
}

// FrozenBlocks indicates an expected call of FrozenBlocks.
func (mr *MockExecutionEngineMockRecorder) FrozenBlocks(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FrozenBlocks", reflect.TypeOf((*MockExecutionEngine)(nil).FrozenBlocks), ctx)
}

// GetAssembledBlock mocks base method.
func (m *MockExecutionEngine) GetAssembledBlock(ctx context.Context, id []byte) (*cltypes.Eth1Block, *engine_types.BlobsBundleV1, *big.Int, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetAssembledBlock", ctx, id)
	ret0, _ := ret[0].(*cltypes.Eth1Block)
	ret1, _ := ret[1].(*engine_types.BlobsBundleV1)
	ret2, _ := ret[2].(*big.Int)
	ret3, _ := ret[3].(error)
	return ret0, ret1, ret2, ret3
}

// GetAssembledBlock indicates an expected call of GetAssembledBlock.
func (mr *MockExecutionEngineMockRecorder) GetAssembledBlock(ctx, id any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAssembledBlock", reflect.TypeOf((*MockExecutionEngine)(nil).GetAssembledBlock), ctx, id)
}

// GetBodiesByHashes mocks base method.
func (m *MockExecutionEngine) GetBodiesByHashes(ctx context.Context, hashes []common.Hash) ([]*types.RawBody, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetBodiesByHashes", ctx, hashes)
	ret0, _ := ret[0].([]*types.RawBody)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetBodiesByHashes indicates an expected call of GetBodiesByHashes.
func (mr *MockExecutionEngineMockRecorder) GetBodiesByHashes(ctx, hashes any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetBodiesByHashes", reflect.TypeOf((*MockExecutionEngine)(nil).GetBodiesByHashes), ctx, hashes)
}

// GetBodiesByRange mocks base method.
func (m *MockExecutionEngine) GetBodiesByRange(ctx context.Context, start, count uint64) ([]*types.RawBody, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetBodiesByRange", ctx, start, count)
	ret0, _ := ret[0].([]*types.RawBody)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetBodiesByRange indicates an expected call of GetBodiesByRange.
func (mr *MockExecutionEngineMockRecorder) GetBodiesByRange(ctx, start, count any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetBodiesByRange", reflect.TypeOf((*MockExecutionEngine)(nil).GetBodiesByRange), ctx, start, count)
}

// HasBlock mocks base method.
func (m *MockExecutionEngine) HasBlock(ctx context.Context, hash common.Hash) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HasBlock", ctx, hash)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// HasBlock indicates an expected call of HasBlock.
func (mr *MockExecutionEngineMockRecorder) HasBlock(ctx, hash any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HasBlock", reflect.TypeOf((*MockExecutionEngine)(nil).HasBlock), ctx, hash)
}

// InsertBlock mocks base method.
func (m *MockExecutionEngine) InsertBlock(ctx context.Context, block *types.Block) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "InsertBlock", ctx, block)
	ret0, _ := ret[0].(error)
	return ret0
}

// InsertBlock indicates an expected call of InsertBlock.
func (mr *MockExecutionEngineMockRecorder) InsertBlock(ctx, block any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InsertBlock", reflect.TypeOf((*MockExecutionEngine)(nil).InsertBlock), ctx, block)
}

// InsertBlocks mocks base method.
func (m *MockExecutionEngine) InsertBlocks(ctx context.Context, blocks []*types.Block, wait bool) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "InsertBlocks", ctx, blocks, wait)
	ret0, _ := ret[0].(error)
	return ret0
}

// InsertBlocks indicates an expected call of InsertBlocks.
func (mr *MockExecutionEngineMockRecorder) InsertBlocks(ctx, blocks, wait any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InsertBlocks", reflect.TypeOf((*MockExecutionEngine)(nil).InsertBlocks), ctx, blocks, wait)
}

// IsCanonicalHash mocks base method.
func (m *MockExecutionEngine) IsCanonicalHash(ctx context.Context, hash common.Hash) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsCanonicalHash", ctx, hash)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsCanonicalHash indicates an expected call of IsCanonicalHash.
func (mr *MockExecutionEngineMockRecorder) IsCanonicalHash(ctx, hash any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsCanonicalHash", reflect.TypeOf((*MockExecutionEngine)(nil).IsCanonicalHash), ctx, hash)
}

// NewPayload mocks base method.
func (m *MockExecutionEngine) NewPayload(ctx context.Context, payload *cltypes.Eth1Block, beaconParentRoot *common.Hash, versionedHashes []common.Hash) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "NewPayload", ctx, payload, beaconParentRoot, versionedHashes)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// NewPayload indicates an expected call of NewPayload.
func (mr *MockExecutionEngineMockRecorder) NewPayload(ctx, payload, beaconParentRoot, versionedHashes any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NewPayload", reflect.TypeOf((*MockExecutionEngine)(nil).NewPayload), ctx, payload, beaconParentRoot, versionedHashes)
}

// Ready mocks base method.
func (m *MockExecutionEngine) Ready(ctx context.Context) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Ready", ctx)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Ready indicates an expected call of Ready.
func (mr *MockExecutionEngineMockRecorder) Ready(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Ready", reflect.TypeOf((*MockExecutionEngine)(nil).Ready), ctx)
}

// SupportInsertion mocks base method.
func (m *MockExecutionEngine) SupportInsertion() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SupportInsertion")
	ret0, _ := ret[0].(bool)
	return ret0
}

// SupportInsertion indicates an expected call of SupportInsertion.
func (mr *MockExecutionEngineMockRecorder) SupportInsertion() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SupportInsertion", reflect.TypeOf((*MockExecutionEngine)(nil).SupportInsertion))
}
